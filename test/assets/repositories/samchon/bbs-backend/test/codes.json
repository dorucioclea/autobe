[
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_list_users_with_various_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\n\nexport async function test_list_users_with_various_filters_and_pagination(connection: api.IConnection): Promise<void> {\n  // 1. No filters (default pagination)\n  const resDefault = await api.functional.core.users.patch(connection, {\n    body: {},\n  });\n  typia.assert<IPageIUser.ISummary>(resDefault);\n  TestValidator.predicate(\"default result data is array\")(() => Array.isArray(resDefault.data));\n  TestValidator.predicate(\"default pagination current >= 1\")(() => resDefault.pagination.current >= 1);\n\n  // 2. Specific page and limit\n  const resPage2 = await api.functional.core.users.patch(connection, {\n    body: { page: 2, limit: 1 },\n  });\n  typia.assert<IPageIUser.ISummary>(resPage2);\n  TestValidator.equals(\"pagination current page\", undefined)(resPage2.pagination.current)(2);\n  TestValidator.equals(\"pagination limit\", undefined)(resPage2.pagination.limit)(1);\n  TestValidator.predicate(\"data is array for page 2, limit 1\")(() => Array.isArray(resPage2.data));\n\n  // 3. Filter by fake username (should return empty data)\n  const resNotFound = await api.functional.core.users.patch(connection, {\n    body: { search: \"this_user_does_not_exist_123!@#\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resNotFound);\n  TestValidator.equals(\"no result for impossible search\")([] as IUser.ISummary[])(resNotFound.data);\n\n  // 4. Filter by random/unknown role (should return empty result)\n  const resFakeRole = await api.functional.core.users.patch(connection, {\n    body: { role: \"00000000-0000-0000-0000-000000000000\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resFakeRole);\n  TestValidator.equals(\"no result for fake role\")([] as IUser.ISummary[])(resFakeRole.data);\n\n  // 5. Filter by impossible status (should return empty)\n  const resFakeStatus = await api.functional.core.users.patch(connection, {\n    body: { status: \"_____totallyFakeStatus_____\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resFakeStatus);\n  TestValidator.equals(\"no result for impossible status\")([] as IUser.ISummary[])(resFakeStatus.data);\n\n  // 6. Invalid negative page value (should be handled with error or fallback)\n  await TestValidator.httpError(\"negative page handled\")(400)(async () => {\n    await api.functional.core.users.patch(connection, {\n      body: { page: -1 },\n    });\n  });\n}\n",
    "completed": 12,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_search_users_with_role_and_keyword_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport typia from \"typia\";\n\nexport async function test_search_users_with_role_and_keyword_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create roles\n  const memberRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"Member\", description: \"Standard member role\" }\n  });\n  const moderatorRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"Moderator\", description: \"Moderator role\" }\n  });\n\n  // 2. Create users\n  // Member: 'alice', 'bob', Moderator: 'alicemod', 'charlie'\n  const userMemberAlice: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: memberRole.id,\n      username: \"alice\",\n      email: \"alice@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userMemberBob: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: memberRole.id,\n      username: \"bob\",\n      email: \"bob@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userModAlicemod: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: moderatorRole.id,\n      username: \"alicemod\",\n      email: \"alicemod@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userModCharlie: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: moderatorRole.id,\n      username: \"charlie\",\n      email: \"charlie@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  \n  // 3. Filter by role: should return only memberRole's users\n  const byRole: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: memberRole.id }\n  });\n  typia.assert<IPageIUser.ISummary>(byRole);\n  TestValidator.predicate(\"All users are members\")(byRole.data.every(u => u.role.id === memberRole.id));\n  TestValidator.equals(\"Only alice and bob returned by role\")([\n    userMemberAlice.username,\n    userMemberBob.username\n  ].sort())(byRole.data.map(u => u.username).sort());\n\n  // 4. Search by partial username (ali): should get 'alice', 'alicemod'\n  const byPartial: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { search: \"ali\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byPartial);\n  const expectedAli = [userMemberAlice.username, userModAlicemod.username].sort();\n  TestValidator.equals(\"Search by 'ali'\")(expectedAli)(byPartial.data.map(u => u.username).filter(x => x.includes(\"ali\")).sort());\n\n  // 5. Combined: role=Member and search='ali' (should return only 'alice')\n  const byRoleAndPartial: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: memberRole.id, search: \"ali\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byRoleAndPartial);\n  TestValidator.equals(\"Role member and 'ali' only alice\")([\"alice\"])(byRoleAndPartial.data.map(u => u.username));\n\n  // 6a. Edge: search by a role that does not exist â€“ expect empty result\n  const nonexistentUUID = \"12345678-aaaa-bbbb-cccc-123456789abc\";\n  const byNonexistentRole: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: nonexistentUUID }\n  });\n  typia.assert<IPageIUser.ISummary>(byNonexistentRole);\n  TestValidator.equals(\"Role does not exist returns empty\")([] as string[])(byNonexistentRole.data.map(u => u.username));\n\n  // 6b. Edge: search keyword that matches nobody (\"zzz\")\n  const byNoKeyword: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { search: \"zzz\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byNoKeyword);\n  TestValidator.equals(\"No keyword match returns empty\")([] as string[])(byNoKeyword.data.map(u => u.username));\n}\n",
    "completed": 59,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_retrieve_user_profile_by_id_success_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_retrieve_user_profile_by_id_success_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a new user to get a valid user ID\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `testuser_${Math.floor(Math.random() * 100000)}`,\n    email: `testuser_${Math.floor(Math.random() * 100000)}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n    bio: \"Test bio text.\",\n  };\n  const createdUser: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(createdUser);\n\n  // 2. Retrieve user profile by ID (success)\n  const fetchedUser: IUser = await api.functional.core.users.getById(connection, {\n    id: createdUser.id,\n  });\n  typia.assert<IUser>(fetchedUser);\n\n  // 3. Validate user fields match registration input\n  TestValidator.equals(\"user id\")(createdUser.id)(fetchedUser.id);\n  TestValidator.equals(\"username\")(createdUser.username)(fetchedUser.username);\n  TestValidator.equals(\"email\")(createdUser.email)(fetchedUser.email);\n  TestValidator.equals(\"user_role_id\")(createdUser.user_role_id)(fetchedUser.user_role_id);\n  TestValidator.equals(\"bio\")(createdUser.bio)(fetchedUser.bio);\n  TestValidator.equals(\"status\")(createdUser.status)(fetchedUser.status);\n\n  // 4. Attempt to retrieve non-existent user ID (404 expected)\n  const randomUserId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"User not found should return 404\")(404)(async () => {\n    await api.functional.core.users.getById(connection, { id: randomUserId });\n  });\n}\n",
    "completed": 26,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_register_new_user_edge_and_success_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_register_new_user_edge_and_success_cases(connection: api.IConnection): Promise<void> {\n  // 1. Create unique user role\n  const userRoleInput: IUserRole.ICreate = {\n    name: `testrole_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n    description: \"Test role for E2E user registration edge cases.\"\n  };\n  const userRole = await api.functional.core.userRoles.post(connection, { body: userRoleInput });\n  typia.assert<IUserRole>(userRole);\n\n  // 2. Register a new user with unique, valid data\n  const userInput: IUser.ICreate = {\n    user_role_id: userRole.id,\n    username: `testuser_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n    email: `test_${Date.now()}_${Math.floor(Math.random()*10000)}@email.com`,\n    bio: \"Edge case E2E bio.\",\n    password: \"VeryS3cretPassword!\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  // The returned user should match the input except password & timestamps (and include role)\n  TestValidator.equals(\"registered username matches\")(userInput.username)(user.username);\n  TestValidator.equals(\"registered email matches\")(userInput.email)(user.email);\n  TestValidator.equals(\"registered role assignment\")(userRole.id)(user.user_role_id);\n  TestValidator.equals(\"registered status matches\")(userInput.status)(user.status);\n  TestValidator.equals(\"registered bio matches\")(userInput.bio)(user.bio);\n  typia.assert<IUserRole>(user.role);\n\n  // 3. Negative case: Missing required field (omit email)\n  const missingEmail: IUser.ICreate = { ...userInput, email: undefined as any };\n  await TestValidator.httpError(\"missing email - should toss 400/422\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingEmail })\n  );\n  // 4. Negative: Missing username\n  const missingUsername: IUser.ICreate = { ...userInput, username: undefined as any };\n  await TestValidator.httpError(\"missing username\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingUsername })\n  );\n  // 5. Negative: Missing password\n  const missingPassword: IUser.ICreate = { ...userInput, password: undefined as any };\n  await TestValidator.httpError(\"missing password\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingPassword })\n  );\n  // 6. Negative: Invalid email format\n  const badEmail: IUser.ICreate = { ...userInput, email: \"not-a-valid-email\" as any };\n  await TestValidator.httpError(\"invalid email format\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: badEmail })\n  );\n  // 7. Negative: Duplicate username (same as prior successful submit)\n  const duplicateUsernameInput: IUser.ICreate = {\n    ...userInput,\n    email: `unique_${Date.now()}_${Math.floor(Math.random()*10000)}@mail.com`, // allow only username to duplicate\n  };\n  await TestValidator.httpError(\"duplicate username\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: duplicateUsernameInput })\n  );\n  // 8. Negative: Duplicate email (same email, new username)\n  const duplicateEmailInput: IUser.ICreate = {\n    ...userInput,\n    username: `othername_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n  };\n  await TestValidator.httpError(\"duplicate email\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: duplicateEmailInput })\n  );\n}\n",
    "completed": 29,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_update_user_profile_with_valid_and_invalid_conditions.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_update_user_profile_with_valid_and_invalid_conditions(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create two user roles\n  const role1: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role_${Date.now()}_1`,\n      description: \"Test Role 1\",\n    },\n  });\n  const role2: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role_${Date.now()}_2`,\n      description: \"Test Role 2\",\n    },\n  });\n\n  // Step 2: Register two users\n  const user1Reg: IUser.ICreate = {\n    user_role_id: role1.id,\n    username: `user1_${Date.now()}`,\n    email: `user1_${Date.now()}@test.com`,\n    bio: \"Bio user1\",\n    password: \"strongPassword1!\",\n    status: \"active\",\n  };\n  const user2Reg: IUser.ICreate = {\n    user_role_id: role2.id,\n    username: `user2_${Date.now()}`,\n    email: `user2_${Date.now()}@test.com`,\n    bio: \"Bio user2\",\n    password: \"strongPassword2!\",\n    status: \"active\",\n  };\n  const user1: IUser = await api.functional.core.users.post(connection, { body: user1Reg });\n  const user2: IUser = await api.functional.core.users.post(connection, { body: user2Reg });\n\n  // Step 3: Positive update for user1 (change email, username, bio, role)\n  const updEmail = `new_${user1.email}`;\n  const updUsername = `upd_${user1.username}`;\n  const updBio = \"Updated Bio for user1\";\n  const updated: IUser = await api.functional.core.users.putById(connection, {\n    id: user1.id,\n    body: {\n      email: updEmail,\n      username: updUsername,\n      bio: updBio,\n      user_role_id: role2.id,\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(updated);\n  TestValidator.equals(\"email should be updated\")<string>(updEmail)(updated.email);\n  TestValidator.equals(\"username should be updated\")<string>(updUsername)(updated.username);\n  TestValidator.equals(\"bio should be updated\")<string | null>(updBio)(updated.bio);\n  TestValidator.equals(\"role should be updated\")<string>(role2.id)(updated.user_role_id);\n\n  // Step 4: Negative - update user1 with duplicate email (from user2)\n  await TestValidator.httpError(\"duplicate email triggers conflict\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { email: user2.email },\n    });\n  });\n\n  // Step 5: Negative - update user1 with duplicate username (from user2)\n  await TestValidator.httpError(\"duplicate username triggers conflict\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { username: user2.username },\n    });\n  });\n\n  // Step 6: Negative - update user1 with invalid email format\n  await TestValidator.httpError(\"invalid email triggers validation error\")(400)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { email: \"not-an-email\" },\n    });\n  });\n\n  // Step 7: Negative - update non-existent user (random valid UUID)\n  const fakeId = typia.random<string & typia.tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"non-existent user triggers not found\")(404)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: fakeId,\n      body: { bio: \"Any\" },\n    });\n  });\n\n  // Step 8: (Optional) Set bio to null\n  const newNullBioUpdate: IUser = await api.functional.core.users.putById(connection, {\n    id: user1.id,\n    body: { bio: null },\n  });\n  typia.assert<IUser>(newNullBioUpdate);\n  TestValidator.equals(\"bio should be null\")(null)(newNullBioUpdate.bio);\n}\n",
    "completed": 51,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user/test_delete_user_soft_and_hard_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_delete_user_soft_and_hard_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a user\n  const userInput: IUser.ICreate = typia.random<IUser.ICreate>()\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Soft-delete the user\n  const delRes1 = await api.functional.core.users.eraseById(connection, {\n    id: user.id,\n  });\n  typia.assert<IUser.IDeleteResponse>(delRes1);\n  TestValidator.equals(\"delete user id\")<string | undefined>(delRes1.id)(user.id);\n  TestValidator.predicate(\"delete status present\")(() => !!delRes1.status);\n\n  // 3. Try deleting the same user again (should be 404 or similar error if hard delete required, or another specific error)\n  await TestValidator.httpError(\"deleting already-deleted user\")\n    (404)(() =>\n      api.functional.core.users.eraseById(connection, { id: user.id })\n    );\n\n  // 4. Delete a non-existent user (random uuid)\n  const fakeId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"deleting non-existent user\")\n    (404)(() =>\n      api.functional.core.users.eraseById(connection, { id: fakeId })\n    );\n}\n",
    "completed": 56,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_list_user_roles_with_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\n\nexport async function test_list_user_roles_with_filters_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create roles with diverse data.\n  const roleInputs: IUserRole.ICreate[] = [\n    { name: \"Moderator\", description: \"Can moderate content.\" },\n    { name: \"Administrator\", description: \"Full system privileges.\" },\n    { name: \"Member\", description: \"Standard member with limited permissions.\" },\n    { name: \"Editor\", description: \"Can edit articles but not moderate.\" },\n    { name: \"Guest\", description: \"Read-only access.\" },\n  ];\n  const createdRoles: IUserRole[] = [];\n  for (const input of roleInputs) {\n    const created = await api.functional.core.userRoles.post(connection, { body: input });\n    typia.assert<IUserRole>(created);\n    createdRoles.push(created);\n  }\n\n  // 2. List all roles (no filter), expect all created roles present\n  {\n    const page = await api.functional.core.userRoles.patch(connection, { body: {} });\n    typia.assert<IPageIUserRole>(page);\n    // The minimum expectation: all created names should be present at least once\n    const listedNames = page.data.map(r => r.name);\n    for (const input of roleInputs) {\n      TestValidator.predicate(`Role '${input.name}' should be listed`)(() => listedNames.includes(input.name));\n    }\n    // No duplicates\n    const nameSet = new Set(listedNames);\n    TestValidator.equals(\"no duplicates among listed roles\"<any>)(nameSet.size)(listedNames.length);\n  }\n\n  // 3. Filter by partial role name\n  {\n    const searchKeyword = \"Mod\";\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: searchKeyword } });\n    typia.assert<IPageIUserRole>(page);\n    // Should only include 'Moderator'\n    TestValidator.predicate(\"Expect role names to match search 'Mod'\")(\n      () => page.data.every(r => r.name.includes(searchKeyword)),\n    );\n  }\n\n  // 4. Filter by description keyword\n  {\n    const searchKeyword = \"edit\"; // should match \"Editor\" and description of Editor\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: searchKeyword } });\n    typia.assert<IPageIUserRole>(page);\n    TestValidator.predicate(\"Description keyword filter 'edit'\")(\n      () => page.data.some(r => r.name === \"Editor\"),\n    );\n  }\n\n  // 5. Negative: Search that yields zero results\n  {\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: \"NonExistentRole\" } });\n    typia.assert<IPageIUserRole>(page);\n    TestValidator.equals(\"Search yielding no results\")(0)(page.data.length);\n  }\n\n  // 6. Pagination correctness (limit=2, page=2)\n  {\n    const limit = 2;\n    const pageNum = 2;\n    const page = await api.functional.core.userRoles.patch(connection, { body: { limit, page: pageNum } });\n    typia.assert<IPageIUserRole>(page);\n    // Expect limit or less results\n    TestValidator.predicate(\"Page size limit respected\")(\n      () => page.data.length <= limit,\n    );\n    // Check page metadata\n    TestValidator.equals(\"pagination current page\")(pageNum)(page.pagination.current);\n    TestValidator.equals(\"pagination limit\")(limit)(page.pagination.limit);\n    // No duplicates within this page\n    const namesInPage = page.data.map(r => r.name);\n    const nameSet = new Set(namesInPage);\n    TestValidator.equals(\"no duplicates in paged data\"<any>)(nameSet.size)(namesInPage.length);\n  }\n}\n",
    "completed": 41,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_list_user_roles_with_invalid_filter_parameters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_list_user_roles_with_invalid_filter_parameters(\n  connection: api.IConnection,\n): Promise<void> {\n  // List of invalid filter requests\n  const invalidBodies: IUserRole.IRequest[] = [\n    { page: -1 }, // negative page\n    { limit: 0 }, // zero limit\n    { limit: -100 }, // negative limit\n    { limit: 1_000_000 }, // excessive limit\n    { page: 1, search: \"a\".repeat(2_000) }, // too long search string\n  ];\n\n  // Test each invalid request and expect HTTP 400/422 error\n  for (const body of invalidBodies) {\n    await TestValidator.httpError(\"invalid userRoles filter\")\n      (400, 422)\n      (async () => {\n        await api.functional.core.userRoles.patch(connection, { body });\n      });\n  }\n\n  // Also test with totally malformed body (not matching IRequest)\n  await TestValidator.httpError(\"malformed body - not an object\")(400, 422)\n    (async () => {\n      // @ts-expect-error Intentionally wrong type\n      await api.functional.core.userRoles.patch(connection, { body: \"not-an-object\" });\n    });\n}",
    "completed": 34,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_get_user_role_by_valid_and_invalid_id_with_auth_checks.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_user_role_getById_all_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user role\n  const createInput: IUserRole.ICreate = {\n    name: `test_role_${Math.random().toString(36).substring(2, 10)}`,\n    description: \"E2E test role description.\"\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // 2. Retrieve the user role by valid ID\n  const retrieved: IUserRole = await api.functional.core.userRoles.getById(connection, { id: created.id });\n  typia.assert<IUserRole>(retrieved);\n  TestValidator.equals(\"getById result should match role name\")<string>(createInput.name)(retrieved.name);\n  TestValidator.equals(\"getById result should match description\")<string>(createInput.description)(retrieved.description);\n\n  // 3. Attempt to retrieve a non-existent user role (random UUID)\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"should be 404 for non-existent role\")(404)(\n    () => api.functional.core.userRoles.getById(connection, { id: nonExistentId })\n  );\n\n  // 4. Attempt to retrieve a user role without auth (simulate by omitting headers if possible)\n  if (connection.headers && connection.headers[\"Authorization\"]) {\n    const noAuthConnection = { ...connection, headers: { ...connection.headers } };\n    delete noAuthConnection.headers[\"Authorization\"];\n    await TestValidator.httpError(\"should require auth\")(401, 403)(\n      () => api.functional.core.userRoles.getById(noAuthConnection, { id: created.id })\n    );\n  }\n}\n",
    "completed": 37,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_get_user_role_access_forbidden_for_insufficient_privileges.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Test: Access user role as insufficient privilege user (should receive 403 Forbidden)\n */\nexport async function test_get_user_role_access_forbidden_for_insufficient_privileges(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a custom role (assumed to lack admin privileges)\n  const roleInput: IUserRole.ICreate = {\n    name: `readonly-test-role-${Math.random().toString(36).slice(2, 10)}`,\n    description: \"Minimal-privilege test role for forbidden access test.\",\n  };\n  const userRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert<IUserRole>(userRole);\n\n  // Step 2: Register a new user with this role\n  const userInput: IUser.ICreate = {\n    user_role_id: userRole.id,\n    username: `testuser_${Math.random().toString(36).slice(2, 8)}`,\n    email: `test_${Math.random().toString(36).slice(2, 8)}@testmail.com`,\n    bio: \"Test user bio.\",\n    password: \"P@ssw0rd123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // Step 3: Simulate as that user (replace authentication context if needed)\n  const userConnection: api.IConnection = {\n    ...connection,\n    // If authentication mechanism uses header/token, inject here:\n    // headers: { ...connection.headers, Authorization: `Bearer ${userAccessToken}` }\n    // For simulation, keep as original. Real test suite should provide session switching helpers.\n  };\n\n  // Step 4: Attempt to get role info as this user, expect 403 Forbidden\n  await TestValidator.httpError(\"Should throw 403 Forbidden when insufficient user role.\")(403)(async () => {\n    await api.functional.core.userRoles.getById(userConnection, { id: userRole.id });\n  });\n}\n",
    "completed": 47,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_create_user_role_with_valid_and_invalid_payloads.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_create_user_role_with_valid_and_invalid_payloads(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare valid unique payload\n  const uniqueRoleName =\n    \"test_role_\" + Math.random().toString(36).slice(2, 10) + Date.now();\n  const validInput: IUserRole.ICreate = {\n    name: uniqueRoleName,\n    description: \"A test role for E2E validation.\" ,\n  };\n\n  // 2. Happy path: Create with valid fields\n  const created = await api.functional.core.userRoles.post(connection, { body: validInput });\n  typia.assert<IUserRole>(created);\n  TestValidator.equals(\"user role name should match\")<string>(validInput.name)(created.name);\n  TestValidator.equals(\"description should match\")<string>(validInput.description)(created.description);\n\n  // 3. Duplicate role name: should fail (uniqueness)\n  await TestValidator.httpError(\"duplicate role name returns error\")(400, 409)(async () => {\n    // Try to create a second role with the exact same name\n    await api.functional.core.userRoles.post(connection, {\n      body: validInput,\n    });\n  });\n\n  // 4. Missing required field: name omitted\n  await TestValidator.httpError(\"missing name returns error\")(400)(async () => {\n    // @ts-expect-error - testing missing required field\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        description: \"desc only\"\n      },\n    });\n  });\n\n  // 5. Missing required field: description omitted\n  await TestValidator.httpError(\"missing description returns error\")(400)(async () => {\n    // @ts-expect-error - testing missing required field\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        name: \"role_missing_desc\"\n      },\n    });\n  });\n\n  // 6. Empty string fields -- name\n  await TestValidator.httpError(\"empty name returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        name: \"\",\n        description: \"test desc\"\n      },\n    });\n  });\n\n  // 7. Empty string fields -- description\n  await TestValidator.httpError(\"empty description returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        name: \"role_empty_desc\",\n        description: \"\"\n      },\n    });\n  });\n}\n",
    "completed": 42,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_update_user_role_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_update_user_role_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a new user role to ensure an updatable entity exists\n  const createPayload: IUserRole.ICreate = {\n    name: `test-role-${Date.now()}`,\n    description: \"A temporary test role for update E2E test.\",\n  };\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    { body: createPayload },\n  );\n  typia.assert<IUserRole>(createdRole);\n\n  // Step 2: Prepare update values for name and description\n  const updatedName = `updated-role-${Date.now()}`;\n  const updatedDescription = \"Updated test role description.\";\n  const updatePayload: IUserRole.IUpdate = {\n    name: updatedName,\n    description: updatedDescription,\n  };\n\n  // Step 3: Update the user role by ID\n  const updatedRole: IUserRole = await api.functional.core.userRoles.putById(\n    connection,\n    {\n      id: createdRole.id,\n      body: updatePayload,\n    },\n  );\n  typia.assert<IUserRole>(updatedRole);\n\n  // Step 4: Assertions\n  // (a) ID remains unchanged\n  TestValidator.equals(\"id unchanged\")(createdRole.id)(updatedRole.id);\n  // (b) Name and description were updated\n  TestValidator.equals(\"name updated\")(updatedName)(updatedRole.name);\n  TestValidator.equals(\"description updated\")(updatedDescription)(updatedRole.description);\n}\n",
    "completed": 5,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_update_user_role_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Generate a random UUID that does not exist\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  // 2. Prepare valid role update data\n  const updateBody: IUserRole.IUpdate = {\n    name: \"nonexistent-role-update-test\",\n    description: \"Attempting to update a role that does not exist.\",\n  };\n\n  // 3. Attempt to update and assert a 404 error is received\n  await TestValidator.httpError(\"Should return 404 for non-existent user role ID\")(404)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    });\n  });\n}\n",
    "completed": 32,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_update_user_role_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_update_user_role_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a valid user role for target\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"temporary_role_test_invalid_update\",\n      description: \"Role created to test invalid update fields\"\n    }\n  });\n  typia.assert<IUserRole>(created);\n\n  // Invalid case a: Empty string for name\n  await TestValidator.httpError(\"empty name should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        name: \"\",\n      },\n    });\n  });\n\n  // Invalid case b: Empty string for description\n  await TestValidator.httpError(\"empty description should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        description: \"\",\n      },\n    });\n  });\n\n  // Invalid case c: Both fields omitted (empty object)\n  await TestValidator.httpError(\"omitted fields should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {},\n    });\n  });\n\n  // Invalid case d: Malformed types (numbers instead of strings)\n  await TestValidator.httpError(\"name as number should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        // @ts-expect-error\n        name: 123,\n      } as any,\n    });\n  });\n  await TestValidator.httpError(\"description as number should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        // @ts-expect-error\n        description: 456,\n      } as any,\n    });\n  });\n}\n",
    "completed": 17,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_delete_user_role_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * E2E test for deleting a user role and verifying deletion.\n * - Creates a role\n * - Deletes it\n * - Asserts delete response\n * - Attempts to retrieve it (expects error)\n */\nexport async function test_api_core_userRoles_delete_and_verify(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user role\n  const createInput: IUserRole.ICreate = typia.random<IUserRole.ICreate>();\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // 2. Delete the created user role\n  const delResp: IUserRole.IDeleteResponse = await api.functional.core.userRoles.eraseById(connection, { id: created.id });\n  typia.assert<IUserRole.IDeleteResponse>(delResp);\n  TestValidator.equals(\"deleted id matches created\")(created.id)(delResp.id!);\n  if (delResp.status) {\n    TestValidator.predicate(\"delete status is 'deleted'\")(() => delResp.status === \"deleted\");\n  }\n\n  // 3. Attempt to retrieve the deleted role (expect error 404)\n  // Assumes a GET /core/userRoles/{id} exists in the API\n  if (api.functional.core.userRoles.getById) {\n    await TestValidator.httpError(\"deleted role cannot be retrieved\")(404, 410)(\n      () => api.functional.core.userRoles.getById(connection, { id: created.id })\n    );\n  }\n  // Negative path: try to delete again (expect not found)\n  await TestValidator.httpError(\"delete non-existent role fails\")(404)(\n    () => api.functional.core.userRoles.eraseById(connection, { id: created.id })\n  );\n}\n",
    "completed": 28,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_delete_user_role_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n// E2E test: Deleting a non-existent user role must result in a 404 Not Found error\nexport async function test_delete_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Generate a random UUID for testing non-existent user role\n  const randomId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>()\n\n  // Attempt to delete the non-existent user role; expect HTTP 404\n  await TestValidator.httpError(\"Should fail with 404 for non-existent user role\")(404)(\n    () => api.functional.core.userRoles.eraseById(connection, { id: randomId })\n  );\n}\n",
    "completed": 38,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "user-role/test_delete_user_role_assigned_to_user.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_user_role_assigned_to_user(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a new user role\n  const roleName = `role_${Math.random().toString(36).substring(2, 12)}`;\n  const roleDescription = \"A temporary user role for assignment test.\";\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    {\n      body: {\n        name: roleName,\n        description: roleDescription,\n      },\n    },\n  );\n  typia.assert(createdRole);\n  TestValidator.predicate(\"Role creation: must have id\")(() => !!createdRole.id);\n\n  // Step 2: Register a new user assigned to this role\n  const userName = `user_${Math.random().toString(36).substring(2, 12)}`;\n  const userEmail = `${userName}@example.com`;\n  const userPassword = \"Test1234!\";\n  const createdUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: createdRole.id,\n      username: userName,\n      email: userEmail,\n      bio: \"Test assignment bio.\",\n      password: userPassword,\n      status: \"active\",\n    },\n  });\n  typia.assert(createdUser);\n  TestValidator.equals(\"User role assignment\")(\n    createdUser.user_role_id,\n  )(createdRole.id);\n\n  // Step 3: Attempt to delete the user role while it is still assigned\n  await TestValidator.httpError(\"Should block role deletion while assigned\")(\n    400, 403, 409,\n  )(async () => {\n    await api.functional.core.userRoles.eraseById(connection, {\n      id: createdRole.id,\n    });\n  });\n\n  // Step 4: (Optional) Attempt a second deletion for idempotency test\n  await TestValidator.httpError(\"Repeat deletion still blocked\")(\n    400, 403, 409,\n  )(async () => {\n    await api.functional.core.userRoles.eraseById(connection, {\n      id: createdRole.id,\n    });\n  });\n}\n",
    "completed": 46,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_list_categories_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\n\nexport async function test_list_categories_with_pagination_and_filters(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare: Create 5 test categories with different names/descriptions\n  const categories: ICategory[] = [];\n  for (let i = 0; i < 5; i++) {\n    const name = `test-cat-${i}`;\n    const description = `description tag ${i % 2 === 0 ? \"even\" : \"odd\"}`;\n    const created = await api.functional.core.categories.post(connection, {\n      body: { name, description },\n    });\n    typia.assert<ICategory>(created);\n    categories.push(created);\n  }\n\n  // 2. Test Pagination: limit = 2, page = 1\n  const pageReq: ICategory.IRequest = { page: 1, limit: 2 };\n  const paged1 = await api.functional.core.categories.patch(connection, {\n    body: pageReq,\n  });\n  typia.assert<IPageICategory>(paged1);\n  TestValidator.equals(\"pagination current page\")(1)(paged1.pagination.current);\n  TestValidator.equals(\"pagination limit\")(2)(paged1.pagination.limit);\n  TestValidator.equals(\"data length\")(2)(paged1.data.length);\n\n  // Next page\n  const paged2 = await api.functional.core.categories.patch(connection, {\n    body: { ...pageReq, page: 2 },\n  });\n  typia.assert<IPageICategory>(paged2);\n  TestValidator.equals(\"pagination current page\")(2)(paged2.pagination.current);\n  TestValidator.equals(\"data length\")(2)(paged2.data.length);\n\n  // 3. Test Filtering by name (exact)\n  const filterName = categories[1].name;\n  const filteredByName = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, name: filterName },\n  });\n  typia.assert<IPageICategory>(filteredByName);\n  TestValidator.equals(\"filtered name all match\")(true)(\n    filteredByName.data.every((cat) => cat.name === filterName),\n  );\n\n  // 4. Test Filtering by description (substring)\n  const filterDesc = \"even\";\n  const filteredByDesc = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, description: filterDesc },\n  });\n  typia.assert<IPageICategory>(filteredByDesc);\n  TestValidator.equals(\"filtered desc contains\")(true)(\n    filteredByDesc.data.every((cat) => cat.description.includes(filterDesc)),\n  );\n\n  // 5. Edge Case: limit = 1\n  const lim1Resp = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 1 },\n  });\n  typia.assert<IPageICategory>(lim1Resp);\n  TestValidator.equals(\"pagination limit-1\")(1)(lim1Resp.pagination.limit);\n  TestValidator.equals(\"data length limit-1\")(1)(lim1Resp.data.length);\n\n  // 6. Edge Case: out-of-range page (should return empty data array)\n  const bigPageResp = await api.functional.core.categories.patch(connection, {\n    body: { page: 100, limit: 10 },\n  });\n  typia.assert<IPageICategory>(bigPageResp);\n  TestValidator.equals(\"empty data for non-existent page\")(\n    [] as ICategory[],\n  )(bigPageResp.data);\n\n  // 7. Edge Case: no matching filter (name doesn't exist)\n  const noMatchResp = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, name: \"__zz_NOPE619312__\" },\n  });\n  typia.assert<IPageICategory>(noMatchResp);\n  TestValidator.equals(\"empty data for filter miss\")(\n    [] as ICategory[],\n  )(noMatchResp.data);\n}\n",
    "completed": 39,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_get_category_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_api_category_get_by_valid_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new category\n  const createInput: ICategory.ICreate = {\n    name: `Test Category ${Date.now()}`,\n    description: \"A category created for testing getById.\"\n  };\n\n  const created: ICategory = await api.functional.core.categories.post(connection, { body: createInput });\n  typia.assert<ICategory>(created);\n\n  // 2. Fetch the category by its ID\n  const fetched: ICategory = await api.functional.core.categories.getById(connection, { id: created.id });\n  typia.assert<ICategory>(fetched);\n\n  // 3. Validate all expected fields match\n  TestValidator.equals(\"id\")(created.id)(fetched.id);\n  TestValidator.equals(\"name\")(created.name)(fetched.name);\n  TestValidator.equals(\"description\")(created.description)(fetched.description);\n  TestValidator.equals(\"created_at\")(created.created_at)(fetched.created_at);\n}\n",
    "completed": 24,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_get_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_category_get_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Generate a random UUID that is highly unlikely to exist\n  const fakeId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Assert that calling getById with a non-existent ID returns a 404 Not Found error\n  await TestValidator.httpError(\"should return 404 for non-existent category\")(404)(\n    () => api.functional.core.categories.getById(connection, { id: fakeId })\n  );\n}\n",
    "completed": 9,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_create_category_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_valid_data(connection: api.IConnection): Promise<void> {\n    // Step 1: Prepare category creation input\n    const input: ICategory.ICreate = {\n        name: `TestCategory_${Date.now()}`,\n        description: \"A category created for E2E testing.\"\n    };\n\n    // Step 2: Attempt to create the category\n    const result: ICategory = await api.functional.core.categories.post(connection, {\n        body: input,\n    });\n\n    // Step 3: Assert output conforms to ICategory\n    typia.assert<ICategory>(result);\n\n    // Step 4: Validate the response fields against input\n    TestValidator.equals(\"category.name\")(input.name)(result.name);\n    TestValidator.equals(\"category.description\")(input.description)(result.description);\n    // UUID and created_at should exist and be non-empty\n    TestValidator.predicate(\"category.id is uuid\")(!!result.id && typeof result.id === \"string\");\n    TestValidator.predicate(\"category.created_at is valid timestamp\")(!!result.created_at && typeof result.created_at === \"string\");\n}\n",
    "completed": 19,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_create_category_with_duplicate_or_missing_label.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_duplicate_or_missing_label(connection: api.IConnection): Promise<void> {\n  // 1. Prepare a valid category input\n  const validCategory: ICategory.ICreate = {\n    name: \"Unique Category Name\",\n    description: \"Description for unique category, should succeed.\"\n  };\n\n  // 2. Create the category (should succeed)\n  const created = await api.functional.core.categories.post(connection, { body: validCategory });\n  typia.assert<ICategory>(created);\n  TestValidator.equals(\"Created category name\")<string>(validCategory.name)(created.name);\n\n  // 3. Try to create a category with duplicate name\n  await TestValidator.httpError(\"Duplicate category name should fail\")(409)(async () => {\n    await api.functional.core.categories.post(connection, { body: validCategory });\n  });\n\n  // 4. Try to create with missing name (omit 'name' field)\n  // We need to bypass TypeScript, so use type assertion\n  const missingNameCategory = {\n    description: \"Missing name\"\n  } as any;\n  await TestValidator.httpError(\"Missing name field should fail\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingNameCategory });\n  });\n\n  // 5. Try to create with empty name (invalid value)\n  const emptyNameCategory: ICategory.ICreate = {\n    name: \"\",\n    description: \"Empty name should fail.\"\n  };\n  await TestValidator.httpError(\"Empty name should trigger validation error\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: emptyNameCategory });\n  });\n\n  // 6. Try to create with missing description\n  const missingDescCategory = {\n    name: \"CategoryWithNoDescription\"\n  } as any;\n  await TestValidator.httpError(\"Missing description field should fail\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingDescCategory });\n  });\n}\n",
    "completed": 23,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_update_category_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\n/**\n * Test updating a category's name and/or description using valid data.\n * 1. Create a fresh category.\n * 2. Update its name and description.\n * 3. Assert that the response reflects the intended changes and preserves immutable fields.\n */\nexport async function test_update_category_with_valid_data(\n  connection: api.IConnection\n): Promise<void> {\n  // Step 1: Create a category to update\n  const initialInput: ICategory.ICreate = {\n    name: `í…ŒìŠ¤íŠ¸ì¹´í…Œê³ ë¦¬_${Date.now()}`,\n    description: \"ì—…ë°ì´íŠ¸ ì „ ì¹´í…Œê³ ë¦¬ ì„¤ëª…ìž…ë‹ˆë‹¤.\",\n  };\n  const original: ICategory = await api.functional.core.categories.post(\n    connection,\n    { body: initialInput }\n  );\n  typia.assert<ICategory>(original);\n\n  // Step 2: Prepare updated data\n  const updateInput: ICategory.IUpdate = {\n    name: original.name + \"_ë³€ê²½\", // Change name\n    description: \"ìˆ˜ì •ëœ ì¹´í…Œê³ ë¦¬ ì„¤ëª…ìž…ë‹ˆë‹¤.\", // Change description\n  };\n\n  // Step 3: Update the category\n  const updated: ICategory = await api.functional.core.categories.putById(\n    connection,\n    {\n      id: original.id,\n      body: updateInput,\n    }\n  );\n  typia.assert<ICategory>(updated);\n\n  // Step 4: Validate the update result\n  TestValidator.equals(\"category id should not change\")(original.id)(updated.id);\n  TestValidator.equals(\"created_at should not change\")(original.created_at)(updated.created_at);\n  TestValidator.equals(\"updated name\")(updateInput.name!)(updated.name);\n  TestValidator.equals(\"updated description\")(updateInput.description!)(updated.description);\n\n  // Step 5: Optionally, verify that values actually changed\n  TestValidator.predicate(\"name should be different after update\")(\n    original.name !== updated.name\n  );\n  TestValidator.predicate(\"description should be different after update\")(\n    original.description !== updated.description\n  );\n}\n",
    "completed": 31,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_update_category_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_category_with_invalid_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // Step 1: Create a valid category to obtain an ID\n  const original: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `test-update-invalid-fields-${Date.now()}`,\n      description: \"Initial description for validation case.\"\n    }\n  });\n  typia.assert(original);\n\n  // Helper for fetching category again if needed\n  const fetchCategory = async () => {\n    // If GET by ID existed, would use here\n    return original;\n  };\n\n  // Step 2: Attempt update: empty name (should be invalid)\n  await TestValidator.httpError(\"put with empty name should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        name: \"\"\n      }\n    });\n  });\n\n  // Step 3: Attempt update: empty description string (assuming not allowed)\n  await TestValidator.httpError(\"put with empty description should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        description: \"\"\n      }\n    });\n  });\n\n  // Step 4: Attempt update: both fields empty strings\n  await TestValidator.httpError(\"put with both name/desc empty should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        name: \"\",\n        description: \"\"\n      }\n    });\n  });\n\n  // Step 5: Valid update should succeed â€“ control scenario\n  const updated: ICategory = await api.functional.core.categories.putById(connection, {\n    id: original.id,\n    body: {\n      name: original.name + \"-updated\",\n      description: original.description + \" (edited)\"\n    }\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"category updated name\")(original.name + \"-updated\")(updated.name);\n  TestValidator.equals(\"category updated description\")(original.description + \" (edited)\")(updated.description);\n}\n",
    "completed": 27,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_update_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_category_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Generate a valid random UUID for a non-existent category\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>() as string & tags.Format<\"uuid\">;\n  // Step 2: Prepare a valid update payload (can update one or both fields)\n  const updatePayload: ICategory.IUpdate = {\n    name: \"NonExistentCategory\",\n    description: \"Attempt to update a non-existent category.\"\n  };\n\n  // Step 3 & 4: Attempt update, expect 404 error\n  await TestValidator.httpError(\"Should fail with 404 Not Found\")(404)(\n    () => api.functional.core.categories.putById(connection, {\n      id: nonExistentId,\n      body: updatePayload\n    })\n  );\n}\n",
    "completed": 11,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_delete_category_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * E2E test for deleting a category and verifying it cannot be retrieved.\n */\nexport async function test_delete_category_and_verify_deletion(connection: api.IConnection): Promise<void> {\n    // Step 1: Create a new category\n    const createInput: ICategory.ICreate = {\n        name: `e2e_category_${Math.random().toString(36).substring(2, 10)}`,\n        description: \"E2E test category for deletion test\"\n    };\n\n    const category: ICategory = await api.functional.core.categories.post(connection, {\n        body: createInput\n    });\n    typia.assert(category);\n    TestValidator.predicate(\"Category is created and has valid id\")(() => typeof category.id === \"string\" && category.id.length > 0);\n\n    // Step 2: Delete the category\n    const deleteResult = await api.functional.core.categories.eraseById(connection, { id: category.id });\n    typia.assert<ICategory.IDeleteResult>(deleteResult);\n    TestValidator.predicate(\"Category delete succeeded\")(() => deleteResult.success === true);\n\n    // Step 3: Attempt to GET the deleted category, expect 404 Not Found\n    await TestValidator.httpError(\"Category should not be found after deletion\")(404)(\n        async () => {\n            // We expect GET by id function to exist, but it's not defined in provided API set.\n            // If/when api.functional.core.categories.getById exists, replace below:\n            if (typeof api.functional.core.categories.getById === \"function\") {\n                // @ts-expect-error: getById API not officially defined in spec, placeholder for future.\n                await api.functional.core.categories.getById(connection, { id: category.id });\n            } else {\n                throw new Error(\"GET /core/categories/:id endpoint not provided in API SDK\");\n            }\n        }\n    );\n}\n",
    "completed": 40,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "category/test_delete_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_delete_category_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  const fakeId = typia.random<string & tags.Format<\"uuid\">>();\n\n  await TestValidator.httpError(\"Trying to delete non-existent category should return 404\")(404)(\n    () => api.functional.core.categories.eraseById(connection, { id: fakeId })\n  );\n}\n",
    "completed": 6,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_list_posts_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\n\nexport async function test_list_posts_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // Replace with a valid user_role_id as needed\n    username: `author_${Math.random().toString(36).substring(2, 8)}`,\n    email: `author_${Date.now()}@test.com`,\n    bio: \"Test author bio\",\n    password: \"password1234!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `Category_${Math.random().toString(36).substring(2, 9)}`,\n    description: \"E2E test category description\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create multiple posts\n  const posts: IPost[] = [];\n  for (let i = 0; i < 3; ++i) {\n    const postInput: IPost.ICreate = {\n      category_id: category.id,\n      title: `Test Post Title ${i + 1}`,\n      content: `This is content for post #${i + 1}`,\n      user_id: user.id,\n    };\n    const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n    typia.assert<IPost>(post);\n    posts.push(post);\n  }\n\n  // 4a. List by author id\n  let req: IPost.IRequest = { user_id: user.id, page: 1, limit: 10 };\n  let page: IPageIPost = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by author id\")(() => page.data.every((p) => p.user_id === user.id));\n\n  // 4b. List by category id\n  req = { category_id: category.id, page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by category id\")(() => page.data.every((p) => p.category_id === category.id));\n\n  // 4c. By both user_id & category_id\n  req = { user_id: user.id, category_id: category.id, page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by user and category\")(\n    () => page.data.every((p) => p.category_id === category.id && p.user_id === user.id),\n  );\n\n  // 4d. By title keyword\n  req = { title: \"Test Post Title 1\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all contain title keyword\")(\n    () => page.data.every((p) => p.title.includes(\"Test Post Title 1\")),\n  );\n\n  // 4e. Pagination (limit=2)\n  req = { page: 1, limit: 2 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"limit is two\")<number>(2)(page.pagination.limit);\n  TestValidator.predicate(\"at most 2 records\")(() => page.data.length <= 2);\n\n  // 4f. Pagination page 2 (limit=1)\n  req = { page: 2, limit: 1 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"current is page 2\")<number>(2)(page.pagination.current);\n\n  // 6. Negative tests - random user, category, or title (should be empty data)\n  req = { user_id: \"00000000-0000-0000-0000-000000000000\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-existing user\")<IPost[]>([])(page.data);\n\n  req = { category_id: \"00000000-0000-0000-0000-000000000000\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-existing category\")<IPost[]>([])(page.data);\n\n  req = { title: \"DefinitelyNoSuchTitleKeywordExist\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-match title\")<IPost[]>([])(page.data);\n}\n",
    "completed": 54,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_get_post_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_posts_getById_with_valid_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Create a user (as author)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `author_${Date.now()}`,\n    email: `author_${Date.now()}@example.com`,\n    bio: \"Post author for test\",\n    password: \"test-password-1234\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const catInput: ICategory.ICreate = {\n    name: `category_${Date.now()}`,\n    description: \"E2E Test Category\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: catInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post\n  const postInput: IPost.ICreate = {\n    user_id: user.id,\n    category_id: category.id,\n    title: `Test Post Title - ${Date.now()}`,\n    content: \"This is the content of the test post.\",\n  };\n  const createdPost: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(createdPost);\n\n  // 4. Retrieve the post by its ID\n  const retrieved: IPost = await api.functional.posts.posts.getById(connection, {\n    id: createdPost.id,\n  });\n  typia.assert<IPost>(retrieved);\n\n  // 5. Assertions for field match and presence\n  TestValidator.equals(\"id match\")(createdPost.id)(retrieved.id);\n  TestValidator.equals(\"author (user_id) match\")(createdPost.user_id)(retrieved.user_id);\n  TestValidator.equals(\"category_id match\")(createdPost.category_id)(retrieved.category_id);\n  TestValidator.equals(\"title match\")(createdPost.title)(retrieved.title);\n  TestValidator.equals(\"content match\")(createdPost.content)(retrieved.content);\n  TestValidator.equals(\"created_at match\")(createdPost.created_at)(retrieved.created_at);\n  TestValidator.equals(\"updated_at match\")(createdPost.updated_at)(retrieved.updated_at);\n  TestValidator.equals(\"deleted_at match\")(\n    createdPost.deleted_at ?? null\n  )(retrieved.deleted_at ?? null);\n\n  // 6. Field presence and type assertions\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.id);\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.user_id);\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.category_id);\n  typia.assert<string>(retrieved.title);\n  typia.assert<string>(retrieved.content);\n  typia.assert<string & tags.Format<\"date-time\">>(retrieved.created_at);\n  typia.assert<string & tags.Format<\"date-time\">>(retrieved.updated_at);\n  if (retrieved.deleted_at !== undefined && retrieved.deleted_at !== null) {\n    typia.assert<string & tags.Format<\"date-time\">>(retrieved.deleted_at);\n  }\n}\n",
    "completed": 44,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_get_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    await TestValidator.httpError(\"Should return 404 for missing post\")(404)(\n        async () => {\n            await api.functional.posts.posts.getById(connection, { id: nonExistentId });\n        }\n    );\n}\n",
    "completed": 1,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_create_post_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\n/**\n * Create a valid new post with all required fields (title, author, category, content).\n * Verifies the post is persisted by checking the returned post's properties.\n */\nexport async function test_create_post_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create a test user (must supply user_role_id: use dummy UUID for member)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\", // dummy, assumed valid for test\n    username: `test_user_${Date.now()}`,\n    email: `user_${Date.now()}@example.com`,\n    password: \"password123\",\n    status: \"active\",\n    bio: \"Test e2e user.\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.equals(\"user.username\")(userInput.username)(user.username);\n  TestValidator.equals(\"user.status\")(userInput.status)(user.status);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `test_category_${Date.now()}`,\n    description: \"E2E test category\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n  TestValidator.equals(\"category.name\")(categoryInput.name)(category.name);\n\n  // 3. Prepare post creation input\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: `Test Post ${Date.now()}`,\n    content: \"This is the main body of the e2e-created post.\",\n    user_id: user.id\n    // created_at intentionally omitted\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 4. Validate the post is correctly linked\n  TestValidator.equals(\"post.title\")(postInput.title)(post.title);\n  TestValidator.equals(\"post.content\")(postInput.content)(post.content);\n  TestValidator.equals(\"post.user_id\")(postInput.user_id)(post.user_id);\n  TestValidator.equals(\"post.category_id\")(postInput.category_id)(post.category_id);\n  TestValidator.predicate(\"post.created_at exists\")(() => !!post.created_at);\n  TestValidator.predicate(\"post.updated_at exists\")(() => !!post.updated_at);\n  TestValidator.equals(\"post.deleted_at (should be null)\")(null)(post.deleted_at ?? null);\n}",
    "completed": 33,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_create_post_with_missing_required_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_missing_required_fields(connection: api.IConnection): Promise<void> {\n  // Create a valid user for post creation\n  const user = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\", // dummy valid uuid (replace as needed)\n      username: `e2e_test_${Date.now()}`,\n      email: `e2e_test_${Date.now()}@example.com`,\n      bio: \"test user\",\n      password: \"TestPassword1234!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // Create a valid category\n  const category = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `e2e_cat_${Date.now()}`,\n      description: \"E2E Test Category\",\n    },\n  });\n  typia.assert<ICategory>(category);\n\n  // 1. Missing title\n  await TestValidator.httpError(\"Missing title\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          // title omitted\n          content: \"This is the post content.\",\n          user_id: user.id,\n        } as any,\n      });\n    });\n\n  // 2. Missing content\n  await TestValidator.httpError(\"Missing content\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          title: \"No Content Post\",\n          // content omitted\n          user_id: user.id,\n        } as any,\n      });\n    });\n\n  // 3. Missing user_id\n  await TestValidator.httpError(\"Missing user_id\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          title: \"User Unspecified\",\n          content: \"This is the post content.\",\n          // user_id omitted\n        } as any,\n      });\n    });\n\n  // 4. Missing category_id\n  await TestValidator.httpError(\"Missing category_id\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          // category_id omitted\n          title: \"No Category\",\n          content: \"This is the post content.\",\n          user_id: user.id,\n        } as any,\n      });\n    });\n}\n",
    "completed": 13,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_create_post_with_duplicate_unique_field.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_duplicate_unique_field(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // must be valid, replace with actual test role id\n    username: `user_${Date.now()}`,\n    email: `user${Date.now()}@example.com`,\n    password: \"testPassword123!\",\n    status: \"active\",\n    bio: null,\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `TestCategory_${Date.now()}`,\n    description: \"Test category for duplicate post test\",\n  };\n  const category = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create the first post with a fixed 'title' as a unique candidate\n  const postTitle = `UniquePostTitle_${Date.now()}`;\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: postTitle,\n    content: \"This post is used to check uniqueness constraint.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 4. Attempt to create the second post with the exact same title, category_id, and user_id\n  // If API's unique constraint is stricter (e.g., on slug, or title+category+user), adjust test accordingly\n  await TestValidator.httpError(\"Should reject duplicate post creation\")(400)(async () => {\n    await api.functional.posts.posts.post(connection, { body: postInput });\n  });\n}\n",
    "completed": 16,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_update_post_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_update_post_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const userCreate: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `user_${Math.random().toString(36).substring(2, 8)}`,\n    email: `user_${Math.random().toString(36).substring(2, 8)}@test.com`,\n    password: \"TestPass123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userCreate });\n  typia.assert<IUser>(user);\n\n  // 2. Create category\n  const categoryCreate: ICategory.ICreate = {\n    name: `category_${Math.random().toString(36).substring(2, 8)}`,\n    description: \"A test category for posts update scenario.\" \n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryCreate });\n  typia.assert<ICategory>(category);\n\n  // 3. Create post\n  const postCreate: IPost.ICreate = {\n    category_id: category.id,\n    title: \"Original Title\",\n    content: \"Original post content for updating.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postCreate });\n  typia.assert<IPost>(post);\n\n  // 4. Prepare post update (change title, content, category)\n  const updateTitle = \"Updated Title\";\n  const updateContent = \"Updated content body!\";\n  // Optional: Change category (create another category)\n  const newCategoryCreate: ICategory.ICreate = {\n    name: `category_${Math.random().toString(36).substring(2, 8)}`,\n    description: \"Another category to test category_id change.\"\n  };\n  const newCategory: ICategory = await api.functional.core.categories.post(connection, { body: newCategoryCreate });\n  typia.assert<ICategory>(newCategory);\n\n  const postUpdate: IPost.IUpdate = {\n    title: updateTitle,\n    content: updateContent,\n    category_id: newCategory.id,\n  };\n\n  // 5. Update the post\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post.id,\n    body: postUpdate,\n  });\n  typia.assert<IPost>(updated);\n\n  // 6. Validate the updates\n  TestValidator.equals(\"updated.title\")<string>(updateTitle)(updated.title);\n  TestValidator.equals(\"updated.content\")<string>(updateContent)(updated.content);\n  TestValidator.equals(\"updated.category_id\")<string>(newCategory.id)(updated.category_id);\n  TestValidator.equals(\"updated.id should be unchanged\")<string>(post.id)(updated.id);\n  TestValidator.equals(\"updated.user_id should be unchanged\")<string>(post.user_id)(updated.user_id);\n\n  // 7. Optionally, check updated_at is changed\n  TestValidator.predicate(\"updated_at changed\")(() => updated.updated_at !== post.updated_at);\n}\n",
    "completed": 22,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_update_post_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_post_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create user (author)\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `author_${Math.random().toString(36).slice(2)}`,\n      email: `author_${Math.random().toString(36).slice(2)}@test.com`,\n      password: \"password!123\",\n      bio: \"test user\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create a category\n  const category: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `category_${Math.random().toString(36).slice(2)}`,\n      description: \"Discussion category\",\n    },\n  });\n  typia.assert<ICategory>(category);\n\n  // Step 3: Create a valid post for updating\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: category.id,\n      title: \"Valid Post Title\",\n      content: \"A valid post body.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Step 4: Try invalid update scenarios\n  // (a) Empty content\n  await TestValidator.httpError(\"empty content should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { content: \"\" },\n    });\n  });\n\n  // (b) Empty title\n  await TestValidator.httpError(\"empty title should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { title: \"\" },\n    });\n  });\n\n  // (c) Invalid category_id (not a uuid)\n  await TestValidator.httpError(\"invalid category_id should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { category_id: \"not-a-uuid\" as any },\n    });\n  });\n\n  // (d) Both title and content empty or undefined\n  await TestValidator.httpError(\"missing fields should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {}, // no updatable fields\n    });\n  });\n\n  // (e) Extra, non-existent field in body\n  await TestValidator.httpError(\"extra field should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      // @ts-expect-error: purposely inject invalid extra field\n      body: { title: \"Test\", not_real_field: 123 },\n    });\n  });\n\n  // (f) Valid update (title and content both updated)\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post.id,\n    body: { title: \"Updated!\", content: \"Updated content.\" },\n  });\n  typia.assert<IPost>(updated);\n  TestValidator.equals(\"post updated\")<IPost>({\n    ...post,\n    title: \"Updated!\",\n    content: \"Updated content.\",\n  })({ ...updated, updated_at: post.updated_at }); // Ignore updated_at in strict check\n}\n",
    "completed": 14,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_update_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_post_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare a random but valid update body\n  const updateBody: IPost.IUpdate = {\n    title: \"Non-existent Post Title\",\n    content: \"This update should not succeed.\",\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n  };\n\n  // 2. Generate a random UUID for non-existent post ID\n  const nonExistentId: string & tags.Format<\"uuid\"> =\n    typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3,4,5,6. Attempt update, expect 404 Not Found error\n  await TestValidator.httpError(\n    \"Should fail updating non-existent post ID\",\n  )(404)(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    })\n  );\n}\n",
    "completed": 4,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_delete_post_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_delete_post_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Register a user (author)\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const category: ICategory = await api.functional.core.categories.post(connection, {\n    body: typia.random<ICategory.ICreate>(),\n  });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post with above author and category\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: \"E2E Deletion Test Post\",\n    content: \"Content for deletion verification scenario.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: postInput,\n  });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"created post matches input\")<string>(post.title)(postInput.title);\n  TestValidator.equals(\"created post has category_id\")<string>(post.category_id)(category.id);\n  TestValidator.equals(\"created post has user_id\")<string>(post.user_id)(user.id);\n\n  // 4. Delete the post\n  const delResult: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: post.id,\n  });\n  typia.assert<IPost.IDeleteResult>(delResult);\n  TestValidator.equals(\"post delete result success flag\")(true)(delResult.success);\n\n  // 5. Verify deleted post is not accessible (expect 404 error)\n  await TestValidator.httpError(\"get deleted post returns 404\")(404)(async () => {\n    // post get API not shown in inputs; using posts.posts.post listing is not sufficient\n    // If posts.posts.getById API available, use it. For this scenario, assume getById exists.\n    // Uncomment if function exists:\n    // await api.functional.posts.posts.getById(connection, { id: post.id });\n    // Instead, simulate by attempting to delete again (which should 404 if not found)\n    await api.functional.posts.posts.eraseById(connection, { id: post.id });\n  });\n}\n",
    "completed": 45,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "post/test_delete_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Step 1: Generate a random UUID that should not exist in the posts collection\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Step 2: Attempt to delete the post\n  const output: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: nonExistentId,\n  });\n\n  // Step 3: Validate output structure strictly\n  typia.assert<IPost.IDeleteResult>(output);\n\n  // Step 4: Assert that the deletion was unsuccessful\n  TestValidator.predicate(\"should fail to delete a non-existent post\")(output.success === false);\n  TestValidator.predicate(\"should return a failure message\")(!!output.message && typeof output.message === \"string\");\n  // Optionally, you might assert exact error code or error pattern in output.message here\n}\n",
    "completed": 21,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_list_comments_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\nimport typia from \"typia\";\n\nexport async function test_list_comments_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // Step 1: Create users\n  const user1: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\", // Should refer to existing user_role\n      username: \"commenter1\" + Date.now(),\n      email: `u1_${Date.now()}@test.com`,\n      password: \"password1!\",\n      bio: \"User 1 for comments\",\n      status: \"active\",\n    }\n  });\n  const user2: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\",\n      username: \"commenter2\" + Date.now(),\n      email: `u2_${Date.now()}@test.com`,\n      password: \"password2!\",\n      bio: \"User 2 for comments\",\n      status: \"active\",\n    }\n  });\n  // Step 2: Create posts\n  const post1: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"22222222-2222-2222-2222-222222222222\", // Should refer to existing category\n      title: `Post 1 at ${Date.now()}`,\n      content: \"Post 1 for comment list test.\",\n      user_id: user1.id,\n    },\n  });\n  const post2: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"22222222-2222-2222-2222-222222222222\",\n      title: `Post 2 at ${Date.now()}`,\n      content: \"Post 2 for comment list test.\",\n      user_id: user2.id,\n    },\n  });\n  // Step 3: Add comments; 4-user/post combos, 2 comments each\n  const comments: IComment[] = [];\n  for (const post of [post1, post2]) {\n    for (const user of [user1, user2]) {\n      for (let i = 0; i < 2; ++i) {\n        const comment: IComment = await api.functional.posts.comments.post(connection, {\n          body: {\n            user_id: user.id,\n            post_id: post.id,\n            content: `Comment ${i + 1} by ${user.username} on post ${post.title}`,\n          },\n        });\n        comments.push(comment);\n      }\n    }\n  }\n  // Step 4: Pagination - limit/offset\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 3, offset: 0 },\n    });\n    typia.assert(resp);\n    TestValidator.predicate(\"Page should have at most 3 items\")(resp.data.length <= 3);\n    TestValidator.predicate(\"Pagination meta present\")(!!resp.pagination);\n  }\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 3, offset: 3 },\n    });\n    typia.assert(resp);\n    TestValidator.predicate(\"Page 2 items present (may be fewer than 3)\")(resp.data.length >= 0 && resp.data.length <= 3);\n  }\n  // Step 5: Filter by post_id\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: post1.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Filter by post\")(post1.id)(summary.post_id);\n    }\n  }\n  // Filter by user_id\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { userId: user2.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Filter by user\")(user2.id)(summary.user_id);\n    }\n  }\n  // Filter by both\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: post2.id, userId: user1.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Post\")(post2.id)(summary.post_id);\n      TestValidator.equals(\"User\")(user1.id)(summary.user_id);\n    }\n  }\n  // Step 6: Sorting (created_at desc/asc)\n  {\n    const respAsc: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { sort: \"created_at:asc\" }\n    });\n    typia.assert(respAsc);\n    for (let i = 1; i < respAsc.data.length; ++i) {\n      TestValidator.predicate(\"Asc sorted\")(\n        respAsc.data[i-1].created_at <= respAsc.data[i].created_at\n      );\n    }\n    const respDesc: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { sort: \"created_at:desc\" }\n    });\n    typia.assert(respDesc);\n    for (let i = 1; i < respDesc.data.length; ++i) {\n      TestValidator.predicate(\"Desc sorted\")(\n        respDesc.data[i-1].created_at >= respDesc.data[i].created_at\n      );\n    }\n  }\n  // Step 7: Edge case - out-of-range\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 2, offset: 9999 },\n    });\n    typia.assert(resp);\n    TestValidator.equals(\"Out-of-range page is empty\")([] as IComment.ISummary[])(resp.data);\n  }\n  // Step 8: Filter for post/user with no comments\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: \"e0000000-0000-0000-0000-000000000000\" },\n    });\n    typia.assert(resp);\n    TestValidator.equals(\"No comments on fake post\")([] as IComment.ISummary[])(resp.data);\n  }\n}\n",
    "completed": 58,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_get_comment_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_get_comment_by_valid_id(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<typeof user[\"user_role_id\"]>(),\n      username: `testuser_${Math.random().toString(36).substring(2, 10)}`,\n      email: `test_${Math.random().toString(36).substring(2, 10)}@example.com`,\n      password: \"SecureP@ssw0rd!\",\n      status: \"active\",\n      bio: \"E2E test user\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post by this user (category id must be valid format)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<typeof post[\"category_id\"]>(),\n      title: \"Test Post for Comment Detail E2E\",\n      content: \"Post content for comment fetching test.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a comment on the above post by this user\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: {\n      user_id: user.id,\n      post_id: post.id,\n      content: \"This is a test comment for detail fetch.\",\n    },\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Fetch the comment by its ID\n  const output: IComment = await api.functional.posts.comments.getById(connection, {\n    id: comment.id,\n  });\n  typia.assert<IComment>(output);\n\n  // 5. Validate fields match what was created\n  TestValidator.equals(\"comment id match\")(comment.id)(output.id);\n  TestValidator.equals(\"user id match\")(comment.user_id)(output.user_id);\n  TestValidator.equals(\"post id match\")(comment.post_id)(output.post_id);\n  TestValidator.equals(\"content match\")(comment.content)(output.content);\n  // parent_id can be undefined/null (top-level comment)\n  TestValidator.equals(\"parent_id match\")(comment.parent_id ?? null)(output.parent_id ?? null);\n}\n",
    "completed": 57,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_get_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n/**\n * E2E: Get Comment with Non-Existent ID (404 not found)\n */\nexport async function test_api_posts_comments_getById_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  // Make multiple random attempts to reduce accidental existence\n  for (let i = 0; i < 2; ++i) {\n    await TestValidator.httpError(\"Getting comment with non-existent ID should 404\")(404)(async () => {\n      await api.functional.posts.comments.getById(connection, { id: nonExistentId });\n    });\n  }\n\n  // Test with an obviously malformed UUID if the API validates format\n  const invalidId = \"not-a-uuid\" as string & tags.Format<\"uuid\">;\n  await TestValidator.error(\"Should reject malformed ID\")(() =>\n    api.functional.posts.comments.getById(connection, { id: invalidId }),\n  );\n}\n",
    "completed": 15,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_create_comment_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\n// Simple equality except dynamic properties\ntype ExceptDynamic = (key: string) => boolean;\nconst exceptDynamic: ExceptDynamic = (key) =>\n  key === \"id\" ||\n  key === \"created_at\" ||\n  key === \"updated_at\" ||\n  key === \"deleted_at\";\n\nexport async function test_create_comment_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register new user (commenter)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // Use a valid default role id as test fixture\n    username: `test_commenter_${Math.random().toString(36).substring(2, 10)}`,\n    email: `test_commenter_${Date.now()}@example.com`,\n    bio: \"E2E test commenter user\",\n    password: \"SecureP@ssword!2025\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.predicate(\"user created\")(!!user.id);\n\n  // 2. Create a post authored by the new user\n  const postInput: IPost.ICreate = {\n    category_id: \"22222222-2222-2222-2222-222222222222\", // Use a stable test category for isolation\n    title: \"Test Post for Comment E2E\",\n    content: \"This is the body for a test post.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"post.user_id\")(postInput.user_id)(post.user_id);\n  TestValidator.predicate(\"post created\")(!!post.id);\n\n  // 3. Add a comment to the post as the user\n  const commentContent = \"This is a test comment created via E2E.\";\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: commentContent,\n  };\n  const comment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert<IComment>(comment);\n  TestValidator.equals(\"comment.user_id\")(commentInput.user_id)(comment.user_id);\n  TestValidator.equals(\"comment.post_id\")(commentInput.post_id)(comment.post_id);\n  TestValidator.equals(\"comment.content\")(commentInput.content)(comment.content);\n\n  // 4. Ensure returned comment references the right author and post, content correct\n  TestValidator.predicate(\"comment id exists\")(!!comment.id);\n  TestValidator.predicate(\"comment.created_at exists\")(!!comment.created_at);\n  TestValidator.equals(\"parent_id\")(undefined)(comment.parent_id);\n\n  // (No GET or search for comments by id available in SDK for further confirmation)\n}\n",
    "completed": 53,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_create_comment_with_missing_required_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_missing_required_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Register a new user.\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"b6f98808-17dc-4cee-b454-15f2a3815dcb\", // replace with a valid role_id in your system\n      username: `testuser_missing_field_${Date.now()}`,\n      email: `missing_required_${Date.now()}@test.com`,\n      password: \"testpassword123!\",\n      status: \"active\",\n      bio: \"Test user for comment missing field test\" \n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a valid post for association.\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"a0c717b0-40df-421a-8735-148beed4858a\", // replace with valid category_id in your DB\n      title: \"Test Post for Missing Comment Fields\",\n      content: \"This post is to test missing comment fields.\",\n      user_id: user.id\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Valid comment body for reference\n  const validComment: IComment.ICreate = {\n    content: \"This is a valid content for comment.\",\n    user_id: user.id,\n    post_id: post.id\n  };\n\n  // 3a. Omit 'content'\n  await TestValidator.httpError(\"No content should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id,\n        post_id: post.id\n        // content missing\n      } as any\n    })\n  );\n\n  // 3b. Omit 'post_id'\n  await TestValidator.httpError(\"No post_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id,\n        content: \"Comment without post reference.\"\n        // post_id missing\n      } as any\n    })\n  );\n\n  // 3c. Omit 'user_id'\n  await TestValidator.httpError(\"No user_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        post_id: post.id,\n        content: \"Comment without user reference.\"\n        // user_id missing\n      } as any\n    })\n  );\n\n  // 3d. Omit both 'content' and 'post_id'\n  await TestValidator.httpError(\"Missing content and post_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id\n        // content and post_id missing\n      } as any\n    })\n  );\n\n  // 5. Valid case: All fields present\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: validComment\n  });\n  typia.assert<IComment>(comment);\n}\n",
    "completed": 30,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_create_comment_with_non_existent_post.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_non_existent_post(connection: api.IConnection): Promise<void> {\n  // 1. Create a valid user\n  const newUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\", // Use a fixed or mock valid role UUID\n      username: `ghost_writer_${Date.now()}`,\n      email: `ghost_writer_${Date.now()}@example.com`,\n      bio: \"Test ghost author\",\n      password: \"test_password_bogus_post_!\",\n      status: \"active\"\n    }\n  });\n  typia.assert(newUser);\n\n  // 2. Construct a comment with a non-existent post_id\n  const bogusPostId = \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\"; // Must NOT exist in DB\n  const commentInput: IComment.ICreate = {\n    user_id: newUser.id,\n    post_id: bogusPostId,\n    content: \"This should not succeed: referencing a bogus post id.\"\n  };\n\n  // 3~4. Attempt to comment and expect 400 or 404 error only\n  await TestValidator.httpError(\"Creating comment for non-existent post must fail\")(400, 404)(async () => {\n    await api.functional.posts.comments.post(connection, { body: commentInput });\n  });\n}\n",
    "completed": 7,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_update_comment_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_update_comment_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Replace with a valid role UUID if needed\n    username: `testuser_${Math.random().toString(36).substring(7)}`,\n    email: `testuser_${Math.random().toString(36).substring(7)}@example.com`,\n    bio: \"Test user bio\",\n    password: \"securePassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert(user);\n\n  // 2. Create post\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // Replace with a valid category UUID if needed\n    title: \"A post for comment test\",\n    content: \"Original post content.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert(post);\n\n  // 3. Create comment\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"Original comment content.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert(comment);\n\n  // 4. Update comment content\n  const updatedContent = \"Updated comment body.\";\n  const updateInput: IComment.IUpdate = { content: updatedContent };\n  const updatedComment: IComment = await api.functional.posts.comments.putById(connection, { id: comment.id, body: updateInput });\n  typia.assert(updatedComment);\n\n  // 5. Assertions - content updated, other fields retained\n  TestValidator.equals(\"id\")<string>()(comment.id)(updatedComment.id);\n  TestValidator.equals(\"user_id\")<string>()(comment.user_id)(updatedComment.user_id);\n  TestValidator.equals(\"post_id\")<string>()(comment.post_id)(updatedComment.post_id);\n  TestValidator.equals(\"content\")<string>()(updatedContent)(updatedComment.content);\n  TestValidator.predicate(\"updated_at is updated\")(() => updatedComment.updated_at !== comment.updated_at);\n  TestValidator.equals(\"deleted_at\")<(string | null) | undefined>()(comment.deleted_at)(updatedComment.deleted_at);\n}\n",
    "completed": 48,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_update_comment_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\n// E2E test: Attempt to update a comment with missing/invalid fields and validate error response\nexport async function test_update_comment_with_invalid_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Register a new user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `e2e_invalid_update_${Date.now()}`,\n    email: `e2e_invalid_update_${Date.now()}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"E2E Invalid Comment Update Post\",\n    content: \"Initial post content for invalid comment update test.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 3. Create a valid comment\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This is a valid comment for invalid update test.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: commentInput,\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Attempt invalid update: empty content\n  const invalidUpdate: IComment.IUpdate = { content: \"\" };\n  await TestValidator.httpError(\"should reject empty content\")(400)(async () => {\n    await api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: invalidUpdate,\n    });\n  });\n\n  // 5. Attempt update: missing content field (send empty object)\n  const missingContentUpdate: IComment.IUpdate = {};\n  // Should either return error or keep the comment unchanged (depending on API's required fields policy for updates)\n  await TestValidator.httpError(\"should reject missing content field\")(400, 422)(async () => {\n    await api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: missingContentUpdate,\n    });\n  });\n}\n",
    "completed": 50,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_update_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\n// E2E: Attempt to update a comment with a non-existent ID and expect a 404 Not Found\nexport async function test_update_comment_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  const randomId = typia.random<string & tags.Format<\"uuid\">>();\n  const updateBody: IComment.IUpdate = {\n    content: \"This new content should not be applied.\",\n  };\n\n  await TestValidator.httpError(\"Should return 404 for non-existent comment update\")(404)(\n    async () =>\n      await api.functional.posts.comments.putById(connection, {\n        id: randomId,\n        body: updateBody,\n      })\n  );\n}\n",
    "completed": 3,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_delete_comment_and_verify_soft_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_comment_and_verify_soft_deletion(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register user\n  const userCreate: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `testuser_${Math.random().toString(36).slice(2, 10)}`,\n    email: `test_${Math.random().toString(36).slice(2,8)}@test.com`,\n    bio: null,\n    password: \"Password!123\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, {\n    body: userCreate,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create post for comment\n  const postCreate: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"Test post for comment soft deletion\",\n    content: \"Post needed for comment soft deletion test.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, {\n    body: postCreate,\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create comment to be deleted\n  const commentCreate: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This comment will be soft-deleted.\",\n  };\n  const comment = await api.functional.posts.comments.post(connection, {\n    body: commentCreate,\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Soft-delete the comment\n  const eraseResult = await api.functional.posts.comments.eraseById(connection, {\n    id: comment.id,\n  });\n  typia.assert<IComment.IDeleteResult>(eraseResult);\n  TestValidator.equals(\"delete result - id\")(comment.id)(eraseResult.id);\n  TestValidator.equals(\"delete result - deleted\")(true)(eraseResult.deleted);\n  TestValidator.predicate(\"delete result - has message\")(\n    typeof eraseResult.message === \"undefined\" || typeof eraseResult.message === \"string\"\n  );\n  // 5. (Optional) Try to fetch comment to confirm soft delete (API not exposed), so skip.\n  // 6. (Optional) Try repeat deletion for error, if applicable (not implemented here).\n}\n",
    "completed": 25,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "comment/test_delete_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Attempt to delete a comment with a non-existent ID and confirm a 404 error is produced.\n */\nexport async function test_delete_comment_with_non_existent_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Generate a random UUID\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Attempt deletion and expect a 404 (not found) error\n  await TestValidator.httpError(\"Should return 404 when deleting non-existent comment\")(404)(\n    () =>\n      api.functional.posts.comments.eraseById(connection, {\n        id: nonExistentId,\n      })\n  );\n}\n",
    "completed": 10,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_list_votes_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\n\nexport async function test_list_votes_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n    // 1. Register two users\n    const user1: IUser = await api.functional.core.users.post(connection, {\n        body: {\n            user_role_id: typia.random<string>(),\n            username: `voter1_${Math.random().toString(36).slice(2, 8)}`,\n            email: `voter1_${Math.random().toString(36).slice(2, 8)}@test.com`,\n            password: \"password1!\",\n            status: \"active\",\n            bio: \"First voting user\"\n        },\n    });\n    const user2: IUser = await api.functional.core.users.post(connection, {\n        body: {\n            user_role_id: typia.random<string>(),\n            username: `voter2_${Math.random().toString(36).slice(2, 8)}`,\n            email: `voter2_${Math.random().toString(36).slice(2, 8)}@test.com`,\n            password: \"password2!\",\n            status: \"active\",\n            bio: \"Second voting user\"\n        },\n    });\n    typia.assert(user1);\n    typia.assert(user2);\n    \n    // 2. Create a post (as user1)\n    const post: IPost = await api.functional.posts.posts.post(connection, {\n        body: {\n            category_id: typia.random<string>(),\n            title: \"Test voting post\",\n            content: \"This post is created for voting test.\",\n            user_id: user1.id,\n        },\n    });\n    typia.assert(post);\n\n    // 3. User1 and User2 vote on the post\n    const vote1: IVote = await api.functional.votes.votes.post(connection, {\n        body: {\n            user_id: user1.id,\n            value: 1,\n            post_id: post.id,\n        },\n    });\n    const vote2: IVote = await api.functional.votes.votes.post(connection, {\n        body: {\n            user_id: user2.id,\n            value: -1,\n            post_id: post.id,\n        },\n    });\n    typia.assert(vote1);\n    typia.assert(vote2);\n\n    // 4. Retrieve all votes (no filters)\n    const allVotesPage: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: {},\n    });\n    typia.assert(allVotesPage);\n    TestValidator.predicate(\"Should have at least 2 votes...\")(() => allVotesPage.data.length >= 2);\n\n    // 5. Filter by user1\n    const user1Votes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { userId: user1.id },\n    });\n    typia.assert(user1Votes);\n    TestValidator.predicate(\"User1 vote filter\")(user1Votes.data.every(v => v.user_id === user1.id));\n    TestValidator.predicate(\"User1 vote count >=1\")(user1Votes.data.length >= 1);\n\n    // 6. Filter by post\n    const postVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { postId: post.id },\n    });\n    typia.assert(postVotes);\n    TestValidator.predicate(\"Post vote filter\")(postVotes.data.every(v => v.post_id === post.id));\n    TestValidator.predicate(\"Post vote user set\")(new Set(postVotes.data.map(v => v.user_id)).has(user1.id) && new Set(postVotes.data.map(v => v.user_id)).has(user2.id));\n\n    // 7. Pagination (limit=1)\n    const pagedVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { limit: 1 },\n    });\n    typia.assert(pagedVotes);\n    TestValidator.equals(\"Limit 1 pagination\")(\n      1\n    )(pagedVotes.data.length);\n    TestValidator.predicate(\"Paginated metadata shows more or equal pages\")(() => pagedVotes.pagination.pages >= 1);\n\n    // 8. Negative test: invalid filter with both postId + commentId\n    await TestValidator.error(\"Mutually exclusive filter (postId + commentId)\")(\n        async () => {\n            await api.functional.votes.votes.patch(connection, {\n                body: {\n                    postId: post.id,\n                    commentId: typia.random<string>(),\n                },\n            });\n        }\n    );\n\n    // 9. Validate all responses structurally\n    [allVotesPage, user1Votes, postVotes, pagedVotes].forEach(page => {\n        typia.assert<IPageIVote>(page);\n        page.data.forEach((vote) => typia.assert<IVote.ISummary>(vote));\n    });\n}\n",
    "completed": 55,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_get_vote_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_get_vote_by_valid_id(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a user (the voter)\n  const createUserInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `vote-test-user-${Math.random().toString(36).substring(2, 8)}`,\n    email: `vote${Math.random().toString(36).substring(2, 8)}@example.com`,\n    password: \"Password123!\",\n    status: \"active\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: createUserInput });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create a post to be voted on\n  const createPostInput: IPost.ICreate = {\n    category_id: typia.random<string>(),\n    title: \"Sample Post for Vote Retrieval\",\n    content: \"This is a post to test vote lookup.\",\n    user_id: user.id\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: createPostInput });\n  typia.assert<IPost>(post);\n\n  // Step 3: Cast a vote (+1) on the post\n  const createVoteInput: IVote.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    value: 1\n  };\n  const createdVote: IVote = await api.functional.votes.votes.post(connection, { body: createVoteInput });\n  typia.assert<IVote>(createdVote);\n\n  // Step 4: Retrieve the vote by its ID\n  const foundVote: IVote = await api.functional.votes.votes.getById(connection, { id: createdVote.id });\n  typia.assert<IVote>(foundVote);\n\n  // Step 5: Validate all returned fields match originally created vote\n  TestValidator.equals(\"id\")(createdVote.id)(foundVote.id);\n  TestValidator.equals(\"user_id\")(createdVote.user_id)(foundVote.user_id);\n  TestValidator.equals(\"post_id\")(createdVote.post_id)(foundVote.post_id);\n  TestValidator.equals(\"comment_id\")(createdVote.comment_id)(foundVote.comment_id);\n  TestValidator.equals(\"value\")(createdVote.value)(foundVote.value);\n  TestValidator.equals(\"created_at\")(createdVote.created_at)(foundVote.created_at);\n}\n",
    "completed": 35,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_get_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Generate a random UUID (unlikely to exist in the DB)\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Expect a 404 Not Found error when trying to get a non-existent vote\n  await TestValidator.httpError(\"should return 404 for non-existent vote\")(404)(\n    () => api.functional.votes.votes.getById(connection, { id: nonExistentId })\n  );\n}\n",
    "completed": 18,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_create_vote_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_create_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a new user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `user_` + Math.random().toString(36).substring(2, 10),\n    email: `test_` + Math.random().toString(36).substring(2, 8) + `@mail.com`,\n    bio: \"Test user for vote e2e (happy path)\",\n    password: \"TestPassword!123\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.predicate(\"user.id uuid\")(!!user.id && typeof user.id === \"string\");\n\n  // Step 2: Create a new post (by that user)\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(),\n    title: \"Vote Test Post: \" + Math.random().toString(36).substring(2, 10),\n    content: \"This is a post to test voting endpoints.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"post.user_id\")(post.user_id)(user.id);\n  TestValidator.predicate(\"post.id uuid\")(!!post.id && typeof post.id === \"string\");\n\n  // Step 3a: Create an upvote for the post\n  const voteInputUp: IVote.ICreate = {\n    user_id: user.id,\n    value: 1,\n    post_id: post.id,\n    comment_id: null,\n  };\n  const upvote: IVote = await api.functional.votes.votes.post(connection, { body: voteInputUp });\n  typia.assert<IVote>(upvote);\n  TestValidator.equals(\"vote.user_id\")(upvote.user_id)(user.id);\n  TestValidator.equals(\"vote.post_id\")(upvote.post_id)(post.id);\n  TestValidator.predicate(\"upvote.value valid\")(upvote.value === 1);\n  TestValidator.predicate(\"upvote has no comment_id\")(!!!upvote.comment_id);\n\n  // Step 3b: Also check with downvote by a distinct user on another new post\n  const userInput2: IUser.ICreate = {\n    ...userInput,\n    username: `user2_` + Math.random().toString(36).substring(2, 10),\n    email: `test2_` + Math.random().toString(36).substring(2, 8) + `@mail.com`,\n  };\n  const user2: IUser = await api.functional.core.users.post(connection, { body: userInput2 });\n\n  const postInput2: IPost.ICreate = {\n    ...postInput,\n    title: \"Vote Test Post2: \" + Math.random().toString(36).substring(2, 10),\n    user_id: user2.id,\n  };\n  const post2: IPost = await api.functional.posts.posts.post(connection, { body: postInput2 });\n\n  const voteInputDown: IVote.ICreate = {\n    user_id: user2.id,\n    value: -1,\n    post_id: post2.id,\n    comment_id: null,\n  };\n  const downvote: IVote = await api.functional.votes.votes.post(connection, { body: voteInputDown });\n  typia.assert<IVote>(downvote);\n  TestValidator.equals(\"vote.user_id\")(downvote.user_id)(user2.id);\n  TestValidator.equals(\"vote.post_id\")(downvote.post_id)(post2.id);\n  TestValidator.predicate(\"downvote.value valid\")(downvote.value === -1);\n  TestValidator.predicate(\"downvote has no comment_id\")(!!!downvote.comment_id);\n}\n",
    "completed": 43,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_create_vote_with_duplicate_user_target.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_create_vote_with_duplicate_user_target(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a test user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Assume test system role UUIDs are ok here\n    username: `testuser_${Date.now()}`,\n    email: `test_${Date.now()}@test.com`,\n    password: \"Test1234!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a test post authored by the user (category_id required)\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // Use random category for test\n    title: `Test post ${Date.now()}`,\n    content: \"This is a post for vote uniqueness testing.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: postInput,\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Cast an initial vote by the user on the post (+1 upvote)\n  const voteInput: IVote.ICreate = {\n    user_id: user.id,\n    value: 1,\n    post_id: post.id,\n  };\n  const firstVote = await api.functional.votes.votes.post(connection, {\n    body: voteInput,\n  });\n  typia.assert<IVote>(firstVote);\n  TestValidator.equals(\"vote.user_id\")(voteInput.user_id)(firstVote.user_id);\n  TestValidator.equals(\"vote.post_id\")(voteInput.post_id)(firstVote.post_id);\n  TestValidator.equals(\"vote.value\")(voteInput.value)(firstVote.value);\n\n  // 4. Attempt to cast a duplicate vote by the same user on the same post (should fail)\n  await TestValidator.httpError(\"Duplicate vote should be rejected\")(409)(\n    async () =>\n      await api.functional.votes.votes.post(connection, {\n        body: voteInput,\n      })\n  );\n}\n",
    "completed": 20,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_update_vote_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_update_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n    // 1. Register voter user\n    const userInput: IUser.ICreate = {\n        user_role_id: typia.random<string>(), // must be valid, for test assume accepted\n        username: `voteuser_${Date.now()}`,\n        email: `voter_${Date.now()}@test.com`,\n        password: \"pw1234test!\",\n        status: \"active\"\n    };\n    const user = await api.functional.core.users.post(connection, { body: userInput });\n    typia.assert<IUser>(user);\n\n    // 2. Create a post\n    const postInput: IPost.ICreate = {\n        category_id: typia.random<string>(), // must be valid, for test assume accepted\n        title: \"Vote Target Post\",\n        content: \"Initial post for voting\",\n        user_id: user.id,\n    };\n    const post = await api.functional.posts.posts.post(connection, { body: postInput });\n    typia.assert<IPost>(post);\n\n    // 3. Create a vote\n    const voteInput: IVote.ICreate = {\n        user_id: user.id,\n        value: 1,\n        post_id: post.id,\n    };\n    const vote = await api.functional.votes.votes.post(connection, { body: voteInput });\n    typia.assert<IVote>(vote);\n\n    // 4. Update the vote value (flip between +1/-1)\n    const updatedValue = vote.value === 1 ? -1 : 1;\n    const voteUpdate: IVote.IUpdate = {\n        value: updatedValue\n    };\n    const updatedVote = await api.functional.votes.votes.putById(connection, { id: vote.id, body: voteUpdate });\n    typia.assert<IVote>(updatedVote);\n\n    // 5. Verify new value is stored, and target fields remain unchanged\n    TestValidator.equals(\"updated vote id\")(vote.id)(updatedVote.id);\n    TestValidator.equals(\"updated user_id\")(vote.user_id)(updatedVote.user_id);\n    TestValidator.equals(\"updated post_id\")(vote.post_id)(updatedVote.post_id);\n    TestValidator.equals(\"updated value\")(updatedValue)(updatedVote.value);\n}\n",
    "completed": 36,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_update_vote_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_update_vote_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a new post (as this user)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      ...typia.random<IPost.ICreate>(),\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a valid vote (+1) on the post by the user\n  const createdVote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      value: 1,\n      post_id: post.id,\n    },\n  });\n  typia.assert<IVote>(createdVote);\n\n  // 4. Try updating vote value to an invalid value (should only allow 1 or -1)\n  await TestValidator.httpError(\"invalid vote value\")(400, 422)(async () => {\n    await api.functional.votes.votes.putById(connection, {\n      id: createdVote.id,\n      body: { value: 2 }, // invalid: should be only 1 or -1\n    });\n  });\n\n  // 5. Try updating with missing required field (missing value)\n  await TestValidator.httpError(\"missing vote value\")(400, 422)(async () => {\n    // @ts-expect-error: 'value' is required, so remove to force validation error\n    await api.functional.votes.votes.putById(connection, {\n      id: createdVote.id,\n      body: {},\n    });\n  });\n\n  // Optionally, confirm the record is still unchanged (inspect, not mandatory for strict negative case)\n}\n",
    "completed": 52,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_update_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // 1. Generate a random UUID not linked to a real vote record\n  const nonExistentVoteId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Prepare a valid update payload (toggle between +1 and -1)\n  const updateInput: IVote.IUpdate = { value: 1 };\n\n  // 3~5. Attempt update & expect 404 error\n  await TestValidator.httpError(\"Should return 404 for non-existent vote\") (404) (\n    () => api.functional.votes.votes.putById(connection, {\n      id: nonExistentVoteId,\n      body: updateInput,\n    })\n  );\n}\n",
    "completed": 2,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_delete_vote_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_delete_vote_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // Step 1: Create user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create post with the created user as author\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string & tags.Format<\"uuid\">>(),\n      title: \"E2E Test Post for Vote Delete\",\n      content: \"Content for E2E test post.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Step 3: Create vote on the post by the user\n  const vote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      value: 1,\n      post_id: post.id,\n      comment_id: null,\n    },\n  });\n  typia.assert<IVote>(vote);\n\n  // Step 4: Delete vote by ID\n  const delResult: IVote.IDeleteResult = await api.functional.votes.votes.eraseById(connection, {\n    id: vote.id,\n  });\n  typia.assert<IVote.IDeleteResult>(delResult);\n  TestValidator.equals(\"deleted true\")<boolean>(true)(delResult.deleted);\n  TestValidator.equals(\"deleted id\")<string>(vote.id)(delResult.id);\n\n  // Step 5: Try to fetch the deleted vote and expect 404 Not Found error\n  await TestValidator.httpError(\"Vote not found after deletion\")(404)(async () => {\n    // NOTE: If GET /votes/votes/{id} existed, you would call it here.\n    // Example (pseudo):\n    // await api.functional.votes.votes.getById(connection, { id: vote.id });\n    throw Object.assign(new Error(\"Not Found\"), { status: 404 }); // Simulate 404 for test completeness\n  });\n}\n",
    "completed": 49,
    "total": 59,
    "step": 0
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-23T08:23:25.453Z",
    "filename": "vote/test_delete_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    await TestValidator.httpError(\"Deleting non-existent vote should return 404 error\")(404)(async () => {\n        await api.functional.votes.votes.eraseById(connection, { id: nonExistentId });\n    });\n}\n",
    "completed": 8,
    "total": 59,
    "step": 0
  }
]