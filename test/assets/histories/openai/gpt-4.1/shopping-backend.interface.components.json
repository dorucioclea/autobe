{
  "schemas": {
    "IPage.IRequest": {
      "type": "object",
      "properties": {
        "current": {
          "type": "integer",
          "description": "Current page number to request (1-based, required for all paged endpoints). Usually defaults to 1."
        },
        "limit": {
          "type": "integer",
          "description": "Desired number of records per page/result block. Strict max limit enforced by server (default 20/50/100, as per endpoint)."
        },
        "sorts": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "field": {
                "type": "string",
                "description": "Field name to sort results by. Must be valid column key (e.g., 'created_at', 'nickname'), as specified by the endpoint."
              },
              "direction": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "Ascending order for the specified field."
                  },
                  {
                    "const": "desc",
                    "description": "Descending order for the specified field."
                  }
                ],
                "description": "Direction for sorting: 'asc' for ascending, 'desc' for descending."
              }
            },
            "required": [
              "field",
              "direction"
            ]
          },
          "description": "Array of objects specifying complex/multi-field sort order for paged endpoints. E.g. [{ field: 'created_at', direction: 'desc' }]. Optional; use for advanced paging/sorting UIs."
        }
      },
      "required": [
        "current",
        "limit"
      ],
      "description": "Standard pagination request object for all OpenAPI endpoints returning paged results. Used to specify page number, page size, and optional complex sorting. All paged endpoints' PATCH request bodies may extend from or include this as a base struct."
    },
    "ai_ecommerce_customers.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "A free-text search string for filtering customers by nickname, email, or other indexed properties. Enables advanced searching/filtering of ai_ecommerce_customers list by query term.\n\nMatches records by partial or full email, display nickname, etc. as supported by system."
        },
        "status": {
          "type": "string",
          "description": "Status filter for customer account (e.g., 'active', 'deleted', or system-defined statuses). Used to filter by account lifecycle state.\n\nTypically supports 'active', 'deleted', 'locked', etc. Implemented at business logic/application level. Not a DB enum; value space enforced by backend."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start date for filtering customers by account creation time. Supports ISO 8601 format.\n\nReturns only customers created after this timestamp (inclusive)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for filtering customers by account creation time. Supports ISO 8601 format.\n\nReturns only customers created before this timestamp (inclusive)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Page number for paginated results. Defaults to 1 if omitted."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of results per page (pagination limit). Defaults to 20 if omitted. Use for server-side paging."
        },
        "sort_key": {
          "type": "string",
          "description": "Key/field to sort by. Examples: 'created_at', 'nickname', etc.\n\nRequired for sortable paginated browsing and consistent result ordering."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
            },
            {
              "const": "desc",
              "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
            }
          ],
          "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
        }
      },
      "description": "Request schema for paginated, filterable, and searchable retrieval of ai_ecommerce_customers. Used as PATCH request body for /ai_ecommerce/customers.\n\nEnables advanced query patterns on the customer entity list and supports pagination, search, and sorting.",
      "required": []
    },
    "IPageai_ecommerce_customers": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_customers"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_customers result list.\n\nStandardized response structure for paging, includes data array of customers and a pagination info block. Used as response for PATCH /ai_ecommerce/customers."
    },
    "ai_ecommerce_customers": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique customer identifier (UUID, primary key). Immutable. Referenced in all customer business flows and join relations. Mirrors id field in ai_ecommerce_customers table.\n\nUsed as foreign key in most customer-related records (cart, order, etc.)."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to 1:1 ai_ecommerce_user_profiles. Strictly required and unique per customer. Used for normalized profile linkage.\n\nNever directly modifiable after creation; enforced at database and service layer."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of account creation. ISO 8601, UTC. Used for audit, traceability and time-bounded queries."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime of last update. Used for audit, compliance, optimistic concurrency."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-deletion marker. If set (not null), the customer is logically deleted; else record is active.\n\nEnables GDPR/compliance workflows without physical deletion."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft-deletion marker. If set (not null), the customer is logically deleted; else record is active.\n\nEnables GDPR/compliance workflows without physical deletion."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Normalized customer entity representing a registered account in ai_ecommerce_customers table.\n\nReferences the unique profile, audit data, and soft-deletion marker as described in core system schema. Used for customer management, admin/support, and backend logic."
    },
    "ai_ecommerce_customers.IRegister": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key linking this customer to ai_ecommerce_user_profiles. Strictly one-to-one; required for account creation.\n\nThis value must reference an existing user profile row."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Payload schema for registration/creation of a new ai_ecommerce_customers entity (POST /ai_ecommerce/customers).\n\nRequires linking to a user profile; all other fields are system-generated or managed afterwards."
    },
    "ai_ecommerce_customers.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "Status to update the customer record with. Supported values depend on system business logic; may include 'active', 'deleted', etc."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Update to set soft-deletion timestamp. If set (not null), marks as deleted; for restoring, may be set to null. Mutation follows business rules for logical deletion/restoration."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update to set soft-deletion timestamp. If set (not null), marks as deleted; for restoring, may be set to null. Mutation follows business rules for logical deletion/restoration."
        }
      },
      "description": "Payload for patching/updating an ai_ecommerce_customers entity. Used for updating status or lifecycle dates, not profile_id.",
      "required": []
    },
    "ai_ecommerce_sellers.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Free-text search term to filter sellers, by business name, profile info, or other indexed fields."
        },
        "status": {
          "type": "string",
          "description": "Filter sellers by account status ('active', 'deleted', etc). Interpreted at business logic layer; not a DB enum."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start date for filtering sellers by account creation time (ISO 8601)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for filtering sellers by account creation time (ISO 8601)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Current page number for paginated results. Default 1."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum page size (defaults to 20)."
        },
        "sort_key": {
          "type": "string",
          "description": "Field name to sort by ('created_at', etc)."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sorting order: ascending ('asc') or descending ('desc')."
            },
            {
              "const": "desc",
              "description": "Sorting order: ascending ('asc') or descending ('desc')."
            }
          ],
          "description": "Sorting order: ascending ('asc') or descending ('desc')."
        }
      },
      "description": "Request schema for paged/searchable seller list retrieval (PATCH /ai_ecommerce/sellers). Supports free-text search, status filter, created timestamp range, pagination, and custom sorting.",
      "required": []
    },
    "IPageai_ecommerce_sellers": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_sellers"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response container for ai_ecommerce_sellers search/listing. Used to wrap list of sellers with page info on PATCH /ai_ecommerce/sellers."
    },
    "ai_ecommerce_sellers": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique seller identifier (UUID primary key). Used as seller identity on the platform."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique user profile linkage (FK to ai_ecommerce_user_profiles). Enforcement of 1:1 business/identity separation."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when account (seller) was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime of last update for seller record."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-delete field: null if active, timestamp if deleted for audit/compliance."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft-delete field: null if active, timestamp if deleted for audit/compliance."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Seller entity for ai_ecommerce_sellers, as defined in core schema.\n\nRepresents legal business user. Links 1:1 to a user profile."
    },
    "ai_ecommerce_sellers.IRegister": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key (UUID) to ai_ecommerce_user_profiles - identity for this seller. Enforces 1:1 business link."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Payload for creating a new seller record (POST /ai_ecommerce/sellers). Requires linking to a user profile row. Other fields handled by system."
    },
    "ai_ecommerce_sellers.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "Status to set for seller. Not a database enum; enforced by application layer. Examples include: 'active', 'deleted', etc."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Update for soft-deletion of seller; follow business compliance rules. Null for restore/reactivation; timestamp for deletion."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update for soft-deletion of seller; follow business compliance rules. Null for restore/reactivation; timestamp for deletion."
        }
      },
      "description": "Payload for updating/patching a seller entity. Used for status/lifecycle field updates only.",
      "required": []
    },
    "ai_ecommerce_administrators.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Free-text search string for admin listing (email/nickname/etc. from linked profile or indexed fields)."
        },
        "status": {
          "type": "string",
          "description": "Status filter (e.g., 'active', 'deleted'). Not a true enum; business logic enforced."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for admin accounts created after this datetime (ISO-8601)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for admin accounts created before this datetime (ISO-8601)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Pagination page number (min: 1, default: 1)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Pagination limit (max: 100, default: 20)."
        },
        "sort_key": {
          "type": "string",
          "description": "Field name to sort by (e.g., 'created_at')."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
            },
            {
              "const": "desc",
              "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
            }
          ],
          "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
        }
      },
      "description": "Request schema for paginated, searchable administrator account listing. Used on PATCH /ai_ecommerce/administrators.",
      "required": []
    },
    "IPageai_ecommerce_administrators": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_administrators"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paging wrapper for ai_ecommerce_administrators entities. Used in list results for PATCH /ai_ecommerce/administrators."
    },
    "ai_ecommerce_administrators": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique admin identity; referenced in admin/audit flows. Immutable for all administrator records in the system.\n\nRequired by business and security rules for administrative account operations and traceability."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles; unique per admin. Required for identification and normalization.\n\nThis ensures each administrator record references a specific user profile, and that profile_id is unique for admins."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Created for traceability. System-generated timestamp for audit logs of administrator account creation.\n\nEnables full lifecycle and compliance audit or rollback."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Last Updated Timestamp] - Compliance/audit edits. Reflects changes or edits by sysadmin or process automation.\n\nTracks last modification, supporting change tracking and data stewardship for regulatory requirements."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Administrator entity representing privileged platform/system admins, as defined in the ai_ecommerce_administrators table (Prisma schema and ERD). Each administrator is uniquely linked to a user profile, supports traceability, soft deletion, and full audit compliance.\n\nReferenced in system audit, onboarding, and role management flows. Fulfills business requirements regarding admin separability, account lifecycle, and access control.\n\nAll properties, relations, and deletion behaviors described here mirror those in the original database schema and business logic."
    },
    "IPage.IPagination": {
      "type": "object",
      "description": "Paging metadata structure returned with all IPage<T> responses. Contains key info about the current page for list results, including position, strict limit, total record count, and calculated total pages. Used by dashboards, UIs, and reporting interfaces to build paginated/batch UX components.",
      "properties": {
        "current": {
          "type": "integer",
          "description": "Current page number (uint32). Required for all paginated responses."
        },
        "limit": {
          "type": "integer",
          "description": "Page size (per-page record limit, default 100/strict system-dependent max) for paginated result."
        },
        "records": {
          "type": "integer",
          "description": "Total number of records matching query in the DB (used to drive total page calculation, UX.)"
        },
        "pages": {
          "type": "integer",
          "description": "Total number of pages as analytic pagination ceil(records/limit)."
        }
      },
      "required": [
        "current",
        "limit",
        "records",
        "pages"
      ]
    },
    "IAiEcommerceAdministrator.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles table. Must be an existing, unique user profile ID representing the admin.\n\nEnforces normalization and uniqueness of administrators in the system."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Request body schema for creating a new administrator record (ai_ecommerce_administrators table). Requires mandatory linkage to an existing user profile.\n\nProfile_id must refer to an available, unique user profile not already associated with an admin entity. All default fields, such as created_at and updated_at, are populated automatically by the system."
    },
    "IAiEcommerceAdministrator": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique admin identity; referenced in admin/audit flows. Immutable for all administrator records in the system.\n\nRequired by business and security rules for administrative account operations and traceability."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles; unique per admin. Required for identification and normalization.\n\nThis ensures each administrator record references a specific user profile, and that profile_id is unique for admins."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Created for traceability. System-generated timestamp for audit logs of administrator account creation.\n\nEnables full lifecycle and compliance audit or rollback."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Last Updated Timestamp] - Compliance/audit edits. Reflects changes or edits by sysadmin or process automation.\n\nTracks last modification, supporting change tracking and data stewardship for regulatory requirements."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Administrator entity representing privileged platform/system admins, as defined in the ai_ecommerce_administrators table (Prisma schema and ERD). Each administrator is uniquely linked to a user profile, supports traceability, soft deletion, and full audit compliance.\n\nReferenced in system audit, onboarding, and role management flows. Fulfills business requirements regarding admin separability, account lifecycle, and access control.\n\nAll properties, relations, and deletion behaviors described here mirror those in the original database schema and business logic."
    },
    "IAiEcommerceAdministrator.IUpdate": {
      "type": "object",
      "properties": {
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for the moment the admin record is updated. Should be set to the current time when making the update.\n\nMandatory for all admin record change tracking."
        }
      },
      "required": [
        "updated_at"
      ],
      "description": "Request body for updating an administrator record in the ai_ecommerce_administrators table. Update able fields are restricted to timestamp (updated_at), as all other identifiers (profile_id, id) are immutable after creation.\n\nMust always set updated_at to current time for proper audit trail, in line with database and regulatory expectations."
    },
    "IAiEcommerceUserProfile.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Full-text search query for nickname or email. Enables flexible querying for admin dashboards, CMS interfaces, or customer management. Optional; if omitted, no filtering occurs."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "description": "Page number for pagination (1-based). Used for batched result retrieval in UI or batch download. Optional; default is 1."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "description": "Records per page. Used to throttle or paginate results. Optional; default is 100."
        },
        "sortBy": {
          "type": "string",
          "description": "Field to sort results by (e.g. 'created_at', 'nickname'). Optional; omitted for natural order."
        },
        "sortDir": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
            },
            {
              "const": "desc",
              "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
            }
          ],
          "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
        }
      },
      "description": "Request parameters for searching/paginating user profiles (ai_ecommerce_user_profiles). Each field matches a probable query parameter, supporting typical admin UI or self-service search requirements. See Prisma schema for full field index and business rules.",
      "required": []
    },
    "IPageIAiEcommerceUserProfile": {
      "type": "object",
      "properties": {
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number being returned."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Maximum number of records returned per page (default 100)."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of records in the database for this query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total page count for this query."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination definition for paged result containers. All paginated endpoints return this object alongside actual data."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceUserProfile"
          },
          "description": "List of user profiles for the current page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard paginated result for ai_ecommerce_user_profiles entity search/list operation. All paginated collection endpoints follow this container, including the mandatory data array and pagination metadata."
    },
    "IAiEcommerceUserProfile": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - One-to-one with every user/seller/admin identity. Global unique identifier for user profiles."
        },
        "nickname": {
          "type": "string",
          "description": "[Display Nickname] - Used as user-facing name; not globally unique. Allows for system-search and UI display."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "[Profile Image URI] - Optional. Stores avatar/profile photo as URI string. May be null if not set."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Profile Image URI] - Optional. Stores avatar/profile photo as URI string. May be null if not set."
        },
        "email": {
          "type": "string",
          "description": "[Email Address] - Main point of communication & login. Must be unique system-wide; enforced at DB and business logic."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "[Phone Number] - Optional for secondary comms/MFA. May be null if not supplied."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Phone Number] - Optional for secondary comms/MFA. May be null if not supplied."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "[Communication Consent] - True if user has opted in for platform communication. Regulatory/business compliance setting."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Timestamp of profile creation. Used for audit, lifecycle, and compliance."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Updated Timestamp] - Timestamp of last change to profile. Essential for profile updates, rollback, and change tracking."
        }
      },
      "required": [
        "id",
        "nickname",
        "email",
        "communication_consent",
        "created_at",
        "updated_at"
      ],
      "description": "ai_ecommerce_user_profiles entity representing fundamental user/account profile for customers, sellers, and admins. Contains all basic display/communication fields, normalization logic, and audit fields.\n\nBusiness rule: At most one profile per email; all RBAC and account linkage is by this entity. Conforms to DB schema and UX design for consistent access, creation, and updating."
    },
    "IAiEcommerceUserProfile.ICreate": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "[Display Nickname] - Required name string for display in community/UI/comm preferences. Non-unique."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "[Profile Image URI] - Optional; avatar file URI, may be set to null to omit."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Profile Image URI] - Optional; avatar file URI, may be set to null to omit."
        },
        "email": {
          "type": "string",
          "description": "[Email Address] - Required field for system comms and login. Must be unique at time of creation."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "[Phone Number] - Optional field for comms/MFA. Omit or set null if unused."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Phone Number] - Optional field for comms/MFA. Omit or set null if unused."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "[Communication Consent] - Explicit consent to contact. True/false only."
        }
      },
      "required": [
        "nickname",
        "email",
        "communication_consent"
      ],
      "description": "Request body for creating new ai_ecommerce_user_profiles entity. All fields must be supplied per business/rule constraints except optional avatar/phone number. Omitted/invalid email or nickname triggers record rejection."
    },
    "IAiEcommerceUserProfile.IUpdate": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "Updated nickname for the user profile, if changed. May be omitted if not changing. Requires non-empty string if set."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "Profile image URI to update. Optional. Can set to null to remove avatar."
            },
            {
              "type": "null"
            }
          ],
          "description": "Profile image URI to update. Optional. Can set to null to remove avatar."
        },
        "email": {
          "type": "string",
          "description": "Updated email address; must remain unique if changed. Validation applies. Optional."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "Updated phone number for comms/MFA. Optional. Can set null to clear."
            },
            {
              "type": "null"
            }
          ],
          "description": "Updated phone number for comms/MFA. Optional. Can set null to clear."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "Updated communication consent flag. Optional; set to true/false."
        }
      },
      "description": "Payload for updating ai_ecommerce_user_profiles. Supports partial or full update. All fields optional, but at least one should be supplied for effective update. Omitting a property leaves it unchanged.\n\nBusiness and schema rules enforce constraints (e.g., unique email, non-null constraints, 80000 char max for avatar).",
      "required": []
    },
    "IAiEcommerceUserAddress.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter by user profile (foreign key). Only addresses belonging to this user profile will be returned. Optional."
        },
        "address_type": {
          "type": "string",
          "description": "Filter by address type (e.g., 'default', 'delivery', 'billing'). Optional."
        },
        "search": {
          "type": "string",
          "description": "Full-text search across name, address, custom_label, etc. Optional."
        },
        "region_code": {
          "type": "string",
          "description": "Filter addresses by region code (ISO/Country). Optional."
        },
        "is_default": {
          "type": "boolean",
          "description": "Filter only default addresses (true/false). Optional."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "description": "Pagination: page number (1-based). Optional."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "description": "Pagination: number of records per page. Optional."
        }
      },
      "description": "Request payload for searching, filtering, and paginating user address book entries (ai_ecommerce_user_addresses/\nai_ecommerce_user_address). All parameters are optional for flexible queries.",
      "required": []
    },
    "IPageIAiEcommerceUserAddress": {
      "type": "object",
      "properties": {
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number being returned."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Maximum number of records returned per page (default 100)."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of records in the database for this query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total page count for this query."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination definition for paged result containers. All paginated endpoints return this object alongside actual data."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceUserAddress"
          },
          "description": "List of user addresses for the current page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated data structure for user address list results. Includes result set of addresses and pagination metadata for UI display/consumption."
    },
    "IAiEcommerceUserAddress": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique address ID for referencing/fulfillment and audit."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[Profile FK] - Indicates which user/owner the address belongs to. Foreign key to user_profiles."
        },
        "address_type": {
          "type": "string",
          "description": "Address classification; business logic expects values like 'default', 'billing', or 'delivery'."
        },
        "name": {
          "type": "string",
          "description": "Recipient name for this address; used for delivery or billing records."
        },
        "phone_number": {
          "type": "string",
          "description": "Recipient contact phone number; used for fulfillment and customer contact."
        },
        "postal_code": {
          "type": "string",
          "description": "Address postal/ZIP code for shipping validation. FMS/international addresses supported."
        },
        "address_line1": {
          "type": "string",
          "description": "First address line (required); typically street, building number, etc."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Additional bottom/auxiliary address info (optional); apt/unit/floor."
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional bottom/auxiliary address info (optional); apt/unit/floor."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "User-supplied friendly label, e.g. 'Home', 'Work', 'For gifts'. Optional; may be null."
            },
            {
              "type": "null"
            }
          ],
          "description": "User-supplied friendly label, e.g. 'Home', 'Work', 'For gifts'. Optional; may be null."
        },
        "region_code": {
          "type": "string",
          "description": "Region or country code; ISO/locale identifier. Required for shipping compliance."
        },
        "is_default": {
          "type": "boolean",
          "description": "True if this address is the user's active default. Used by services/UI to pre-select address for checkout."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Record creation timestamp. System-generated for compliance/audit auditing."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last modification timestamp. Used for audit and version history."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft delete timestamp; null if active. Set for logically removed/compliant retrievals."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft delete timestamp; null if active. Set for logically removed/compliant retrievals."
        }
      },
      "required": [
        "id",
        "profile_id",
        "address_type",
        "name",
        "phone_number",
        "postal_code",
        "address_line1",
        "region_code",
        "is_default",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic user address record as defined in ai_ecommerce_user_addresses/ai_ecommerce_user_address. Used for fulfillment, billing, address book UIs, and compliance queries. All major fields are separated per DB normalization; read/write business rules enforced as per schema descriptions."
    },
    "IAiEcommerceUserAddress.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key referring to the user's profile. This field links the address to a user via ai_ecommerce_user_profiles.id. Required for associating the address with its owner profile in a normalized fashion. See Prisma schema for ai_ecommerce_user_addresses.profile_id."
        },
        "address_type": {
          "type": "string",
          "description": "Classifies the address as 'default', 'delivery', or 'billing'. Serves logical separation of addresses in user profile context. Enforced by application logic and referenced at checkout, profile book, and for business flows. See Prisma: ai_ecommerce_user_addresses.address_type."
        },
        "name": {
          "type": "string",
          "description": "Name of the person who will receive at this address. Required for labeling deliveries, billing, etc. Directly maps to ai_ecommerce_user_addresses.name."
        },
        "phone_number": {
          "type": "string",
          "description": "Contact phone for delivery, notifications, or order/fulfillment. Atomic per 3NF. Column: ai_ecommerce_user_addresses.phone_number."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal ZIP code for address validation/shipping. Handles domestic/international. See Prisma: ai_ecommerce_user_addresses.postal_code."
        },
        "address_line1": {
          "type": "string",
          "description": "Main address field: street/road/building, atomic per normalization. See ai_ecommerce_user_addresses.address_line1."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
            },
            {
              "type": "null",
              "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
            }
          ],
          "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
            },
            {
              "type": "null",
              "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
            }
          ],
          "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
        },
        "region_code": {
          "type": "string",
          "description": "Code denoting region/country for shipping and legal region enforcement. ISO/local codes supported. Prisma: ai_ecommerce_user_addresses.region_code."
        },
        "is_default": {
          "type": "boolean",
          "description": "Whether this address is considered the default for the profile. Enforced at the service level; not multiple default per user. See ai_ecommerce_user_addresses.is_default."
        }
      },
      "required": [
        "profile_id",
        "address_type",
        "name",
        "phone_number",
        "postal_code",
        "address_line1",
        "region_code",
        "is_default"
      ],
      "description": "Request body for creating a user address, as per ai_ecommerce_user_addresses in Prisma schema. Contains all required fields, links to profile, and optionally labels/customizes the address for user UX. Required for user address onboarding, checkout, and delivery flows. All business and normalization rules referenced from the schema documentation."
    },
    "IAiEcommerceUserAddress.IUpdate": {
      "type": "object",
      "properties": {
        "address_type": {
          "type": "string",
          "description": "See IAiEcommerceUserAddress.ICreate; updates the type for this address (default/delivery/billing)."
        },
        "name": {
          "type": "string",
          "description": "Recipient name for this address."
        },
        "phone_number": {
          "type": "string",
          "description": "Contact phone for delivery/fulfillment."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal ZIP code for delivery address."
        },
        "address_line1": {
          "type": "string",
          "description": "Main address line."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional detail (apartment/unit/floor)."
            },
            {
              "type": "null",
              "description": "Optional detail (apartment/unit/floor)."
            }
          ],
          "description": "Optional detail (apartment/unit/floor)."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional label for easier user recognition."
            },
            {
              "type": "null",
              "description": "Optional label for easier user recognition."
            }
          ],
          "description": "Optional label for easier user recognition."
        },
        "region_code": {
          "type": "string",
          "description": "Region or country code."
        },
        "is_default": {
          "type": "boolean",
          "description": "Mark or remove this address as default."
        }
      },
      "required": [],
      "description": "Update body for ai_ecommerce_user_addresses. All fields optional; only properties present will be updated. Used for address edits, relabeling, or updating delivery data in customer or admin flows. See schema for validation, normalization, and compliance requirements."
    },
    "ai_ecommerce_user_oauth.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to user profile (ai_ecommerce_user_profiles.id)."
        },
        "provider": {
          "type": "string",
          "description": "OAuth provider. E.g., 'google', 'apple', etc."
        },
        "provider_user_id": {
          "type": "string",
          "description": "Unique identifier provided by OAuth provider for federation."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest date for filtering linked OAuth accounts."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest date for filtering linked OAuth accounts."
            }
          ],
          "description": "Earliest date for filtering linked OAuth accounts."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest date for filtering linked OAuth accounts."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest date for filtering linked OAuth accounts."
            }
          ],
          "description": "Latest date for filtering linked OAuth accounts."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: page number, starts from 1."
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: maximum records per page."
        }
      },
      "required": [],
      "description": "Search, filter and pagination structure for listing OAuth account bindings. Applies query filters as defined for ai_ecommerce_user_oauth PATCH endpoint. Each parameter references the normalized properties from the Prisma schema. For listing OAuth linkages by user or admin, see schema documentation for property semantics."
    },
    "IPageai_ecommerce_user_oauth": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_user_oauth"
          },
          "description": "Array of OAuth user account records."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response for ai_ecommerce_user_oauth list API. Contains pagination metadata and an array of ai_ecommerce_user_oauth records. See IPage<T> standard in API."
    },
    "ai_ecommerce_user_oauth": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the ai_ecommerce_user_oauth table. Unique OAuth binding row identifier. See schema documentation."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key linking this OAuth record to the user profile. See ai_ecommerce_user_profiles.id."
        },
        "provider": {
          "type": "string",
          "description": "OAuth provider (e.g., 'google','apple','kakao')."
        },
        "provider_user_id": {
          "type": "string",
          "description": "User ID as provided by the OAuth provider. Must be globally unique within the provider namespace."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for account linkage; audit field. See ai_ecommerce_user_oauth.created_at."
        }
      },
      "required": [
        "id",
        "profile_id",
        "provider",
        "provider_user_id",
        "created_at"
      ],
      "description": "Represents a single OAuth provider linkage for a user profile, per ai_ecommerce_user_oauth table in Prisma schema. Used for federated login, SSO, or external authentication. All fields map directly to Prisma columns and 3NF requirements. Comprehensively documents the normalized OAuth linkage."
    },
    "ai_ecommerce_user_oauth.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "User profile foreign key; owner of the OAuth linkage."
        },
        "provider": {
          "type": "string",
          "description": "Provider key: 'google', 'apple', 'kakao', etc."
        },
        "provider_user_id": {
          "type": "string",
          "description": "OAuth provider-side unique user id reference."
        }
      },
      "required": [
        "profile_id",
        "provider",
        "provider_user_id"
      ],
      "description": "Request payload for creating a new OAuth provider binding for a user. Requires the profile (FK), provider key, and external provider_user_id. Input parallels the columns in ai_ecommerce_user_oauth table per schema."
    },
    "ai_ecommerce_user_oauth.IUpdate": {
      "type": "object",
      "properties": {
        "provider": {
          "type": "string",
          "description": "Update the OAuth provider, if allowed."
        },
        "provider_user_id": {
          "type": "string",
          "description": "Update the provider user id."
        }
      },
      "required": [],
      "description": "Update structure for ai_ecommerce_user_oauth. Supports patching provider/provider_user_id."
    },
    "ai_ecommerce_user_audit_logs.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by user profile owning the audit log."
        },
        "event_type": {
          "type": "string",
          "description": "Type of audit event ('registration','login','profile_update', etc.)."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest log creation date for filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest log creation date for filter."
            }
          ],
          "description": "Earliest log creation date for filter."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest log creation date for filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest log creation date for filter."
            }
          ],
          "description": "Latest log creation date for filter."
        },
        "page": {
          "type": "integer",
          "description": "Page number, for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Page size (number of records per page)."
        }
      },
      "required": [],
      "description": "Search/pagination/filtering parameters for PATCH listing of ai_ecommerce_user_audit_logs. Parameter definitions match Prisma schema properties for user audit logging/filtering/analytics."
    },
    "IPageai_ecommerce_user_audit_logs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_user_audit_logs"
          },
          "description": "Array of audit log records matching the search."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result for ai_ecommerce_user_audit_logs list/search. Array contains audit log records, pagination describes current/total state."
    },
    "ai_ecommerce_user_audit_logs": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for each audit event. Immutable/unique. Prisma ai_ecommerce_user_audit_logs.id."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to actor user profile who performed action. 1:N relationship. Prisma: profile_id."
        },
        "event_type": {
          "type": "string",
          "description": "Enumeration of audit event type: 'registration','login','profile_update', etc."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
            },
            {
              "type": "null",
              "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
            }
          ],
          "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Audit event creation timestamp. Prisma: created_at."
        }
      },
      "required": [
        "id",
        "profile_id",
        "event_type",
        "created_at"
      ],
      "description": "Single user audit log event as recorded by ai_ecommerce_user_audit_logs table. Represents key user events (registration, login, changes). All properties derived from schema, not duplicated elsewhere."
    },
    "ai_ecommerce_user_audit_logs.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Actor's user profile FK. Belongs to ai_ecommerce_user_profiles.id."
        },
        "event_type": {
          "type": "string",
          "description": "Audit event code/type. See Prisma column."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional additional event details/metadata (JSON/text, etc)."
            },
            {
              "type": "null",
              "description": "Optional additional event details/metadata (JSON/text, etc)."
            }
          ],
          "description": "Optional additional event details/metadata (JSON/text, etc)."
        }
      },
      "required": [
        "profile_id",
        "event_type"
      ],
      "description": "Request payload for creating an audit log entry (user action). Properties mirror ai_ecommerce_user_audit_logs for normalized event logging. Event payload may be omitted/null as per schema definition."
    },
    "ai_ecommerce_user_audit_logs.IUpdate": {
      "type": "object",
      "properties": {
        "event_type": {
          "type": "string",
          "description": "Updated event type code, if correcting event log."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "Edit/append/correct event context for audit trail."
            },
            {
              "type": "null",
              "description": "Edit/append/correct event context for audit trail."
            }
          ],
          "description": "Edit/append/correct event context for audit trail."
        }
      },
      "required": [],
      "description": "Update structure for amending user audit log records. Supports correcting event type or payload. Intended for administration or legal correction only, as logs are otherwise append-only."
    },
    "ai_ecommerce_seller_business_profiles.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier of the seller whose business profiles are being requested. This must be a UUID as per the ai_ecommerce_seller_business_profiles schema. This filter allows administrative queries over all associated business profiles of a seller.\n\nReference: FK in Prisma ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "Business name (company name) filter for advanced search. Allows partial/full search for company registration/onboarding scenarios. This value should match normalized business profile schemas, supporting UI querying of sellers by business name.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Filter by unique business registration number. Used in seller onboarding compliance and duplicate prevention. This value determines if a business is already registered, aiding in anti-fraud and regulatory lookup.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "is_deleted": {
          "type": "boolean",
          "description": "When true, only soft-deleted (deleted_at set) business profiles are returned. Used for compliance reviews. Linked to deleted_at property in schema.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound ISO8601 timestamp for filtering business profiles created after this point. Useful for onboarding review, time-based batch queries, and reporting.\n\nReference: created_at in ai_ecommerce_seller_business_profiles."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound ISO8601 timestamp for last updated time. Used for querying business profiles based on recency of change.\n\nReference: updated_at in ai_ecommerce_seller_business_profiles."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which result page to retrieve (1-based).",
          "minimum": 1
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: number of results per page. System defaults should apply if not supplied.",
          "minimum": 1
        }
      },
      "required": [],
      "description": "Request DTO for searching/filtering/paging seller business profiles. Every property aligns with a column or business logic in ai_ecommerce_seller_business_profiles Prisma schema. All fields are optional and can be used in any combination for flexible query construction.\n\nCan be used in admin onboarding dashboard, compliance review pipelines, and seller search interfaces.\n\nSupports multi-field search, pagination, and compliance-filtered querying."
    },
    "IPageai_ecommerce_seller_business_profiles": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerBusinessProfile"
          },
          "description": "Paginated array of seller business profile summary/detail records. Each item is compliant with IAiEcommerceSellerBusinessProfile."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_seller_business_profiles query results. Conforms to IPage<T> as used throughout the platform. Contains page metadata and result data array."
    },
    "IAiEcommerceSellerBusinessProfile": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID uniquely identifying the seller business profile. Required for linking, updating, deleting, or compliance tracking.\n\nReference: id in ai_ecommerce_seller_business_profiles."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking this business profile to its owner seller. Strong FK enforce 1:1 mapping. Immutable after creation.\n\nReference: seller_id in ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "The legally registered company name for this business profile. Onboarding/compliance purposes. Must be unique per seller.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Employer/business registration number used for legal and regulatory trace. Must be unique in table.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "The business point-of-contact's name. Used for escalation/logistics. Must match onboarding/contact documentation.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Contact telephone number for the business. Requires normalization/validation. Used for onboarding/audit communication.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Contact email for all business communication, onboarding, support, or compliance notifications. Not user/seller's private email: must be a business domain address.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "Business headquarters/physical location, first address line. Used for onboarding/shipping/compliance correspondence.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Business city/municipality. Required for logistics, regulatory analysis.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "State or province or region for business registration. Critical for internationalization, regulatory sorting.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal or ZIP code of the business address. Used for plugin delivery/logistics, address validation.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Country in ISO country name/code (e.g., 'KR', 'KOR', 'South Korea'). Required for compliance.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp for when the business profile was created. System-generated.\n\nReference: created_at in ai_ecommerce_seller_business_profiles."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp for last update of the business profile. Used for system audit/compliance.\n\nReference: updated_at in ai_ecommerce_seller_business_profiles."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_name",
        "business_registration_number",
        "contact_name",
        "contact_phone",
        "contact_email",
        "address_line1",
        "city",
        "state",
        "postal_code",
        "country",
        "created_at",
        "updated_at"
      ],
      "description": "Complete business profile for an ai_ecommerce_seller. All non-nullable fields required by onboarding/compliance, all nullable fields treated per business logic. Properties rigorously match columns in ai_ecommerce_seller_business_profiles schema."
    },
    "IAiEcommerceSellerBusinessProfile.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Seller UUID for whom the business profile is created. Must reference an existing seller record. Required.\n\nReference: seller_id in ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "Officially registered company name. Required for business onboarding. Must be unique for this seller.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Unique business registration/certification number issued by the government. Required. Must remain unique for business profile CRUD.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "Point of contact for the businesstypically a staff or owner name. Mandatory for onboarding/contact.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Phone number for business contact. Must be validated and normalized. Required for approval processes.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Business-specific contact email for onboarding communications. Not user private email; must pass business validation. Required.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "First/main address line for business office or headquarters. Required at registration. Used for location verification.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Business city/region. Required for registration/audit.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "State/province/region for legal certification, used in address normalization and regulatory filings. Required.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal or ZIP code for address validation, delivery, and onboarding. Required.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Country for compliance/registration. Use ISO code or country full name for onboarding. Required.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [
        "seller_id",
        "business_name",
        "business_registration_number",
        "contact_name",
        "contact_phone",
        "contact_email",
        "address_line1",
        "city",
        "state",
        "postal_code",
        "country"
      ],
      "description": "Creation DTO for onboarding a seller's business profile. All non-nullable onboarding/compliance fields are required per ai_ecommerce_seller_business_profiles schema documentation. The structure must exactly match the onboarding form presented to the seller or admin."
    },
    "IAiEcommerceSellerBusinessProfile.IUpdate": {
      "type": "object",
      "properties": {
        "business_name": {
          "type": "string",
          "description": "Business/company name update for onboarding edits or compliance correction. Must not conflict with any other in-seller business name.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Business registration number update, used in compliance rectification. Must remain unique. Edits strictly limited by policy.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "Updated contact name for profile correction. Only allowed under regulated onboarding flows.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Updated business contact number for profile correction. May trigger revalidation. Must pass normalization checks.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Updated business email for regulatory correspondence or compliance fix. Must pass email validation.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "Updated primary address line for business. Used for compliance/physical audit.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Updated city field for compliance rectification.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "Updated state/province value for regulatory correspondence correction.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Updated postal code for onboarding compliance rectification.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Updated country value (ISO or name) for regulatory change/correction.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [],
      "description": "DTO for updating seller business profile fields for compliance, onboarding rectification, or business data correction. All fields are optional and only those specified are changed. Only non-immutable profile fields are allowed to be modified based on ai_ecommerce_seller_business_profiles policy."
    },
    "IAiEcommerceSellerBusinessProfile.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted (soft) business profile for traceability. Always returned as confirmation.\n\nReference: id in ai_ecommerce_seller_business_profiles."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) when the business profile was soft-deleted. Set by the compliance system. Returned for audit confirmation."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Response DTO after a seller business profile is deleted (soft delete). Used for audit and compliance trace, notifies external handlers of actual row logical removal. Matched against deleted_at in ai_ecommerce_seller_business_profiles."
    },
    "Pageable.IAiEcommerceSellerOnboardingLogs.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the seller whose onboarding logs are being requested. FK in ai_ecommerce_seller_onboarding_logs. Used for compliance and audit queries targeting a specific seller."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the business profile associated with these onboarding logs. Used in onboarding compliance filtering and cross-referencing logs during seller onboarding review."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the administrator who performed the onboarding action, if set. Used to audit onboarding decisions and review admin activity."
        },
        "step": {
          "type": "string",
          "description": "Filter by workflow step (e.g., 'application_submitted', 'documents_received', 'manual_review', etc). Enables log searches by onboarding state."
        },
        "action": {
          "type": "string",
          "description": "Filter by nature of onboarding action (e.g., 'accepted', 'rejected', 'flagged', 'info_requested'). Used in compliance and workflow analysis."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type for onboarding log entries (e.g., 'system', 'administrator'). Useful for role-based filtering in onboarding pipelines."
        },
        "decision_state": {
          "type": "string",
          "description": "Status after onboarding action (e.g., 'pending', 'approved', 'rejected', 'escalated'). Used for retrieval of logs matching specific onboarding review outcomes."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound filter by created_at timestamp for log search. Used in compliance, timeline reviews, and onboarding analytics."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which page to retrieve.",
          "minimum": 1
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: number of results per page.",
          "minimum": 1
        }
      },
      "required": [],
      "description": "Request DTO for paginated, filtered, and compliant queries of ai_ecommerce_seller_onboarding_logs. All fields are optional and correspond to columns in the onboarding log schema, supporting multi-condition audits, onboarding dashboard filters, and advanced admin review tools."
    },
    "Pageable.IAiEcommerceSellerOnboardingLogs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerOnboardingLog"
          },
          "description": "Paginated array of seller onboarding log detail records; each entry is an atomic event from ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container DTO for lists of ai_ecommerce_seller_onboarding_logs entries, containing audit-compliant timeline event records plus pagination information. Used for onboarding dashboard UIs, compliance event traceability, and operational reporting."
    },
    "IAiEcommerceSellerOnboardingLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID for the seller onboarding log entry. Uniquely identifies onboarding workflow event for traceability and audit.\n\nReference: id in ai_ecommerce_seller_onboarding_logs."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking the log event to the seller. FK to ai_ecommerce_sellers. Required for all onboarding action records.\n\nReference: seller_id in ai_ecommerce_seller_onboarding_logs."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking this onboarding log to the seller's business profile. FK for compliance trace.\n\nReference: business_profile_id in ai_ecommerce_seller_onboarding_logs."
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
        },
        "step": {
          "type": "string",
          "description": "Workflow step for onboarding (e.g., 'application_submitted', 'manual_review'). Must match onboarding policy enumeration.\n\nReference: step in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Nature of the onboarding action (e.g., 'accepted', 'rejected', 'flagged', 'info_requested'). Must match onboarding process logic.\n\nReference: action in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type for log entry ('system' or 'administrator'). Used for analytics/workflow audit.\n\nReference: actor_type in ai_ecommerce_seller_onboarding_logs."
        },
        "decision_state": {
          "type": "string",
          "description": "Status after onboarding action (e.g., 'pending', 'approved', 'rejected', 'escalated'). Enumerated in workflow policies.\n\nReference: decision_state in ai_ecommerce_seller_onboarding_logs."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) of the onboarding workflow/log event creation.\n\nReference: created_at in ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_profile_id",
        "step",
        "action",
        "actor_type",
        "decision_state",
        "created_at"
      ],
      "description": "Detailed record of a single onboarding workflow event for a seller as defined in ai_ecommerce_seller_onboarding_logs, containing atomic workflow/audit information as required for onboarding, regulatory review, and compliance trace."
    },
    "IAiEcommerceSellerOnboardingLog.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Seller UUID for which this onboarding log event is recorded. Must reference an existing seller. Required for linkage.\n\nReference: seller_id in ai_ecommerce_seller_onboarding_logs."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Business profile UUID linked to this onboarding event. Ensures compliance trace to business onboarding docs. Required FK.\n\nReference: business_profile_id in ai_ecommerce_seller_onboarding_logs."
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
        },
        "step": {
          "type": "string",
          "description": "Onboarding workflow step (e.g., 'documents_received','manual_review'). Enumeration as per process policy. Required.\n\nReference: step in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Onboarding action ('accepted','rejected','flagged','info_requested'). Required.\n\nReference: action in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type specifying if this log is due to 'system' or 'administrator' action. Required.\n\nReference: actor_type in ai_ecommerce_seller_onboarding_logs."
        },
        "decision_state": {
          "type": "string",
          "description": "Resulting onboarding status after this action (e.g., 'approved','rejected','pending'). Required.\n\nReference: decision_state in ai_ecommerce_seller_onboarding_logs."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "seller_id",
        "business_profile_id",
        "step",
        "action",
        "actor_type",
        "decision_state"
      ],
      "description": "DTO for creation of a seller onboarding log event. Required fields align with ai_ecommerce_seller_onboarding_logs schema for traceability, workflow compliance, and audit. Only supplied fields are permitted; extra data is ignored by logic."
    },
    "IAiEcommerceSellerOnboardingLog.IUpdate": {
      "type": "object",
      "properties": {
        "step": {
          "type": "string",
          "description": "New onboarding workflow step (see process enumeration). Must match allowed values in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Updated onboarding action. Must follow business logic and compliance rules in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Updated actor type, if changed by administrative process."
        },
        "decision_state": {
          "type": "string",
          "description": "Updated status after onboarding action (e.g., 'rejected','approved','escalated','pending'). Must match onboarding policy."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional new or updated rationale text. Null if not relevant."
            },
            {
              "type": "null",
              "description": "Optional new or updated rationale text. Null if not relevant."
            }
          ],
          "description": "Optional new or updated rationale text. Null if not relevant."
        }
      },
      "required": [],
      "description": "DTO for updating permissible non-immutable fields in an onboarding log workflow entry (ai_ecommerce_seller_onboarding_logs). All properties are optionalonly updated fields need be supplied."
    },
    "IAiEcommerceSellerOnboardingLog.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of deleted (soft) onboarding log row for traceability. Confirmation field."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) when onboarding log was deleted by system, returned for audit trail."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Response DTO for confirming soft deletion of onboarding log events, providing traceable compliance information to audit systems."
    },
    "Pageable.IAiEcommerceSellerVerificationDocuments.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "The page number for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "The number of results per page."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for seller's UUID."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for business profile UUID."
        },
        "document_type": {
          "type": "string",
          "description": "Filter for document type."
        },
        "verified_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Begin date for verified_at filtering."
        },
        "verified_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for verified_at filtering."
        }
      },
      "description": "Search and pagination request for seller verification documents.\n\nThis structure is used to request a page of seller verification document records, filtered by seller, business profile, document type, or verification status, and supports advanced queries on time ranges. Used by administrators and compliance officers for review and analytics.",
      "required": []
    },
    "Pageable.IAiEcommerceSellerVerificationDocuments": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total number of matching records."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerVerificationDocument"
          },
          "description": "Paged array of seller verification documents."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paginated result for seller verification documents.\n\nReturned from endpoints delivering pages of verification document entries for sellers, filtered and sorted as needed."
    },
    "IAiEcommerceSellerVerificationDocument": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique document ID."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the seller who submitted the document."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Business profile linked to this document."
        },
        "document_type": {
          "type": "string",
          "description": "Document type (e.g. business_registration, tax_certificate, etc.)."
        },
        "document_file_url": {
          "type": "string",
          "description": "Full URI to the stored document file."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Date the document was issued."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Optional expiry date for the document."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Optional expiry date for the document."
            }
          ],
          "description": "Optional expiry date for the document."
        },
        "verified_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when document was verified by admin."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when document was verified by admin."
            }
          ],
          "description": "Timestamp when document was verified by admin."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If set, document is logically deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If set, document is logically deleted."
            }
          ],
          "description": "If set, document is logically deleted."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_profile_id",
        "document_type",
        "document_file_url",
        "issue_date"
      ],
      "description": "Represents an official seller verification or compliance document uploaded during onboarding or for compliance purposes.\n\nIncludes details such as document type, issuer, dates, file location, and verification status. Used in onboarding and compliance review workflows."
    },
    "IAiEcommerceSellerVerificationDocument.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the seller submitting the document."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Linked business profile id."
        },
        "document_type": {
          "type": "string",
          "description": "Type of document being submitted (e.g., business_registration, tax_certificate)."
        },
        "document_file_url": {
          "type": "string",
          "description": "URI where the document file is stored."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Document issue date."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Optional document expiry date; null if not set."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Optional document expiry date; null if not set."
            }
          ],
          "description": "Optional document expiry date; null if not set."
        }
      },
      "required": [
        "seller_id",
        "business_profile_id",
        "document_type",
        "document_file_url",
        "issue_date"
      ],
      "description": "Payload for creating a new seller verification document. Must specify all relevant identification and file details for onboarding or compliance."
    },
    "IAiEcommerceSellerVerificationDocument.IUpdate": {
      "type": "object",
      "properties": {
        "document_type": {
          "type": "string",
          "description": "Updated document type (optional)."
        },
        "document_file_url": {
          "type": "string",
          "description": "Updated document file URI."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Updated issue date."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Nullable updated expiry date."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Nullable updated expiry date."
            }
          ],
          "description": "Nullable updated expiry date."
        },
        "verified_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the document is verified by admin."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when the document is verified by admin."
            }
          ],
          "description": "Timestamp when the document is verified by admin."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft delete timestamp, or null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft delete timestamp, or null if active."
            }
          ],
          "description": "Soft delete timestamp, or null if active."
        }
      },
      "description": "Request body for updating seller verification document metadata, used in onboarding or compliance workflows. Enables modification of properties such as document type, file URI, issue or expiry date, and verification status.",
      "required": []
    },
    "IAdminActionLog.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for log pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Number of log records per page."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by administrator UUID."
        },
        "role_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by role UUID."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by related seller UUID."
        },
        "target_type": {
          "type": "string",
          "description": "Target type (e.g. user, seller, system_policy)."
        },
        "action_type": {
          "type": "string",
          "description": "Action type (e.g. role_grant, onboarding_approve, data_export, etc.)."
        },
        "status": {
          "type": "string",
          "description": "Optional status, may be used for custom status values or filtering."
        },
        "created_after": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for logs created after this date."
        },
        "created_before": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for logs created before this date."
        }
      },
      "description": "Search and paginate administrator action logs for compliance and incident investigation. Enables filtering and retrieving action log entries based on actor, target, event action, or timeframe.",
      "required": []
    },
    "IPageAdminActionLog": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total log records matching criteria."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAdminActionLog"
          },
          "description": "Paged array of admin action log records."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paged results for administrator action log searches. Used for compliance investigations and platform audits."
    },
    "IAdminActionLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique log entry ID."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the administrator who performed the action."
        },
        "role_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Role UUID for role actions."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Role UUID for role actions."
            }
          ],
          "description": "Role UUID for role actions."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Related seller for the admin action (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Related seller for the admin action (nullable)."
            }
          ],
          "description": "Related seller for the admin action (nullable)."
        },
        "target_type": {
          "type": "string",
          "description": "Subject of the admin action, e.g., user, seller, system_policy."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Target row/entity for the action if relevant."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Target row/entity for the action if relevant."
            }
          ],
          "description": "Target row/entity for the action if relevant."
        },
        "action_type": {
          "type": "string",
          "description": "Type of action taken, e.g., role_grant, data_export, onboarding_approve."
        },
        "action_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Additional context or description for the action."
            },
            {
              "type": "null",
              "description": "Additional context or description for the action."
            }
          ],
          "description": "Additional context or description for the action."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of the action."
        }
      },
      "required": [
        "id",
        "administrator_id",
        "target_type",
        "action_type",
        "created_at"
      ],
      "description": "A record of a sensitive or configuration-changing administrator action performed on the system. Enables tracking and auditing of role, onboarding, privilege, or system/admin policy actions."
    },
    "IAdminActionLog.ICreate": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "Admin UUID performing the action."
        },
        "role_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Role affected by the action (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Role affected by the action (nullable)."
            }
          ],
          "description": "Role affected by the action (nullable)."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller affected by the action (optional)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller affected by the action (optional)."
            }
          ],
          "description": "Seller affected by the action (optional)."
        },
        "target_type": {
          "type": "string",
          "description": "Target of the action, such as 'user', 'seller', 'system_policy'."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Entity acted on (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Entity acted on (nullable)."
            }
          ],
          "description": "Entity acted on (nullable)."
        },
        "action_type": {
          "type": "string",
          "description": "Action performed, e.g., onboarding_approve, role_grant."
        },
        "action_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Full explanation/context JSON or text."
            },
            {
              "type": "null",
              "description": "Full explanation/context JSON or text."
            }
          ],
          "description": "Full explanation/context JSON or text."
        }
      },
      "required": [
        "administrator_id",
        "target_type",
        "action_type"
      ],
      "description": "Payload to create a new administrator action log entry. Used in platform compliance and sensitive operations."
    },
    "IAdminActionLog.IUpdate": {
      "type": "object",
      "properties": {
        "action_detail": {
          "type": "string",
          "description": "Update the action detail/context."
        }
      },
      "description": "Update/patch request for admin action log, used for adding context or correction to an existing admin action record.",
      "required": []
    },
    "IRole.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "name": {
          "type": "string",
          "description": "Role name filter (supports partial match)."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Filter roles created after this date."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "Filter roles created before this date."
        }
      },
      "description": "Filter, search, and paginate roles in the RBAC system. Used by admin role/privilege UI for audit, search, or configuration.",
      "required": []
    },
    "IPageRole": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total number of matching roles."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IRole"
          },
          "description": "Paged array of role records."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paged results for role database table/entity. Used for admin views and privilege dashboards."
    },
    "IRole": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  .   RBAC   .\n\nPrisma  id  ,    .\n"
        },
        "name": {
          "type": "string",
          "description": " (: 'administrator', 'seller' ). RBAC    .\n\nPrisma  name ()."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": " . , UI  ,   .\n\nPrisma description() ."
            },
            {
              "type": "null"
            }
          ],
          "description": " . , UI  ,   .\n\nPrisma description() ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "  .        .\n\nPrisma  created_at ()."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "    .   , UI   .\n\nPrisma  updated_at ()."
        }
      },
      "required": [
        "id",
        "name",
        "created_at",
        "updated_at"
      ],
      "description": "(RBAC)  .     (: admin, seller ),    .\n\nPrisma schema ai_ecommerce_roles   description,   .    , ,  , UI   .\n"
    },
    "IRole.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "  .   , RBAC /  ."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": " .  , UI,     ."
            },
            {
              "type": "null"
            }
          ],
          "description": " .  , UI,     ."
        }
      },
      "required": [
        "name"
      ],
      "description": "  (request body) DTO.\n\nname  , description . Prisma ai_ecommerce_roles   .\n"
    },
    "IRole.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "  .  .    ."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": " . UI    ."
            },
            {
              "type": "null"
            }
          ],
          "description": " . UI    ."
        }
      },
      "required": [],
      "description": "  (request body) DTO. name, description  .\n\nPrisma ai_ecommerce_roles   ."
    },
    "ai_ecommerce_permission.IRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": " (). RBAC   / .\n\nPrisma name   ."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": " (/ , ).\n\nPrisma description   ."
            },
            {
              "type": "null"
            }
          ],
          "description": " (/ , ).\n\nPrisma description   ."
        }
      },
      "required": [],
      "description": "(Permission)   /  DTO.\n\nai_ecommerce_permissions   RBAC    ."
    },
    "IPageai_ecommerce_permission": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": " .  IPage (generic) .\n"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_permission"
          },
          "description": "   (permission)  .\n"
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "(Permission)   .  IPage  .\n"
    },
    "ai_ecommerce_permission": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "(Permission)  (primary key). RBAC    ,  .\n\nPrisma ai_ecommerce_permissions - id  ."
        },
        "name": {
          "type": "string",
          "description": " .  RBAC   .\n\nPrisma  name ()  ."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "  //  . UI, ,    .\n\nPrisma description   ."
            },
            {
              "type": "null"
            }
          ],
          "description": "  //  . UI, ,    .\n\nPrisma description   ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "(Permission)  . RBAC    / .\n\nPrisma : created_at"
        }
      },
      "required": [
        "id",
        "name",
        "created_at"
      ],
      "description": "(Permission)   . RBAC // ,   Prisma schema .\n"
    },
    "ai_ecommerce_permission.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "  . RBAC   key, ."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": " ( ). ."
            },
            {
              "type": "null"
            }
          ],
          "description": " ( ). ."
        }
      },
      "required": [
        "name"
      ],
      "description": "  (request body) DTO. name .\n\nPrisma ai_ecommerce_permissions   business logic ."
    },
    "ai_ecommerce_permission.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "   name()."
        }
      },
      "description": "   DTO.      .",
      "required": []
    },
    "ai_ecommerce_permission.IDeleteResult": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "  .\n"
        },
        "message": {
          "type": "string",
          "description": "  .      .\n"
        }
      },
      "required": [
        "success"
      ],
      "description": " /Delete API  .  ,   .\n"
    },
    "ai_ecommerce_product.IRequest": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": " (title) - ,  .     \n\n(Prisma: title)"
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": " () id. ,  filtering \n\n(Prisma: seller_id)"
        },
        "status": {
          "type": "string",
          "description": " ('published','draft' ). /  .\n\n(Prisma: status )"
        },
        "approval_state": {
          "type": "string",
          "description": "/ . compliance . (: 'approved','pending' )\n\nPrisma: approval_state"
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "/ .  \n"
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "/ .  \n"
        }
      },
      "required": [],
      "description": " / (body) DTO. ai_ecommerce_products  atomic    .\n"
    },
    "IPageai_ecommerce_product": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": " .  IPage ,   .\n"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product"
          },
          "description": "   ai_ecommerce_product  "
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "(ai_ecommerce_product)   .  IPage (structure) .\n"
    },
    "ai_ecommerce_product": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  (Prisma: id). cross-entity ,  ,   ."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "  /(). , RBAC, seller filtering .\n\nPrisma: seller_id"
        },
        "title": {
          "type": "string",
          "description": " /. customer-facing. .\n\nPrisma: title"
        },
        "description": {
          "type": "string",
          "description": " ( , atomic,    ). UI .\n\nPrisma: description"
        },
        "status": {
          "type": "string",
          "description": " .  ,    .\n\nPrisma: status"
        },
        "approval_state": {
          "type": "string",
          "description": " / (). compliance/workflow .\n\nPrisma: approval_state"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " .   ,  .\n\nPrisma: created_at"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "  . , UI  .\n\nPrisma: updated_at"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  . null , timestamp  .\n\nPrisma: deleted_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "  . null , timestamp  .\n\nPrisma: deleted_at"
        }
      },
      "required": [
        "id",
        "seller_id",
        "title",
        "description",
        "status",
        "approval_state",
        "created_at",
        "updated_at"
      ],
      "description": "   DTO.  / ai_ecommerce_products Prisma       business/  .\n"
    },
    "ai_ecommerce_product.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "The UUID of the seller who owns this product. Implements strict foreign-key normalization and is required for all product creation as per the Prisma schema and business rules."
        },
        "title": {
          "type": "string",
          "description": "The product's display name. String value, required and unique per seller, must be human-friendly. Multilingual support is handled via related tables."
        },
        "description": {
          "type": "string",
          "description": "A detailed description providing information about the product. Long text, required. Multilingual variants handled externally."
        },
        "status": {
          "type": "string",
          "description": "Product lifecycle status (e.g., draft, pending, published, archived). Must be an atomic value, follows workflow state conventions enforced in application code."
        },
        "approval_state": {
          "type": "string",
          "description": "Compliance/approval state of the product, such as 'pending', 'approved', 'rejected'. Should match business workflow state machine."
        }
      },
      "required": [
        "seller_id",
        "title",
        "description",
        "status",
        "approval_state"
      ],
      "description": "Payload for creating a new product as per ai_ecommerce_product schema. Contains all required atomic fields for a new catalog item, strictly follows 3NF and business rules. For use by seller onboarding, admin dashboard, or programmatic product import."
    },
    "ai_ecommerce_product.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "(Optional) New title for the product. Subject to uniqueness per seller, must be human-friendly. Must follow multilingual conventions if application requires."
        },
        "description": {
          "type": "string",
          "description": "(Optional) Updated product description. Free-form, subject to length and business rules."
        },
        "status": {
          "type": "string",
          "description": "(Optional) New status for the product (draft, published, archived, etc). Value must align with allowed catalog workflow transitions."
        },
        "approval_state": {
          "type": "string",
          "description": "(Optional) Updated approval state. (pending, approved, rejected, etc)."
        }
      },
      "description": "Update structure for ai_ecommerce_product row. Permits optional modification of human-friendly fields and workflow lifecycles, following 3NF and product management best practices.",
      "required": []
    },
    "ai_ecommerce_product.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted product."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this product was marked as deleted (soft delete)."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Standard confirmation/result payload for a deleted (soft) ai_ecommerce_product. Used for compliance, audit, and confirmation flows."
    },
    "ai_ecommerce_sku.IRequest": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional filter. Return only SKUs for the specified product UUID."
        },
        "code": {
          "type": "string",
          "description": "Optional filter for SKU code (per product uniqueness is enforced in DB)."
        },
        "is_active": {
          "type": "boolean",
          "description": "Optional filter for active/inactive SKUs only."
        },
        "min_price": {
          "type": "number",
          "format": "double",
          "description": "Optional filter for SKUs at or above this price."
        },
        "max_price": {
          "type": "number",
          "format": "double",
          "description": "Optional filter for SKUs at or below this price."
        },
        "sort": {
          "type": "string",
          "description": "Field to sort SKUs by (e.g., 'price', 'created_at')."
        },
        "order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order. Should be 'asc' or 'desc'."
            },
            {
              "const": "desc",
              "description": "Sort order. Should be 'asc' or 'desc'."
            }
          ],
          "description": "Sort order. Should be 'asc' or 'desc'."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination. Default typically 1."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page. Default typically 50-100."
        }
      },
      "description": "Filtering, sorting, and paginating request body for SKU listing/search endpoint, as per ai_ecommerce_sku PATCH operation.",
      "required": []
    },
    "IPageai_ecommerce_sku": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_sku"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container result for lists of ai_ecommerce_sku records. Contains both pagination metadata and an array of SKU result objects."
    },
    "ai_ecommerce_sku": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for SKU row. UUID for global uniqueness."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Product foreign key indicating to which product this SKU belongs."
        },
        "code": {
          "type": "string",
          "description": "SKU code, required, unique per product. For barcode/inventory reference."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "Atomic price for this SKU, as double. No derived or aggregate values in schema."
        },
        "currency": {
          "type": "string",
          "description": "ISO 4217 currency code, e.g., 'USD', 'KRW', etc."
        },
        "is_active": {
          "type": "boolean",
          "description": "SKU active flag. True = orderable, false = unavailable for sale."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp for row creation."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp for last update."
        }
      },
      "required": [
        "id",
        "product_id",
        "code",
        "price",
        "currency",
        "is_active",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic sellable product variant (SKU) with all normalized fields, strictly as per ai_ecommerce_sku/schemas/DB model. Used throughout order, inventory, and catalog flows. For analytics/data transfer, use this as the main object reference. No embedded objects, only atomic references to other entities (e.g. product_id references ai_ecommerce_product)."
    },
    "ai_ecommerce_skus.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to parent product for SKU. Required, validated on creation."
        },
        "code": {
          "type": "string",
          "description": "New SKU code (barcode or business code). Required, unique per product."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "Set unit price for new SKU (atomic price only)."
        },
        "currency": {
          "type": "string",
          "description": "Currency code (e.g., 'KRW', 'USD'). Required."
        },
        "is_active": {
          "type": "boolean",
          "description": "Active flag for SKU (defaults true). Required."
        }
      },
      "required": [
        "product_id",
        "code",
        "price",
        "currency",
        "is_active"
      ],
      "description": "Payload for creating a new SKU entity for a catalog product. Ensures per-product uniqueness, referential integrity, and atomic business logic."
    },
    "ai_ecommerce_skus": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid"
        },
        "product_id": {
          "type": "string",
          "format": "uuid"
        },
        "code": {
          "type": "string"
        },
        "price": {
          "type": "number",
          "format": "double"
        },
        "currency": {
          "type": "string"
        },
        "is_active": {
          "type": "boolean"
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "product_id",
        "code",
        "price",
        "currency",
        "is_active",
        "created_at",
        "updated_at"
      ],
      "description": "Exact same as ai_ecommerce_sku; may be used as alternate schema for list or legacy API, included for compatibility."
    },
    "ai_ecommerce_skus.IUpdate": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "(Optional) New SKU code (must stay unique per product)."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "(Optional) New price in currency units. If updating price, sets new atomic value."
        },
        "currency": {
          "type": "string",
          "description": "(Optional) New currency code (ISO 4217)."
        },
        "is_active": {
          "type": "boolean",
          "description": "(Optional) Set SKU as active/inactive for sale."
        }
      },
      "description": "Fields for updating an existing SKU. Must match atomic, normalized business structure. Only included fields are updated.",
      "required": []
    },
    "ai_ecommerce_categories.IRequest": {
      "type": "object",
      "properties": {
        "parent_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional filter to only fetch categories under this parent category (UUID)."
        },
        "name": {
          "type": "string",
          "description": "Optional fuzzy or exact filter for category name."
        },
        "created_before": {
          "type": "string",
          "format": "date-time",
          "description": "Optional filter: only return categories created before this ISO timestamp."
        },
        "created_after": {
          "type": "string",
          "format": "date-time",
          "description": "Optional filter: only return categories created after this ISO timestamp."
        },
        "sort": {
          "type": "string",
          "description": "Field to sort categories by (e.g., 'name', 'created_at')."
        },
        "order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order ('asc' or 'desc')."
            },
            {
              "const": "desc",
              "description": "Sort order ('asc' or 'desc')."
            }
          ],
          "description": "Sort order ('asc' or 'desc')."
        },
        "page": {
          "type": "integer",
          "description": "Requested page number for pagination, starting from 1."
        },
        "limit": {
          "type": "integer",
          "description": "Number of records per page to return."
        }
      },
      "description": "Request body for PATCH search/filter endpoint for ai_ecommerce_categories (product category) entity. Supports hierarchical and attribute-based queries.",
      "required": []
    },
    "IPageai_ecommerce_categories": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_categories"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response container for ai_ecommerce_categories entity, includes both pagination metadata and array of category records."
    },
    "ai_ecommerce_categories": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary category key (UUID)."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of parent category, null for root categories only."
            },
            {
              "type": "null"
            }
          ],
          "description": "UUID of parent category, null for root categories only."
        },
        "name": {
          "type": "string",
          "description": "Category name (unique under parent)."
        },
        "description": {
          "type": "string",
          "description": "Long description, used for context/help/navigation."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of category creation (ISO 8601)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of category last update (ISO 8601)."
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic product category node, supporting multi-level category taxonomies as defined in ai_ecommerce_categories, with normalized parent-child references."
    },
    "ai_ecommerce_categories.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the category. Required. Must be unique for a given parent category. Example: 'AI-Enabled Devices'. [Prisma: Category Name] Defines the commercial label for this taxonomy node. Used for navigation, filtering, and product attribution.\n\nBusiness rules: Must be a concise, human-readable, and unique value within the scope of its parent category. Strictly an atomic field."
        },
        "description": {
          "type": "string",
          "description": "A human-readable description of the category's purpose or context. Example: 'Robotics/AI-powered hardware.' [Prisma: Description]\n\nUsed in admin UI, category help messages, and hierarchical display. Should give meaningful context to merchants and shoppers defining or choosing this category."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
            }
          ],
          "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
        }
      },
      "required": [
        "name",
        "description"
      ],
      "description": "Request type for creating a product category entity (ai_ecommerce_categories table). Aligns with the product catalog taxonomy requirements. Properties must match the strict normalization in the DB schema: category name, description, and optional parent category FK.\n\nReferences: ai_ecommerce_categories Prisma model and ERD."
    },
    "ai_ecommerce_categories.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The edited name for the category (see .ICreate for full description and constraints). Optional. If omitted, name remains unchanged."
        },
        "description": {
          "type": "string",
          "description": "Edited description for the category. Optional. If not provided, value is not updated."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
            }
          ],
          "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
        }
      },
      "description": "Request type for updating a product category entity (ai_ecommerce_categories table). All properties are optional and only supplied fields are mutated. Strictly matches DB constraints: category name (unique under parent), description, parent_id tree logic.",
      "required": []
    },
    "ai_ecommerce_inventories.IRequest": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Search and filter by FK to SKU table (Inventory is per-SKU/location). Optional. If provided, filters inventory records for a specific SKU only. [Prisma: sku_id]"
        },
        "location": {
          "type": "string",
          "description": "Optional. Text filter for warehouse, fulfillment center, or storage location. [Prisma: location]"
        },
        "min_quantity_available": {
          "type": "integer",
          "description": "Min quantity filter for available stock (inclusive). Optional. Results limited to entries with at least this many in stock."
        },
        "max_quantity_available": {
          "type": "integer",
          "description": "Max quantity filter. Limits to inventories with available quantities up to this number."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination, optional."
        },
        "limit": {
          "type": "integer",
          "description": "Number of records per page (max page size enforcement/optional)."
        }
      },
      "description": "Request type for searching/filtering inventory records. Used in admin/warehouse dashboards and fulfillment systems. Maps to ai_ecommerce_inventories. Supports advanced querying on SKU, location, available quantity, and pagination.\n\nReferences: ai_ecommerce_inventories Prisma model and ERD.",
      "required": []
    },
    "IPageai_ecommerce_inventories": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Page status/metadata for the result set, including current page, limit, total records, and total pages. Follows platform-wide pagination standards."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_inventories"
          },
          "description": "Array of inventory records (ai_ecommerce_inventories) on the current page. Each item is a normalized inventory entity row."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result type for inventory search/list queries. Contains metadata about the page and array of results."
    },
    "ai_ecommerce_inventories": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary unique identifier for the inventory record. [Prisma: id]\n\nRequired for targeting, mutation, or referencing this stock row."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the corresponding SKU entity for which stock is tracked. (Product variant, atomic reference.) [Prisma: sku_id]"
        },
        "location": {
          "type": "string",
          "description": "Text label for physical warehouse, fulfillment center, bin, or locale. Must be atomic and unique per SKU. [Prisma: location]"
        },
        "quantity_available": {
          "type": "integer",
          "description": "Atomic count of in-stock, sellable quantity for this SKU/location. [Prisma: quantity_available]\n\nStrictly positive integer. No aggregate calculations (strict normalization)."
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Atomic count of units reserved (e.g., for pending orders, processing, or holds). [Prisma: quantity_reserved]"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for inventory row creation in UTC ISO8601 format. [Prisma: created_at]"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for most recent update of this inventory record. [Prisma: updated_at]"
        }
      },
      "required": [
        "id",
        "sku_id",
        "location",
        "quantity_available",
        "quantity_reserved",
        "created_at",
        "updated_at"
      ],
      "description": "Normalized inventory entity tracking per-SKU per-location stock. Strictly matches ai_ecommerce_inventories schema fields, supporting stock, warehouse, and fulfillment workflows. No aggregate logic, fully normalized. See ERD and DB documentation."
    },
    "ai_ecommerce_inventories.ICreate": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to SKU entity to which this inventory count pertains. [Prisma: sku_id] Required."
        },
        "location": {
          "type": "string",
          "description": "Text label for warehouse, fulfillment center, or inventory location. [Prisma: location] Required."
        },
        "quantity_available": {
          "type": "integer",
          "description": "Initial count of sellable stock units in location (must be non-negative, business logic applies for zero/negative). [Prisma: quantity_available]"
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Atomic count of units held for reservation in this location. Optional, default 0 if not supplied. [Prisma: quantity_reserved]"
        }
      },
      "required": [
        "sku_id",
        "location",
        "quantity_available"
      ],
      "description": "Request type for creating a new inventory stock row (ai_ecommerce_inventories). Follows 3NF rules and business constraints, see Prisma model. Atomic for each SKU/location."
    },
    "ai_ecommerce_inventories.IUpdate": {
      "type": "object",
      "properties": {
        "location": {
          "type": "string",
          "description": "Optional. New location value to which this inventory record is reassigned (not always mutable in business logic)."
        },
        "quantity_available": {
          "type": "integer",
          "description": "Optional. Updated saleable stock count for the item/location."
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Optional. Updated reserved quantity. Null, not provided, or omitted means value is unchanged."
        }
      },
      "description": "Update type for ai_ecommerce_inventories. Allows update of mutable inventory attributes: location, available/reserved quantities. ID not included as it is the PK path param.",
      "required": []
    },
    "IAiEcommerceMedia.IRequest": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional UUID of the product/SKU/category owning this media asset. [Prisma: owner_id] Can be filtered for parent entity."
        },
        "owner_type": {
          "type": "string",
          "description": "Restricts media assets by associated entity type. E.g., 'product', 'sku', 'category'. [Prisma: owner_type]"
        },
        "media_type": {
          "type": "string",
          "description": "Optional. Filters by file/media MIME type (e.g., 'image/jpeg', 'video/mp4'). [Prisma: media_type]"
        },
        "language": {
          "type": "string",
          "description": "Optional language code (such as 'en', 'ko'), for filtering media by content localization [Prisma: language]"
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which page number to retrieve."
        },
        "limit": {
          "type": "integer",
          "description": "Pagination control: maximum number of records per page."
        }
      },
      "description": "Request/search type for querying media assets. Supports entity linking, type filtering, MIME attributes, localization code, and pagination as per ai_ecommerce_media model.",
      "required": []
    },
    "IPageIAiEcommerceMedia": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Paging metadata for result navigation. Standard for all paginated system API returns."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceMedia"
          },
          "description": "Array of ai_ecommerce_media objects contained on the returned page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard paginated wrapper for media asset query responses (array of records + pagination info)."
    },
    "IAiEcommerceMedia": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for this media entry (PK, ai_ecommerce_media). [Prisma: id]"
        },
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to owning business object (product/SKU/category, determined by owner_type) [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Classification of owner entity (see product/SKU/category for enum, string enforced by business logic). [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "URL or resource path to storage. Can be S3/GCS/CDN/HTTP. Enforced maximum length in DB. [Prisma: uri]"
        },
        "media_type": {
          "type": "string",
          "description": "RFC MIME type for file: image/png, video/mp4, etc. [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
            }
          ],
          "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the media entity was inserted (ISO 8601 format, UTC). [Prisma: created_at]"
        }
      },
      "required": [
        "id",
        "owner_id",
        "owner_type",
        "uri",
        "media_type",
        "created_at"
      ],
      "description": "Normalized media object for platform file/media attachment. Strictly matches ai_ecommerce_media DB fields for attachment, catalog, or UI. Use in all file- or asset-related APIs. No blobs or embedded content."
    },
    "IAiEcommerceMedia.ICreate": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID FK reference to associated business object (product/SKU/category). Mandatory. [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Type discriminator for owning entity (product, sku, category). String; constraints enforced in logic. [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "Absolute/relative URL or file location, per media asset requirements. See [Prisma: uri]\n\nMust match CDN/GCS/S3 or localhost path conventions."
        },
        "media_type": {
          "type": "string",
          "description": "RFC-compliant MIME type specifying content encoding ('image/jpeg', etc). [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
            }
          ],
          "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
        }
      },
      "required": [
        "owner_id",
        "owner_type",
        "uri",
        "media_type"
      ],
      "description": "Input schema for registering/uploading new media asset. Strictly backend file/attachment asset registration (not file data itself). Required: owner_id/entity, type, URL, and media type per product/SKU/category."
    },
    "IAiEcommerceMedia.IUpdate": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional. If updating which entity owns this media file; rare in practice. [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Optional. If updating the owner type (rare). Must match entity types allowed. [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "Optional. Update file location/path for this entity. [Prisma: uri]"
        },
        "media_type": {
          "type": "string",
          "description": "Optional. Update file type (MIME). Only allowed for migration; most business logic prohibits type update for compliance. [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
            }
          ],
          "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
        }
      },
      "description": "Input type for updating ai_ecommerce_media asset metadata. Only properties provided are updated; unchanged attributes are left as-is. Strict FK/compliance logic applies depending on asset/owner/usage.",
      "required": []
    },
    "IAiEcommerceProductOptions.IRequest": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "The UUID of the product to filter options for. If provided, only options belonging to this product will be included in search/filter results.\n\nReference: ai_ecommerce_product_options.product_id column."
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Filter by the SKU UUID. If included, only options specific to this SKU will be considered. Null means options that are not SKU-specific.\n\nReference: ai_ecommerce_product_options.sku_id column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter by the SKU UUID. If included, only options specific to this SKU will be considered. Null means options that are not SKU-specific.\n\nReference: ai_ecommerce_product_options.sku_id column."
        },
        "option_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter for a specific product option name (e.g., 'Color', 'Size'). Null to include all option names.\n\nReference: ai_ecommerce_product_options.option_name field."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter for a specific product option name (e.g., 'Color', 'Size'). Null to include all option names.\n\nReference: ai_ecommerce_product_options.option_name field."
        },
        "option_value": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter for a specific value for the chosen option name. Null means include all values for matching name.\n\nReference: ai_ecommerce_product_options.option_value field."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter for a specific value for the chosen option name. Null means include all values for matching name.\n\nReference: ai_ecommerce_product_options.option_value field."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Lower bound (RFC3339 date string) for option creation timestamp to filter options created on or after this date.\n\nReference: ai_ecommerce_product_options.created_at column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Lower bound (RFC3339 date string) for option creation timestamp to filter options created on or after this date.\n\nReference: ai_ecommerce_product_options.created_at column."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound (RFC3339 date string) for option creation timestamp to filter options created on or before this date.\n\nReference: ai_ecommerce_product_options.created_at column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound (RFC3339 date string) for option creation timestamp to filter options created on or before this date.\n\nReference: ai_ecommerce_product_options.created_at column."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Page number for paginated results. Defaults to 1 if not provided.\n\nReference: Pagination information."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Result page size. Max 100 per page. Defaults to 20 if not supplied.\n\nReference: Typical limit for paged results."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional sorting field, such as 'created_at', 'option_name', 'option_value'. Prefix with '-' for descending (e.g. '-created_at').\n\nReference: UI sorting choice for listing product options."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional sorting field, such as 'created_at', 'option_name', 'option_value'. Prefix with '-' for descending (e.g. '-created_at').\n\nReference: UI sorting choice for listing product options."
        }
      },
      "required": [
        "product_id"
      ],
      "description": "Request filter structure for listing/searching ai_ecommerce_product_options entries.\n\nReference: Used as request body in PATCH /ai_ecommerce/productOptions for filtering options by product, SKU, name, value, date, plus paging and sorting.\n\nAll field descriptions reference ai_ecommerce_product_options columns."
    },
    "IPageIAiEcommerceProductOptions": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceProductOptions"
          },
          "description": "Array of product option entity rows for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container structure for ai_ecommerce_product_options result sets.\n\nReferences: Used as the response body for PATCH /ai_ecommerce/productOptions.\n\nIncludes pagination info and an array of option objects."
    },
    "IAiEcommerceProductOptions": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the product option row.\n\nReference: ai_ecommerce_product_options.id"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the owning product.\n\nReference: ai_ecommerce_product_options.product_id"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Foreign key to the associated SKU, if this option is scoped to a specific SKU.\n\nReference: ai_ecommerce_product_options.sku_id"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Foreign key to the associated SKU, if this option is scoped to a specific SKU.\n\nReference: ai_ecommerce_product_options.sku_id"
        },
        "option_name": {
          "type": "string",
          "description": "Option name (e.g., color, size).\n\nReference: ai_ecommerce_product_options.option_name"
        },
        "option_value": {
          "type": "string",
          "description": "Option value (e.g., red, XL).\n\nReference: ai_ecommerce_product_options.option_value"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (RFC3339) when this option was created.\n\nReference: ai_ecommerce_product_options.created_at"
        }
      },
      "required": [
        "id",
        "product_id",
        "option_name",
        "option_value",
        "created_at"
      ],
      "description": "Atomic, normalized product option entity as defined in ai_ecommerce_product_options schema.\n\nAll fields reference ai_ecommerce_product_options columns."
    },
    "IAiEcommerceProductOptions.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Product for which to add the option (FK).\n\nReference: ai_ecommerce_product_options.product_id"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Optionally link this row to a specific SKU if relevant.\n\nReference: ai_ecommerce_product_options.sku_id"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Optionally link this row to a specific SKU if relevant.\n\nReference: ai_ecommerce_product_options.sku_id"
        },
        "option_name": {
          "type": "string",
          "description": "Name of the product option to add (required).\n\nReference: ai_ecommerce_product_options.option_name"
        },
        "option_value": {
          "type": "string",
          "description": "Atomic value of the option to insert (required).\n\nReference: ai_ecommerce_product_options.option_value"
        }
      },
      "required": [
        "product_id",
        "option_name",
        "option_value"
      ],
      "description": "Request payload to create a new product option row in ai_ecommerce_product_options.\n\nAll fields reference ai_ecommerce_product_options columns."
    },
    "IAiEcommerceProductOptions.IUpdate": {
      "type": "object",
      "properties": {
        "option_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Update the option name."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Update the option name."
        },
        "option_value": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Update the option value."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Update the option value."
        }
      },
      "required": [],
      "description": "Request payload to update a product option row in ai_ecommerce_product_options. Only option_name and option_value are permitted to change.\n\nReference: Used in PUT /ai_ecommerce/productOptions/{id}"
    },
    "IAiEcommerceProductComplianceRules.IRequest": {
      "type": "object",
      "properties": {
        "rule_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter compliance rules by rule name.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter compliance rules by rule name.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Full-text filter/search for rule description.\n\nReference: ai_ecommerce_product_compliance_rules.description"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Full-text filter/search for rule description.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Created at lower bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Created at lower bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Page number to retrieve. Defaults to 1."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Number of items per page. Max 100."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field: 'created_at', 'rule_name'. Descending with '-prefix'."
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort field: 'created_at', 'rule_name'. Descending with '-prefix'."
        }
      },
      "required": [],
      "description": "Request object for searching/filtering/paginating ai_ecommerce_product_compliance_rules.\n\nReference: Used as PATCH /ai_ecommerce/productComplianceRules request body."
    },
    "IPageIAiEcommerceProductComplianceRules": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product_compliance_rules"
          },
          "description": "Array of compliance rule rows for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result set structure for ai_ecommerce_product_compliance_rules search/list endpoints.\n\nReference: Response for PATCH /ai_ecommerce/productComplianceRules."
    },
    "ai_ecommerce_product_compliance_rules": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key, unique id for the compliance rule row.\n\nReference: ai_ecommerce_product_compliance_rules.id"
        },
        "rule_name": {
          "type": "string",
          "description": "Canonical atomic name for the rule.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the rule, as stored in the table.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation timestamp (RFC3339).\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        }
      },
      "required": [
        "id",
        "rule_name",
        "description",
        "created_at"
      ],
      "description": "Atomic, normalized compliance rule entity (ai_ecommerce_product_compliance_rules table).\n\nEvery property references a column in the ai_ecommerce_product_compliance_rules table."
    },
    "ai_ecommerce_product_compliance_rules.ICreate": {
      "type": "object",
      "properties": {
        "rule_name": {
          "type": "string",
          "description": "Canonical name for compliance rule to create. Must be unique.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "type": "string",
          "description": "Long-form explanation or description for this rule, as required for compliance teams and auditing workflows.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        }
      },
      "required": [
        "rule_name",
        "description"
      ],
      "description": "Payload for creating a new compliance rule row in ai_ecommerce_product_compliance_rules.\n\nEach property references a normalized DB column."
    },
    "ai_ecommerce_product_compliance_rules.IUpdate": {
      "type": "object",
      "properties": {
        "rule_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "Canonical name update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
            },
            {
              "type": "null"
            }
          ],
          "description": "Canonical name update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "Rule description update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.description"
            },
            {
              "type": "null"
            }
          ],
          "description": "Rule description update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.description"
        }
      },
      "required": [],
      "description": "Payload to update an existing compliance rule row in ai_ecommerce_product_compliance_rules.\n\nFields are optional; only include what should be changed."
    },
    "ai_ecommerce_product_compliance_rules.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the compliance rule that was deleted.\n\nReference: ai_ecommerce_product_compliance_rules.id"
        },
        "deleted": {
          "type": "boolean",
          "description": "True if deletion succeeded (soft or hard as dictated by business logic)."
        },
        "message": {
          "type": "string",
          "description": "Optional human-readable explanation or error message from the delete process."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": "Standardized result object for delete confirmation for compliance rules.\n\nUsed in DELETE API response for /ai_ecommerce/productComplianceRules/{id}."
    },
    "ai_ecommerce_product_tags.IRequest": {
      "type": "object",
      "properties": {
        "name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter by tag name; performs exact or pattern search depending on implementation.\n\nReference: ai_ecommerce_product_tags.name."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter by tag name; performs exact or pattern search depending on implementation.\n\nReference: ai_ecommerce_product_tags.name."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Lower bound for 'created_at' date. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Lower bound for 'created_at' date. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound (before or on) for 'created_at'. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound (before or on) for 'created_at'. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field: 'name', 'created_at'. Descending with '-' prefix."
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort field: 'name', 'created_at'. Descending with '-' prefix."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Request page number for pagination (default 1)."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Number of rows per page. Max 100 (default per implementation)."
        }
      },
      "required": [],
      "description": "Search/filter/pagination parameters for product tags (ai_ecommerce_product_tags) list endpoints.\n\nAll properties reference ai_ecommerce_product_tags columns."
    },
    "ai_ecommerce_product_tags.IPage": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "  .\n\n          ."
        },
        "page": {
          "type": "integer",
          "description": "  .\n\n    page   . 0  1 ,      ."
        },
        "limit": {
          "type": "integer",
          "description": "      .\n\n     limit    .  20  50    ."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product_tags"
          },
          "description": "     .\n\nai_ecommerce_product_tags   ,      ."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "     .\n\n  ai_ecommerce_product_tags        .   `/ai_ecommerce/productTags`  ,        . Prisma  comments ERD     ,  , ,   .\n\n property    , null    Prisma  ."
    },
    "ai_ecommerce_product_tags": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-wide unique tag ID.\n\n , , ,     . Prisma ERD   system  PK/UK  ."
        },
        "name": {
          "type": "string",
          "description": "- . : 'AI', 'Green', 'Gift Ideas'.\n\n////     . UK  ,      ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "    ISO 8601 UTC  .\n\n    ,       ."
        }
      },
      "required": [
        "id",
        "name",
        "created_at"
      ],
      "description": "    .\n\nPrisma ai_ecommerce_product_tags  ,   PK, ,     .       (: UK, PK, null  )   .\n\n  , ,      ."
    },
    "ai_ecommerce_product_tags.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "  . : 'AI', 'Summer', 'Gift'.\n\nUK()  ,       .\n\nPrisma   ,   null     50       ."
        }
      },
      "required": [
        "name"
      ],
      "description": "      .\n\n  (POST)    ,  name  , id/created_at   .\n\n  ,    name    backend   ."
    },
    "ai_ecommerce_product_tags.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "  .\n\n    name (UK)    ,  null//    ."
        }
      },
      "required": [
        "name"
      ],
      "description": "   ()   .\n\nPUT/PATCH `/ai_ecommerce/productTags/{id}` body .\n\nname     (UK),  null/    backend ,  / validation  ."
    },
    "ai_ecommerce_product_tags.IDeleteResult": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "   . true  , false / /   ."
        },
        "deletedId": {
          "type": "string",
          "format": "uuid",
          "description": " (soft/hard)  uuid.\n\n   null ()."
        }
      },
      "required": [
        "success"
      ],
      "description": "     .\n\n(soft/hard)  ,       uuid( null  undefined) .\n\n / API        ."
    },
    "ai_ecommerce_inquiry.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  (customer) UUID.      ."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID.    ."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "       order UUID ()."
        },
        "title": {
          "type": "string",
          "description": "      .\n\n  (: '', '')  ."
        },
        "status": {
          "type": "string",
          "description": " (: 'open', 'closed', 'pending', )   .      enum ."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "  (from) - ISO 8601 \n\n        ."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "  (to) - ISO 8601 "
        },
        "is_private": {
          "type": "boolean",
          "description": "   (). true  , false  , undefined  ."
        },
        "page": {
          "type": "integer",
          "description": " (0 or 1 ,   )"
        },
        "limit": {
          "type": "integer",
          "description": "   ,   10/20/50   "
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "/   //   DTO.\n\nPrisma ai_ecommerce_inquiry    DTO, , , , ,       .  (page, limit)   ,   ( ) ."
    },
    "ai_ecommerce_inquiry.IPage": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "   \n\n     "
        },
        "page": {
          "type": "integer",
          "description": "  "
        },
        "limit": {
          "type": "integer",
          "description": "  "
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_inquiry"
          },
          "description": "  ai_ecommerce_inquiry  "
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": " /   .\n\nPrisma ai_ecommerce_inquiry     ."
    },
    "ai_ecommerce_inquiry": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "    (PK, UUID)\n\n inquiry  ID /."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID (ai_ecommerce_customer PK )\n\n /   ."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "   UUID\n\n     ."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "     UUID  (nullable)\n\n   null "
        },
        "title": {
          "type": "string",
          "description": " \n\nUI     ."
        },
        "body": {
          "type": "string",
          "description": " / ()\n\n , ,      ."
        },
        "status": {
          "type": "string",
          "description": "  (: 'open', 'closed', 'pending'   )\n\n///   workflow  ."
        },
        "is_private": {
          "type": "boolean",
          "description": "  \n\ntrue , false   ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " (UTC, ISO 8601)\n\n   ."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (ISO 8601)"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "    (ISO8601, null   )"
            },
            {
              "type": "null"
            }
          ],
          "description": "    (ISO8601, null   )"
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "title",
        "body",
        "status",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "/    .\n\nai_ecommerce_inquiry   row .      ,  FK,    . deleted_at   .  body    ."
    },
    "ai_ecommerce_inquiry.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": " (  ) UUID\n\n(       )"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "   UUID ()"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "     UUID,    null."
            },
            {
              "type": "null"
            }
          ],
          "description": "     UUID,    null."
        },
        "title": {
          "type": "string",
          "description": "  ()\n\nUI  ,     "
        },
        "body": {
          "type": "string",
          "description": "   ()\n\n  "
        },
        "is_private": {
          "type": "boolean",
          "description": "  . true 1:1 , false ( false )"
        }
      },
      "required": [
        "customer_id",
        "product_id",
        "title",
        "body"
      ],
      "description": "/    DTO,      .\n\n  customer     api  , order_id nullable,  .\n\n       ."
    },
    "IAiEcommerceInquiry.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "   ()\n\n  "
        },
        "body": {
          "type": "string",
          "description": "    ()\n\n "
        },
        "status": {
          "type": "string",
          "description": " (, )  ()\n\n  enum ( )"
        },
        "is_private": {
          "type": "boolean",
          "description": "/  ()"
        }
      },
      "description": "/    .\n\nPUT/PATCH    (,,, )  (Partial)  .       .\n\n  (,  FK )  .",
      "required": []
    },
    "IAiEcommerceInquiry": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "    (PK, UUID)\n\n inquiry  ID /."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID (ai_ecommerce_customer PK )\n\n /   ."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "   UUID\n\n     ."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "     UUID  (nullable)\n\n   null "
            },
            {
              "type": "null"
            }
          ],
          "description": "     UUID  (nullable)\n\n   null "
        },
        "title": {
          "type": "string",
          "description": " \n\nUI     ."
        },
        "body": {
          "type": "string",
          "description": " / ()\n\n , ,      ."
        },
        "status": {
          "type": "string",
          "description": "  (: 'open', 'closed', 'pending'   )\n\n///   workflow  ."
        },
        "is_private": {
          "type": "boolean",
          "description": "  \n\ntrue , false   ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " (UTC, ISO 8601)\n\n   ."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (ISO 8601)"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "    (ISO8601, null   )"
            },
            {
              "type": "null"
            }
          ],
          "description": "    (ISO8601, null   )"
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "title",
        "body",
        "status",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "/     (  ISummary   ).\n\nai_ecommerce_inquiry   row , deleted_at   ."
    },
    "IAiEcommerceReview.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  () UUID()"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID()"
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "/   UUID()"
        },
        "status": {
          "type": "string",
          "description": "  (: 'active', 'deleted', 'private', .  enum )"
        },
        "rating_min": {
          "type": "integer",
          "description": "  "
        },
        "rating_max": {
          "type": "integer",
          "description": "  "
        },
        "is_verified": {
          "type": "boolean",
          "description": "(verified)  "
        },
        "is_private": {
          "type": "boolean",
          "description": "    true,     false"
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "  (from) - ISO8601"
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "  (to) - ISO8601"
        },
        "page": {
          "type": "integer",
          "description": " "
        },
        "limit": {
          "type": "integer",
          "description": "  "
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "/      (DTO) .\n\nPrisma ai_ecommerce_review  ,  //     ."
    },
    "IPageIAiEcommerceReview": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata describing the current page, limit, total records, and total pages for the result set. See IPage.IPagination, used for every paginated query throughout the system.\n\nAlways present, even for empty result sets. Follows the standard as described in the core documentation."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceReview"
          },
          "description": "Array of IAiEcommerceReview objects representing each review returned by the paginated query.\n\nEach record corresponds to a single customer review with its own atomic fields as per the ai_ecommerce_review schema."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result set of IAiEcommerceReview entities, conforming to platform standard for paging. Used to return multiple review records along with pagination metadata whenever a list of reviews is requested, as per the standard list/search API operations. All fields correspond to schema requirements and API conventions."
    },
    "IAiEcommerceReview": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the review row. Globally unique for each review instance; required for all update/delete/detail operations and all relational linkages (e.g., comments, moderation, etc).\n\nSee ai_ecommerce_review schema: 'id String @id @db.Uuid'"
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer who authored the review. Foreign Key to ai_ecommerce_customer. Used for ownership, moderation display, and auditing. Must always reference a legit customer id."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being reviewed; Foreign Key to ai_ecommerce_product. All reviews must reference a single specific product. Used for detail views, analytics, and aggregation."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order verification linkForeign Key to ai_ecommerce_order. Used to confirm verified purchase, required for business logic of reviews ('verified review')."
        },
        "rating": {
          "type": "integer",
          "description": "Atomic review rating (typically 1-5 or business-defined). Required for analytics and customer feedback logic. Positive integer, no decimals allowed."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional review titlenullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
            },
            {
              "type": "null",
              "description": "Optional review titlenullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
            }
          ],
          "description": "Optional review titlenullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
        },
        "body": {
          "type": "string",
          "description": "Main text content of the review. Required. Stores normalized review message, free-text."
        },
        "is_verified": {
          "type": "boolean",
          "description": "Booleantrue if review is linked to a successful order (verified purchase). Enforced by business logic and analytics."
        },
        "is_private": {
          "type": "boolean",
          "description": "Privacy toggle. If true, the review is not visible to the public/product page but can be used for internal workflows (e.g., feedback only)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the review was originally written. Used for chronological ordering, reporting, and compliance."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for last edit to review."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft deletion timestamp. If presentnot visible in standard queries, retained for audit/compliance."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft deletion timestamp. If presentnot visible in standard queries, retained for audit/compliance."
            }
          ],
          "description": "Soft deletion timestamp. If presentnot visible in standard queries, retained for audit/compliance."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "order_id",
        "rating",
        "body",
        "is_verified",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "A customer review as represented in the ai_ecommerce_review schema. Implements all atomic properties required for analytics, public display, moderation, and relational linking to orders, customers, products, and community features. Derived strictly from the PRISMA and ERD schemanot denormalized. For full audit trail or rollback, related snapshot tables are consulted."
    },
    "IAiEcommerceReview.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer authoring the review. Foreign Key, required for ownership traceability."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being reviewed."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order ID verifying that the purchase was made by the customer-author. Required for 'verified' logic."
        },
        "rating": {
          "type": "integer",
          "description": "Review rating numeric value. Required; integer (typically 15 as enforced by business logic)."
        },
        "body": {
          "type": "string",
          "description": "Main text body of the review. Required, must have user-supplied free text."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
            },
            {
              "type": "null",
              "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
            }
          ],
          "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
        },
        "is_private": {
          "type": "boolean",
          "description": "Boolean: If true, review is only internal/not shown on product page."
        }
      },
      "required": [
        "customer_id",
        "product_id",
        "order_id",
        "rating",
        "body",
        "is_private"
      ],
      "description": "Creation (POST) payload type for IAiEcommerceReview. Contains all fields required to create a new review given business constraints. All field constraints and relationships are enforced by the backend and described in the comments from the PRISMA schema."
    },
    "IAiEcommerceReview.IUpdate": {
      "type": "object",
      "properties": {
        "rating": {
          "type": "integer",
          "description": "Review rating numeric value. Optional for update (PATCH/PUT)."
        },
        "body": {
          "type": "string",
          "description": "Main text body of the review. Optional for update; present for PATCH."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Review title to update. Optional and nullable."
            },
            {
              "type": "null",
              "description": "Review title to update. Optional and nullable."
            }
          ],
          "description": "Review title to update. Optional and nullable."
        },
        "is_private": {
          "type": "boolean",
          "description": "Boolean: If true, review is hidden from public view. Optional for update."
        }
      },
      "required": [],
      "description": "Update payload for IAiEcommerceReview. All fields optional; only properties to be updated need be specified. The schema design matches business rules for PATCH/PUT to modify reviews post-creation. No layout-changing fields are permitted."
    },
    "IAiEcommerceForumThread.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer author who opened the thread, for searching by participant."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product discussed in the thread."
        },
        "category_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product category if the thread is category/QA oriented."
        },
        "status": {
          "type": "string",
          "description": "Status of the thread, such as 'open', 'closed', supporting search/filter for admins/moderators."
        },
        "title": {
          "type": "string",
          "description": "Full-text search by thread title."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Filter for 'pinned' thread status."
        },
        "is_private": {
          "type": "boolean",
          "description": "Search/show only private or public threads as needed."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for threads created at (ISO 8601) or since a particular timestamp."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "For sorting/filtering by last update."
        }
      },
      "required": [],
      "description": "Request/search parameters for paginated forum thread search in ai_ecommerce_forum_thread. All fields are optional filters for searching, sorting, or filtering the thread list. Used by admin dashboards, moderation screens, and category navigation in the product catalog."
    },
    "IPageIAiEcommerceForumThread": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceForumThread"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard page-wrapped result set for listing IAiEcommerceForumThread entities, matching the platform-wide paging container convention. Data array contains each thread's atomic details; pagination duplicates IPage.IPagination used everywhere."
    },
    "IAiEcommerceForumThread": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the forum thread, globally unique. Matches ai_ecommerce_forum_thread.id."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer authoring the thread (FK to ai_ecommerce_customer)."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FKID of related product if the thread is product-specific; null if not."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FKID of related product if the thread is product-specific; null if not."
            }
          ],
          "description": "FKID of related product if the thread is product-specific; null if not."
        },
        "category_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Data: FKID of related category if the thread is category-specific; null if not."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Data: FKID of related category if the thread is category-specific; null if not."
            }
          ],
          "description": "Data: FKID of related category if the thread is category-specific; null if not."
        },
        "title": {
          "type": "string",
          "description": "Thread title, required in schema and for all creation."
        },
        "body": {
          "type": "string",
          "description": "Thread content/body, required, atomic."
        },
        "status": {
          "type": "string",
          "description": "Status of the threadopen, closed, etc. Controlled by backend."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Pinned status for customer support or admin featured display."
        },
        "is_private": {
          "type": "boolean",
          "description": "If true, thread is not shown to public but is visible internally/admin. Required."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when thread was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for the thread."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-deletion timestamp; null if not deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft-deletion timestamp; null if not deleted."
            }
          ],
          "description": "Soft-deletion timestamp; null if not deleted."
        }
      },
      "required": [
        "id",
        "customer_id",
        "title",
        "body",
        "status",
        "is_pinned",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "Forum discussion or Q&A thread, modeled from ai_ecommerce_forum_thread table. Contains all atomic fields (no aggregates or materialized content). All references/foreign keys strictly normalized to underlying schema for full compliance and audit-trail. Timestamps track created/updated/deleted lifecycle status."
    },
    "IAiEcommerceForumThread.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer author. FK to ai_ecommerce_customer."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional product ID if the thread is product-specific."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional product ID if the thread is product-specific."
            }
          ],
          "description": "Optional product ID if the thread is product-specific."
        },
        "category_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional category ID for category/QA thread. Null allowed."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional category ID for category/QA thread. Null allowed."
            }
          ],
          "description": "Optional category ID for category/QA thread. Null allowed."
        },
        "title": {
          "type": "string",
          "description": "Thread title. Required."
        },
        "body": {
          "type": "string",
          "description": "Thread content, required."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Set to true for admin-featured/sticky threads. Optional, defaults false."
        },
        "is_private": {
          "type": "boolean",
          "description": "If true, thread is private-only. Required for explicit thread creation."
        }
      },
      "required": [
        "customer_id",
        "title",
        "body",
        "is_private"
      ],
      "description": "Payload type for creating (POST) a new forum thread. All business-rule and audit-trail fields strictly enforced according to schema. Optional: product_id, category_id, is_pinned flag. Nulls allowed for product/category id."
    },
    "IAiEcommerceForumThread.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "Thread title, updatable."
        },
        "body": {
          "type": "string",
          "description": "Thread content updatable after creation."
        },
        "status": {
          "type": "string",
          "description": "Status updatable (e.g. closed, open, etc.)."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Pinned status updatable (admin/moderator only)."
        },
        "is_private": {
          "type": "boolean",
          "description": "Thread privacy flag; may be updated."
        }
      },
      "required": [],
      "description": "Payload for updating a thread's updatable fields (PUT or PATCH). All fields are optional; only properties to be updated need be provided."
    },
    "ai_ecommerceComment.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Author id, for filtering comments by creator; Foreign Key to ai_ecommerce_customer."
        },
        "forum_thread_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to forum threadfilter for comments tied to specific thread. Optional."
        },
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to inquiry if this is an inquiry comment; optional."
        },
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to review if applicable; for fetching review comments."
        },
        "parent_id": {
          "type": "string",
          "format": "uuid",
          "description": "Parent comment FK for nested queries."
        },
        "body": {
          "type": "string",
          "description": "Full-text search by comment body."
        },
        "depth": {
          "type": "integer",
          "description": "Tree depth, allows searching for root or reply comments."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter comments created after this time."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter comments updated after this time."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter deleted comments for administration/tracing."
        }
      },
      "required": [],
      "description": "Search, filter, and pagination fields as permitted for comment listing, mapped directly to ai_ecommerce_comment fields. All fields are optional for max flexibility."
    },
    "ai_ecommerceComment.IPage": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Page information as per standard IPage.IPagination."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceComment"
          },
          "description": "Comment data rows matching filter/page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response for comments as per business logic. Includes paging metadata and search result rows."
    },
    "ai_ecommerceComment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the comment row, as per ai_ecommerce_comment.id"
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK: comment author, always a customer."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
            }
          ],
          "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK reference to owning forum thread; null if not a thread comment."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK reference to owning forum thread; null if not a thread comment."
            }
          ],
          "description": "FK reference to owning forum thread; null if not a thread comment."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK to inquiry if comment is on inquiry object; null otherwise."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK to inquiry if comment is on inquiry object; null otherwise."
            }
          ],
          "description": "FK to inquiry if comment is on inquiry object; null otherwise."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK: comment to review; null if not attached to review."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK: comment to review; null if not attached to review."
            }
          ],
          "description": "FK: comment to review; null if not attached to review."
        },
        "body": {
          "type": "string",
          "description": "Comment's body/content, plain text."
        },
        "depth": {
          "type": "integer",
          "description": "Tree-depth of this comment, integer representing nesting."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Date/time comment was written."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp (nullable, reflects last edit or present)."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft deletion timestamp; null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft deletion timestamp; null if active."
            }
          ],
          "description": "Soft deletion timestamp; null if active."
        }
      },
      "required": [
        "id",
        "customer_id",
        "body",
        "depth",
        "created_at",
        "updated_at"
      ],
      "description": "Entity for a forum/inquiry/review comment, atomic; follows ai_ecommerce_comment schema for required/optional props, including parent/target/relation FKs, and auditability. All reference fields are normalized/nullable as dictated by ERD and comments schema."
    },
    "ai_ecommerceComment.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for the customer authoring the comment. Must be a valid UUID referencing ai_ecommerce_customer."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
            }
          ],
          "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
            }
          ],
          "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
            }
          ],
          "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related review if this comment is attached to a review, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related review if this comment is attached to a review, else null."
            }
          ],
          "description": "ID of the related review if this comment is attached to a review, else null."
        },
        "body": {
          "type": "string",
          "description": "The main content of the comment. Atomic text, not null, validated for business rules or prohibited content."
        }
      },
      "required": [
        "customer_id",
        "body"
      ],
      "description": "Creation payload for a new comment in the ai_ecommerce_comment table. Fields include author, target context (forum thread, inquiry, review, or parent comment), and main text body. Complies with 3NFonly a single parent, and only one target FK can be non-null for atomicity. Association and context validated by business logic."
    },
    "ai_ecommerceComment.IUpdate": {
      "type": "object",
      "properties": {
        "body": {
          "type": "string",
          "description": "Updated content/body of the comment. Only allowed to be changed by author or admin. Subject to moderation and validation rules."
        }
      },
      "required": [
        "body"
      ],
      "description": "Update payload for modifying an existing comment in ai_ecommerce_comment. Only business-allowed fields can be updated; parent/thread/inquiry/review associations are immutable after creation. Edits are audit-tracked."
    },
    "ai_ecommerceReply.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the seller authoring the reply (nullable if admin-author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the seller authoring the reply (nullable if admin-author)"
            }
          ],
          "description": "ID of the seller authoring the reply (nullable if admin-author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the admin authoring the reply (nullable if seller-author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the admin authoring the reply (nullable if seller-author)"
            }
          ],
          "description": "ID of the admin authoring the reply (nullable if seller-author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The target inquiry being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The target inquiry being replied to (nullable)"
            }
          ],
          "description": "The target inquiry being replied to (nullable)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The target review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The target review being replied to (nullable)"
            }
          ],
          "description": "The target review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The forum thread being replied to (nullable)"
            }
          ],
          "description": "The forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The comment being replied to (if applicable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The comment being replied to (if applicable)"
            }
          ],
          "description": "The comment being replied to (if applicable)"
        },
        "body": {
          "oneOf": [
            {
              "type": "string",
              "description": "Text search or filter on reply content"
            },
            {
              "type": "null",
              "description": "Text search or filter on reply content"
            }
          ],
          "description": "Text search or filter on reply content"
        },
        "created_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for replies created after this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for replies created after this timestamp."
            }
          ],
          "description": "Filter for replies created after this timestamp."
        },
        "created_before": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for replies created before this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for replies created before this timestamp."
            }
          ],
          "description": "Filter for replies created before this timestamp."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination limit (number of records to return)"
            },
            {
              "type": "null",
              "description": "Pagination limit (number of records to return)"
            }
          ],
          "description": "Pagination limit (number of records to return)"
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination offset for fetching reply records"
            },
            {
              "type": "null",
              "description": "Pagination offset for fetching reply records"
            }
          ],
          "description": "Pagination offset for fetching reply records"
        }
      },
      "description": "Search/filter/request object for retrieving a list of reply records. Includes filters for author (seller/admin), target entity info, body text, and date range plus pagination controls.",
      "required": []
    },
    "ai_ecommerceReply.IPage": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceReply"
          },
          "description": "Array of reply objects for current result set."
        },
        "total": {
          "type": "integer",
          "description": "Total number of replies matching the query"
        },
        "limit": {
          "type": "integer",
          "description": "Query limit (results per page)"
        },
        "offset": {
          "type": "integer",
          "description": "Query offset (records skipped)"
        }
      },
      "required": [
        "data",
        "total",
        "limit",
        "offset"
      ],
      "description": "Paginated results set of replies; includes reply data, page size limit, offset, and total result count. Typically returned from reply search/list operations."
    },
    "ai_ecommerceReply": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the reply record, globally unique."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of seller who authored the reply (nullable if admin is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of seller who authored the reply (nullable if admin is author)"
            }
          ],
          "description": "UUID of seller who authored the reply (nullable if admin is author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of admin who authored the reply (nullable if seller is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of admin who authored the reply (nullable if seller is author)"
            }
          ],
          "description": "UUID of admin who authored the reply (nullable if seller is author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the inquiry being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the inquiry being replied to (nullable)"
            }
          ],
          "description": "UUID of the inquiry being replied to (nullable)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being replied to (nullable)"
            }
          ],
          "description": "UUID of the review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being replied to (nullable)"
            }
          ],
          "description": "UUID of the forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            }
          ],
          "description": "UUID of the comment being replied to (nullable)"
        },
        "body": {
          "type": "string",
          "description": "Text content of the reply."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when reply was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when reply was last updated."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp if the reply was soft-deleted; null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp if the reply was soft-deleted; null if active."
            }
          ],
          "description": "Timestamp if the reply was soft-deleted; null if active."
        }
      },
      "required": [
        "id",
        "body",
        "created_at",
        "updated_at"
      ],
      "description": "Main entity schema for a reply record in ai_ecommerce_reply. Contains all atomic fields related to moderation/admin/seller replies to comments, threads, inquiries, or reviews. Each reply references just one target."
    },
    "ai_ecommerceReply.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of seller author if authoring reply (nullable if admin is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of seller author if authoring reply (nullable if admin is author)"
            }
          ],
          "description": "UUID of seller author if authoring reply (nullable if admin is author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of admin author if authoring reply (nullable if seller is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of admin author if authoring reply (nullable if seller is author)"
            }
          ],
          "description": "UUID of admin author if authoring reply (nullable if seller is author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
            }
          ],
          "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of review being replied to (nullable)"
            }
          ],
          "description": "UUID of review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of forum thread being replied to (nullable)"
            }
          ],
          "description": "UUID of forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            }
          ],
          "description": "UUID of the comment being replied to (nullable)"
        },
        "body": {
          "type": "string",
          "description": "Content of the reply."
        }
      },
      "required": [
        "body"
      ],
      "description": "Creation object for a reply entry in ai_ecommerce_reply. Provides reference to author (seller/admin), target entity, and reply body. At least one of seller_id or administrator_id must be non-null; exactly one target FK must be non-null."
    },
    "ai_ecommerceReply.IUpdate": {
      "type": "object",
      "properties": {
        "body": {
          "type": "string",
          "description": "Updated reply body/content. Only allowed to author/moderator/admin as per permission. Content checked for compliance, validation."
        }
      },
      "required": [
        "body"
      ],
      "description": "Update payload for modifying an existing reply in ai_ecommerce_reply. Only mutable field is body texttarget associations are immutable."
    },
    "ai_ecommerceReport.IRequest": {
      "type": "object",
      "properties": {
        "reporter_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the customer who reported (filter)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the customer who reported (filter)"
            }
          ],
          "description": "UUID of the customer who reported (filter)"
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported comment, if this is a comment report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported comment, if this is a comment report"
            }
          ],
          "description": "UUID of the reported comment, if this is a comment report"
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported review, if this is a review report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported review, if this is a review report"
            }
          ],
          "description": "UUID of the reported review, if this is a review report"
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported thread, if this is a thread report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported thread, if this is a thread report"
            }
          ],
          "description": "UUID of the reported thread, if this is a thread report"
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the administrator who resolved this report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the administrator who resolved this report"
            }
          ],
          "description": "UUID of the administrator who resolved this report"
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by report reason"
            },
            {
              "type": "null",
              "description": "Filter by report reason"
            }
          ],
          "description": "Filter by report reason"
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by report workflow/status"
            },
            {
              "type": "null",
              "description": "Filter by report workflow/status"
            }
          ],
          "description": "Filter by report workflow/status"
        },
        "created_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for reports created after this datetime"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for reports created after this datetime"
            }
          ],
          "description": "Filter for reports created after this datetime"
        },
        "created_before": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for reports created before this datetime"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for reports created before this datetime"
            }
          ],
          "description": "Filter for reports created before this datetime"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination limit (number of records to return)"
            },
            {
              "type": "null",
              "description": "Pagination limit (number of records to return)"
            }
          ],
          "description": "Pagination limit (number of records to return)"
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination offset for result set"
            },
            {
              "type": "null",
              "description": "Pagination offset for result set"
            }
          ],
          "description": "Pagination offset for result set"
        }
      },
      "description": "Search/filter object for listing or querying abuse/report records in ai_ecommerce_report. Filtering possible by reporter, target, status, date, or reason, with full-text and pagination fields supported. Used by moderation/admin dashboards.",
      "required": []
    },
    "ai_ecommerceReport.IPage": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceReport"
          },
          "description": "Array of report result objects for current page."
        },
        "total": {
          "type": "integer",
          "description": "Total number of reports matching query."
        },
        "limit": {
          "type": "integer",
          "description": "Limit used in query requests."
        },
        "offset": {
          "type": "integer",
          "description": "Offset used in query requests."
        }
      },
      "required": [
        "data",
        "total",
        "limit",
        "offset"
      ],
      "description": "Paginated object returned by abuse/violation report listing endpoints. Always includes data array, total count, page size, and offset for pagination."
    },
    "ai_ecommerceReport": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-unique identifier for a report row."
        },
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer who filed the report (report actor/subject)."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being reported (if applicable)."
            }
          ],
          "description": "UUID of the comment being reported (if applicable)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being reported (if applicable)."
            }
          ],
          "description": "UUID of the review being reported (if applicable)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if applicable)."
            }
          ],
          "description": "UUID of the forum thread being reported (if applicable)."
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the admin who resolved this report (if resolved)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the admin who resolved this report (if resolved)."
            }
          ],
          "description": "UUID of the admin who resolved this report (if resolved)."
        },
        "reason": {
          "type": "string",
          "description": "Short string that denotes the reason for reporting (e.g., abuse, spam, ToS violation)."
        },
        "status": {
          "type": "string",
          "description": "Workflow/status of the report (e.g., open, resolved, pending)."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended reason comments provided by customer when filing."
            },
            {
              "type": "null",
              "description": "Optional extended reason comments provided by customer when filing."
            }
          ],
          "description": "Optional extended reason comments provided by customer when filing."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the report was submitted."
        },
        "resolved_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "When the report was resolved."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "When the report was resolved."
            }
          ],
          "description": "When the report was resolved."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "When the report was soft-deleted, or null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "When the report was soft-deleted, or null if active."
            }
          ],
          "description": "When the report was soft-deleted, or null if active."
        }
      },
      "required": [
        "id",
        "reporter_id",
        "reason",
        "status",
        "created_at"
      ],
      "description": "Entity schema for an abuse or violation report, in ai_ecommerce_report. Each record references exactly one kind of entity (comment/review/thread), with resolver (admin), reason, status, and time fields. Detailed comments and resolution are tracked for compliance."
    },
    "IAiEcommerceReport.ICreate": {
      "type": "object",
      "properties": {
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer UUID of the abuse reporter."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target comment (if reporting a comment)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target comment (if reporting a comment)."
            }
          ],
          "description": "UUID of the target comment (if reporting a comment)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target review (if reporting a review)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target review (if reporting a review)."
            }
          ],
          "description": "UUID of the target review (if reporting a review)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target forum thread (if reporting a thread)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target forum thread (if reporting a thread)."
            }
          ],
          "description": "UUID of the target forum thread (if reporting a thread)."
        },
        "reason": {
          "type": "string",
          "description": "Short, business-defined abuse/reason code describing why this content is being reported."
        },
        "status": {
          "type": "string",
          "description": "Initial workflow state of the report (e.g., pending, open, triage)."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended description provided by customer at the time of filing."
            },
            {
              "type": "null",
              "description": "Optional extended description provided by customer at the time of filing."
            }
          ],
          "description": "Optional extended description provided by customer at the time of filing."
        }
      },
      "required": [
        "reporter_id",
        "reason",
        "status"
      ],
      "description": "Creation request object for a new abuse/violation report in ai_ecommerce_report. Target associations (comment/review/thread) are exclusive; only one can be non-null per record. The reason and status codes are business-defined enums."
    },
    "IAiEcommerceReport": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-unique identifier for a report, as returned on creation."
        },
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer who filed the report."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being reported (if any)."
            }
          ],
          "description": "UUID of the comment being reported (if any)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being reported (if any)."
            }
          ],
          "description": "UUID of the review being reported (if any)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if any)."
            }
          ],
          "description": "UUID of the forum thread being reported (if any)."
        },
        "reason": {
          "type": "string",
          "description": "Short business-defined string for the violation/abuse reason code."
        },
        "status": {
          "type": "string",
          "description": "Current workflow/status of the report."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended comments provided by user."
            },
            {
              "type": "null",
              "description": "Optional extended comments provided by user."
            }
          ],
          "description": "Optional extended comments provided by user."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation time for the report."
        }
      },
      "required": [
        "id",
        "reporter_id",
        "reason",
        "status",
        "created_at"
      ],
      "description": "Response/result object for a newly created violation or abuse report, as returned by creation endpoints. Fields mirror the main entity but may not include resolved/deleted meta."
    },
    "IAiEcommerceReport.IUpdate": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "description": "  /   .         .\n\n ,          ."
        },
        "status": {
          "type": "string",
          "description": "   . : 'pending', 'reviewed', 'resolved', 'rejected'     ,  enum     .\n\n        ,        /  ."
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "    UUID. /   PK.\n\n  /  , null    ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "    UUID. /   PK.\n\n  /  , null    ."
            }
          ],
          "description": "    UUID. /   PK.\n\n  /  , null    ."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "    /    .\n\n, ,      , 8000~12000   . null ."
            },
            {
              "type": "null",
              "description": "    /    .\n\n, ,      , 8000~12000   . null ."
            }
          ],
          "description": "    /    .\n\n, ,      , 8000~12000   . null ."
        },
        "resolved_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " () . ISO 8601 UTC  .     , NULL  .\n\n : '2025-07-16T06:57:51.232Z'"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " () . ISO 8601 UTC  .     , NULL  .\n\n : '2025-07-16T06:57:51.232Z'"
            }
          ],
          "description": " () . ISO 8601 UTC  .     , NULL  .\n\n : '2025-07-16T06:57:51.232Z'"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "   ( )  /    .\n\nnull   , timestamp  "
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "   ( )  /    .\n\nnull   , timestamp  "
            }
          ],
          "description": "   ( )  /    .\n\nnull   , timestamp  "
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  (comment_id)     PK.\n\n    .  null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  (comment_id)     PK.\n\n    .  null."
            }
          ],
          "description": "  (comment_id)     PK.\n\n    .  null."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " (review_id)     PK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": " (review_id)     PK."
            }
          ],
          "description": " (review_id)     PK."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  (thread_id)     PK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  (thread_id)     PK."
            }
          ],
          "description": "  (thread_id)     PK."
        }
      },
      "description": "ai_ecommerce_report       (PUT/UPDATE) .\n\n(reason), (status),   UUID(resolved_by_id), /, ,       ,      .\n\n null      /  .",
      "required": [
        "status"
      ]
    },
    "IModerationAction.IRequest": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   (actor) UUID.   . null /."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   (actor) UUID.   . null /."
            }
          ],
          "description": "   (actor) UUID.   . null /."
        },
        "action_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "  . : 'delete', 'revert', 'warn', 'block'.   enum  . null ."
            },
            {
              "type": "null",
              "description": "  . : 'delete', 'revert', 'warn', 'block'.   enum  . null ."
            }
          ],
          "description": "  . : 'delete', 'revert', 'warn', 'block'.   enum  . null ."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   (comment) UUID. null   ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   (comment) UUID. null   ."
            }
          ],
          "description": "   (comment) UUID. null   ."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   (review) UUID. null   ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   (review) UUID. null   ."
            }
          ],
          "description": "   (review) UUID. null   ."
        },
        "target_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   /(thread) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   /(thread) UUID."
            }
          ],
          "description": "   /(thread) UUID."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " (from).   . ISO 8601 date-time. null  ."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " (from).   . ISO 8601 date-time. null  ."
            }
          ],
          "description": " (from).   . ISO 8601 date-time. null  ."
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " (to).   . ISO 8601 date-time. null  ."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " (to).   . ISO 8601 date-time. null  ."
            }
          ],
          "description": " (to).   . ISO 8601 date-time. null  ."
        },
        "reversed": {
          "oneOf": [
            {
              "type": "boolean",
              "description": " (/) . True: , False/Null: ."
            },
            {
              "type": "null",
              "description": " (/) . True: , False/Null: ."
            }
          ],
          "description": " (/) . True: , False/Null: ."
        },
        "rationale": {
          "oneOf": [
            {
              "type": "string",
              "description": " ( ,   ) fulltext  ."
            },
            {
              "type": "null",
              "description": " ( ,   ) fulltext  ."
            }
          ],
          "description": " ( ,   ) fulltext  ."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " ( 1, null  1 1)."
            },
            {
              "type": "null",
              "format": "int32",
              "description": " ( 1, null  1 1)."
            }
          ],
          "description": " ( 1, null  1 1)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " ( 30~100)."
            },
            {
              "type": "null",
              "format": "int32",
              "description": " ( 30~100)."
            }
          ],
          "description": " ( 30~100)."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": " (: 'created_at', 'action_type'). null ."
            },
            {
              "type": "null",
              "description": " (: 'created_at', 'action_type'). null ."
            }
          ],
          "description": " (: 'created_at', 'action_type'). null ."
        }
      },
      "description": "ai_ecommerce_moderation_action ( materialized view) /  DTO.\n\n  ,  ,  ,  /, ,    ,       .",
      "required": []
    },
    "IModerationAction": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "ai_ecommerce_moderation_action PK,  ."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  (comment) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  (comment) UUID."
            }
          ],
          "description": "  (comment) UUID."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  (review) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  (review) UUID."
            }
          ],
          "description": "  (review) UUID."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  /(thread) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  /(thread) UUID."
            }
          ],
          "description": "  /(thread) UUID."
        },
        "action_type": {
          "type": "string",
          "description": " .   enum (: delete, revert)"
        },
        "rationale": {
          "type": "string",
          "description": "   ( / )."
        },
        "reversed": {
          "type": "boolean",
          "description": " () . true:  ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " (/)  (UTC ISO8601)"
        },
        "reversed_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  (,  )."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  (,  )."
            }
          ],
          "description": "  (,  )."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "   (null=)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "   (null=)."
            }
          ],
          "description": "   (null=)."
        }
      },
      "required": [
        "id",
        "administrator_id",
        "action_type",
        "rationale",
        "reversed",
        "created_at"
      ],
      "description": "(community moderation)    .\n\n (//)      ,  (rationale), , , ,   ."
    },
    "IModerationAction.ICreate": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "  () UUID.     ."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   PK. ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   PK. ."
            }
          ],
          "description": "   PK. ."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   . ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   . ."
            }
          ],
          "description": "   . ."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  / UUID. ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  / UUID. ."
            }
          ],
          "description": "  / UUID. ."
        },
        "action_type": {
          "type": "string",
          "description": " . : 'delete', 'block', 'warn', 'revert'    enum   ."
        },
        "rationale": {
          "type": "string",
          "description": " -   /  ."
        }
      },
      "description": " ( )   DTO.\n\n (comment/review/thread),  ,  ,    .  1 .",
      "required": [
        "administrator_id",
        "action_type",
        "rationale"
      ]
    },
    "IModerationAction.IUpdate": {
      "type": "object",
      "properties": {
        "rationale": {
          "type": "string",
          "description": " /   ."
        },
        "reversed": {
          "type": "boolean",
          "description": " ()  true   True,    ."
        }
      },
      "description": " ( )  DTO().  ,   .  reversed: true, (rationale) .      .\n\n(Undo, revert)  .",
      "required": []
    },
    "IPageIModerationAction": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IModerationAction"
          },
          "description": "   () ."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "     . , ,    .\n\nIPage  ."
    },
    "IInquirySnapshot.IRequest": {
      "type": "object",
      "properties": {
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  inquiry PK(UUID). null ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  inquiry PK(UUID). null ."
            }
          ],
          "description": "  inquiry PK(UUID). null ."
        },
        "captured_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  (/) PK. null  or ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  (/) PK. null  or ."
            }
          ],
          "description": "  (/) PK. null  or ."
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "  .   enum   ."
            },
            {
              "type": "null",
              "description": "  .   enum   ."
            }
          ],
          "description": "  .   enum   ."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  (from).   ."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  (from).   ."
            }
          ],
          "description": "  (from).   ."
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  (to).   ."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  (to).   ."
            }
          ],
          "description": "  (to).   ."
        },
        "snapshot_reason": {
          "oneOf": [
            {
              "type": "string",
              "description": " (/) ."
            },
            {
              "type": "null",
              "description": " (/) ."
            }
          ],
          "description": " (/) ."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " (1-base)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": " (1-base)"
            }
          ],
          "description": " (1-base)"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " ( 30~100)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": " ( 30~100)"
            }
          ],
          "description": " ( 30~100)"
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": " . null ."
            },
            {
              "type": "null",
              "description": " . null ."
            }
          ],
          "description": " . null ."
        }
      },
      "description": "ai_ecommerce_inquiry_snapshot(  )  /  DTO. inquiry_id, ,    .  .",
      "required": []
    },
    "IPageIInquirySnapshot": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IInquirySnapshot"
          },
          "description": " () "
        }
      },
      "description": "ai_ecommerce_inquiry_snapshot    .  inquiry   .\n\nIPage  .",
      "required": [
        "pagination",
        "data"
      ]
    },
    "IInquirySnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "PK: inquiry    "
        },
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "   inquiry PK(UUID)."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "  ( PK   actor PK)."
        },
        "title": {
          "type": "string",
          "description": "  inquiry "
        },
        "body": {
          "type": "string",
          "description": "  inquiry /"
        },
        "status": {
          "type": "string",
          "description": "  inquiry (enum: open, closed )"
        },
        "snapshot_reason": {
          "type": "string",
          "description": "  , : 'edit', 'status change', 'rollback'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " () (UTC ISO8601)"
        }
      },
      "required": [
        "id",
        "inquiry_id",
        "captured_by_id",
        "title",
        "body",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "(inquiry) ()    .\n\n inquiry ,      .  inquiry PK,  , snapshot     ."
    },
    "IInquirySnapshot.ICreate": {
      "type": "object",
      "properties": {
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "    inquiry UUID(PK)"
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "  Triger actor/custome PK"
        },
        "title": {
          "type": "string",
          "description": "  title"
        },
        "body": {
          "type": "string",
          "description": "  body"
        },
        "status": {
          "type": "string",
          "description": "  workflow (enum)"
        },
        "snapshot_reason": {
          "type": "string",
          "description": "  "
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " (UTC ISO8601)"
        }
      },
      "required": [
        "inquiry_id",
        "captured_by_id",
        "title",
        "body",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "inquiry()     DTO. PK  inquiry_id, ,  title/body/status//  "
    },
    "IInquirySnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "snapshot_reason": {
          "type": "string",
          "description": "     /  ."
        }
      },
      "description": "  snapshot_reason(  ,   )   DTO.",
      "required": []
    },
    "Iai_ecommerceReviewSnapshot.IRequest": {
      "type": "object",
      "properties": {
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  review  PK(UUID). null    ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  review  PK(UUID). null    ."
            }
          ],
          "description": "  review  PK(UUID). null    ."
        },
        "captured_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  PK. null ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  PK. null ."
            }
          ],
          "description": "  PK. null ."
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "  (: 'active', 'archived', 'deleted' )"
            },
            {
              "type": "null",
              "description": "  (: 'active', 'archived', 'deleted' )"
            }
          ],
          "description": "  (: 'active', 'archived', 'deleted' )"
        },
        "rating": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "   (0~5 ), null ."
            },
            {
              "type": "null",
              "format": "int32",
              "description": "   (0~5 ), null ."
            }
          ],
          "description": "   (0~5 ), null ."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  (from) "
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  (from) "
            }
          ],
          "description": "  (from) "
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  (to) "
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  (to) "
            }
          ],
          "description": "  (to) "
        },
        "snapshot_reason": {
          "oneOf": [
            {
              "type": "string",
              "description": " /  "
            },
            {
              "type": "null",
              "description": " /  "
            }
          ],
          "description": " /  "
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " (1-base)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": " (1-base)"
            }
          ],
          "description": " (1-base)"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": " (  30~100)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": " (  30~100)"
            }
          ],
          "description": " (  30~100)"
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": " /"
            },
            {
              "type": "null",
              "description": " /"
            }
          ],
          "description": " /"
        }
      },
      "description": "ai_ecommerce_review_snapshot  /  DTO.  , , , ,     ,  .",
      "required": []
    },
    "IPageIai_ecommerceReviewSnapshot": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination information for the result set. Refer to standard IPage pagination contract.\n\nThis object contains the current page, limit, record count, and page count per IPage documentation."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/Iai_ecommerceReviewSnapshot"
          },
          "description": "Array of ai_ecommerce_review_snapshot records for the current page of results.\n\nEach item represents a historical, append-only snapshot of a review from the audit/history table."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated list container for AI E-Commerce review snapshots (ai_ecommerce_review_snapshot).\n\nEach response represents a page of historical, immutable records for review state changes, suitable for rollback, audit, or compliance reporting. See Iai_ecommerceReviewSnapshot for individual item schema."
    },
    "Iai_ecommerceReviewSnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for this review snapshot record.\n\nReferences the ai_ecommerce_review_snapshot table's primary key."
        },
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "The id of the associated review entity being snapshotted.\n\nForeign key to ai_ecommerce_review."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "Who triggered the snapshot (customer's user id or system actor).\n\nReferences ai_ecommerce_customer."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "The review title at the time of snapshot, or null if review at that point had no title."
            },
            {
              "type": "null",
              "description": "The review title at the time of snapshot, or null if review at that point had no title."
            }
          ],
          "description": "The review title at the time of snapshot, or null if review at that point had no title."
        },
        "body": {
          "type": "string",
          "description": "The full text body of the review at the historical snapshot point.\n\nReferencing ai_ecommerce_review_snapshot.body."
        },
        "rating": {
          "type": "integer",
          "description": "Historical rating value of the review (integer score at snapshot)."
        },
        "status": {
          "type": "string",
          "description": "State of the review at snapshot, e.g., 'active', 'deleted', or other values set at that point in history.\n\nField comes from ai_ecommerce_review_snapshot.status."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Text explanation why this snapshot was taken. E.g. 'edit', 'moderation', 'rollback'.\n\nReferencing ai_ecommerce_review_snapshot.snapshot_reason."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of when the snapshot was created (ISO 8601, UTC)."
        }
      },
      "required": [
        "id",
        "review_id",
        "captured_by_id",
        "body",
        "rating",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "Immutable historical snapshot of a review entity for audit, rollback, and compliance in AI E-commerce.\n\nCaptures all mutable review state at a given time (title/body/rating/status) and attaches an actor/reason/timestamp for traceability."
    },
    "Iai_ecommerceReviewSnapshot.ICreate": {
      "type": "object",
      "properties": {
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "Review entity this snapshot captures (FK to ai_ecommerce_review)."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the user who triggered this snapshot, or system actor (FK to ai_ecommerce_customer)."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Review title at this point (nullable for title-absent reviews)."
            },
            {
              "type": "null",
              "description": "Review title at this point (nullable for title-absent reviews)."
            }
          ],
          "description": "Review title at this point (nullable for title-absent reviews)."
        },
        "body": {
          "type": "string",
          "description": "Body text for the review at this snapshot."
        },
        "rating": {
          "type": "integer",
          "description": "Integer review rating at time of snapshot."
        },
        "status": {
          "type": "string",
          "description": "Review workflow/state at this snapshot point (e.g., 'active', 'deleted')."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Explanation for why the snapshot is taken ('edit', 'moderation', etc)."
        }
      },
      "required": [
        "review_id",
        "captured_by_id",
        "body",
        "rating",
        "status",
        "snapshot_reason"
      ],
      "description": "Request body for creating a new review snapshot in ai_ecommerce_review_snapshot.\n\nFields mirror main entity but with nullable titlesee schema for role in audit/rollback."
    },
    "Iai_ecommerceReviewSnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
            },
            {
              "type": "null",
              "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
            }
          ],
          "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
        },
        "body": {
          "type": "string",
          "description": "Updates the snapshot body text, replaces previous content."
        },
        "rating": {
          "type": "integer",
          "description": "Historical review rating at this update."
        },
        "status": {
          "type": "string",
          "description": "Workflow status at snapshot after update."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Reason code for updating the snapshot record."
        }
      },
      "required": [],
      "description": "Update object for review snapshot entity.\n\nRarely used except for compliance or audit correction. Only mutable fields may be supplied. Immutable fields (ids, actor, created_at) cannot be changed."
    },
    "IPageIai_ecommerceCart": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata: page, limit, total records, etc. See IPage standard doc for detail."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/Iai_ecommerceCart"
          },
          "description": "Array of cart records for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated page result for shopping carts.\n\nEach response represents a slice of current cart records and pagination info."
    },
    "Iai_ecommerceCart": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Cart unique identifier. Always required (PK of ai_ecommerce_cart)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to ai_ecommerce_customer who owns this cart."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
            },
            {
              "type": "null",
              "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
            }
          ],
          "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
        },
        "cart_status": {
          "type": "string",
          "description": "Logical cart state: 'active', 'merged', 'expired', etc. Must align with business logic and API usage."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO 8601, UTC) when cart was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the cart was last updated."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
            }
          ],
          "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
        }
      },
      "required": [
        "id",
        "customer_id",
        "cart_status",
        "created_at",
        "updated_at"
      ],
      "description": "Top-level cart entity for AI E-commerce shopping mall; represents a shoppable container session per customer/device, not including its content/items.\n\nThis record is used for device sync, recovered sessions, and is referenced in order creation."
    },
    "Iai_ecommerceCart.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to ai_ecommerce_customer; must be active/valid for cart creation."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "Device/session context or identifier (nullable)."
            },
            {
              "type": "null",
              "description": "Device/session context or identifier (nullable)."
            }
          ],
          "description": "Device/session context or identifier (nullable)."
        },
        "cart_status": {
          "type": "string",
          "description": "Initial state of the new cart ('active', etc.)."
        }
      },
      "required": [
        "customer_id",
        "cart_status"
      ],
      "description": "Cart creation request payload for initializing new shopping cart entity."
    },
    "Iai_ecommerceCart.IUpdate": {
      "type": "object",
      "properties": {
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "If supplied, new device/session descriptor (null resets context)."
            },
            {
              "type": "null",
              "description": "If supplied, new device/session descriptor (null resets context)."
            }
          ],
          "description": "If supplied, new device/session descriptor (null resets context)."
        },
        "cart_status": {
          "type": "string",
          "description": "Change cart state (e.g., 'merged', 'expired', 'active')."
        }
      },
      "required": [],
      "description": "Update body for shopping cart mutations. Only mutable fields permitted."
    },
    "Iai_ecommerceCartItem.IRequest": {
      "type": "object",
      "properties": {
        "cart_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter: limit to a particular cart (FK). Null disables filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter: limit to a particular cart (FK). Null disables filter."
            }
          ],
          "description": "Filter: limit to a particular cart (FK). Null disables filter."
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter: only items matching this SKU (FK to sku)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter: only items matching this SKU (FK to sku)."
            }
          ],
          "description": "Filter: only items matching this SKU (FK to sku)."
        },
        "added_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
            }
          ],
          "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
        }
      },
      "required": [],
      "description": "Search/filter parameters for retrieving cart items from ai_ecommerce_cart_item. All fields are optional."
    },
    "IPageIai_ecommerceCartItem": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination, page, record count, etc."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceCartItem"
          },
          "description": "Array of cart item records for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated page of cart items (ai_ecommerce_cart_item entities)."
    },
    "IAiEcommerceCartItem": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Cart item unique id (PK)."
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "Parent cart FK."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Referencing specific SKU product."
        },
        "quantity": {
          "type": "integer",
          "description": "How many of the SKU in the cart item; must be 1 or more."
        },
        "added_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp item added to cart (ISO 8601, UTC)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last time this item's state was updated."
        }
      },
      "required": [
        "id",
        "cart_id",
        "sku_id",
        "quantity",
        "added_at",
        "updated_at"
      ],
      "description": "Atomic cart item row: one product (SKU) and quantity held in a particular cart, for session/purchase purposes. See ai_ecommerce_cart_item table for relationships."
    },
    "Iai_ecommerceCart.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": " .\n\nai_ecommerce_cart  cart   UUID .          ."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "/ .\n\n         . :  ,  UUID .      ."
            },
            {
              "type": "null",
              "description": "/ .\n\n         . :  ,  UUID .      ."
            }
          ],
          "description": "/ .\n\n         . :  ,  UUID .      ."
        },
        "cart_status": {
          "oneOf": [
            {
              "type": "string",
              "description": "  .\n\n: 'active', 'merged', 'expired' . ai_ecommerce_cart   cart_status       .          ."
            },
            {
              "type": "null",
              "description": "  .\n\n: 'active', 'merged', 'expired' . ai_ecommerce_cart   cart_status       .          ."
            }
          ],
          "description": "  .\n\n: 'active', 'merged', 'expired' . ai_ecommerce_cart   cart_status       .          ."
        },
        "created_at_range": {
          "type": "object",
          "properties": {
            "from": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "  (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "  (ISO8601)"
                }
              ],
              "description": "  (ISO8601)"
            },
            "to": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "  (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "  (ISO8601)"
                }
              ],
              "description": "  (ISO8601)"
            }
          },
          "required": [],
          "description": "     \n\nfrom  , to  ISO 8601 ."
        },
        "updated_at_range": {
          "type": "object",
          "properties": {
            "from": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "   (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "   (ISO8601)"
                }
              ],
              "description": "   (ISO8601)"
            },
            "to": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "   (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "   (ISO8601)"
                }
              ],
              "description": "   (ISO8601)"
            }
          },
          "required": [],
          "description": "     \n\n     from~to  ISO 8601  ."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "boolean",
              "description": " .\n\n     . true deleted_at null  , false null , null  ."
            },
            {
              "type": "null",
              "description": " .\n\n     . true deleted_at null  , false null , null  ."
            }
          ],
          "description": " .\n\n     . true deleted_at null  , false null , null  ."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IRequest"
        },
        "sort": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "field": {
                "type": "string",
                "description": "  (: created_at, updated_at )"
              },
              "direction": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "  (asc|desc)"
                  },
                  {
                    "const": "desc",
                    "description": "  (asc|desc)"
                  }
                ],
                "description": "  (asc|desc)"
              }
            },
            "required": [
              "field",
              "direction"
            ]
          },
          "description": "  . [{field, direction}]        . : created_at desc, updated_at asc ."
        }
      },
      "required": [],
      "description": "ai_ecommerce_cart    , , ,    \n\n/  ,   , / , (meta) ,         .\n\n 'id', 'customer_id', 'device_context', 'cart_status', 'created_at', 'updated_at', 'deleted_at'       .\n\ndeleted_at      , pagination/sort     ."
    },
    "IAiEcommerceCartItem.ICreate": {
      "type": "object",
      "description": "  ai_ecommerce_cart_item       .\n\n      SKU(  )  SKU      .         . /      .\n\n ,  SKU           .    cart_id, sku_id, quantity  , ID( )  .",
      "properties": {
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "() PK(UUID).     id. ai_ecommerce_cart.id ."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "SKU( ) PK(UUID).  /   . ai_ecommerce_sku.id ."
        },
        "quantity": {
          "type": "integer",
          "description": " (0 ).\n 1   /      .",
          "minimum": 1
        }
      },
      "required": [
        "cart_id",
        "sku_id",
        "quantity"
      ]
    },
    "IAiEcommerceCartItem.IUpdate": {
      "type": "object",
      "description": "ai_ecommerce_cart_item     .\n\n quantity()  ,       . sku_id  (     ). updated_at  API     .",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "   . 1  , /   ."
        }
      },
      "required": [
        "quantity"
      ]
    },
    "IDeleteResult": {
      "type": "object",
      "description": "(  )      .\n\nid(  PK), deleted( ), deleted_at( )  ,   (, )     .",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "(  )  entity PK(UUID)."
        },
        "deleted": {
          "type": "boolean",
          "description": " (True),  (False),  ( ) ."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "    /  (ISO8601).       null."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "    /  (ISO8601).       null."
            }
          ],
          "description": "    /  (ISO8601).       null."
        }
      },
      "required": [
        "id",
        "deleted"
      ]
    },
    "IAiEcommerceOrder.IRequest": {
      "type": "object",
      "description": "(order)  ,       . ai_ecommerce_order        .\n\n     API   /    .    , ID, /, /    .",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  () PK.    . null   / ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  () PK.    . null   / ."
            }
          ],
          "description": "  () PK.    . null   / ."
        },
        "order_status": {
          "oneOf": [
            {
              "type": "string",
              "description": "  . : pending, paid, shipped, delivered, cancelled . null   ."
            },
            {
              "type": "null",
              "description": "  . : pending, paid, shipped, delivered, cancelled . null   ."
            }
          ],
          "description": "  . : pending, paid, shipped, delivered, cancelled . null   ."
        },
        "placed_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " (==   ) ISO 8601."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " (==   ) ISO 8601."
            }
          ],
          "description": " (==   ) ISO 8601."
        },
        "placed_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " (==   ) ISO 8601."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " (==   ) ISO 8601."
            }
          ],
          "description": " (==   ) ISO 8601."
        },
        "cart_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " (cart)     ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": " (cart)     ."
            }
          ],
          "description": " (cart)     ."
        },
        "shipping_address_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "    ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "    ."
            }
          ],
          "description": "    ."
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "(,  ) . null ."
            },
            {
              "type": "null",
              "description": "(,  ) . null ."
            }
          ],
          "description": "(,  ) . null ."
        },
        "limit": {
          "type": "integer",
          "description": "    (  ), : 20"
        },
        "offset": {
          "type": "integer",
          "description": "  (  ), : 0"
        },
        "sort_key": {
          "oneOf": [
            {
              "type": "string",
              "description": "  key(placed_at, order_status )"
            },
            {
              "type": "null",
              "description": "  key(placed_at, order_status )"
            }
          ],
          "description": "  key(placed_at, order_status )"
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": " : asc(), desc()    null."
            },
            {
              "const": "desc",
              "description": " : asc(), desc()    null."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": " : asc(), desc()    null."
            }
          ],
          "description": " : asc(), desc()    null."
        }
      },
      "required": [
        "limit",
        "offset"
      ]
    },
    "IPageIAiEcommerceOrder": {
      "type": "object",
      "description": "ai_ecommerce_order     .   +    .\n\n records( ), pagination, total_count     .",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrder"
          },
          "description": "  "
        },
        "pagination": {
          "type": "object",
          "description": " ( ,  ,   )",
          "properties": {
            "current": {
              "type": "integer",
              "description": "  "
            },
            "limit": {
              "type": "integer",
              "description": "    "
            },
            "records": {
              "type": "integer",
              "description": "  "
            },
            "pages": {
              "type": "integer",
              "description": "  (ceil(records/limit))"
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        },
        "total_count": {
          "type": "integer",
          "description": "   ( )"
        }
      },
      "required": [
        "records",
        "pagination",
        "total_count"
      ]
    },
    "IAiEcommerceOrder": {
      "type": "object",
      "description": "ai_ecommerce_order    .    (, , , , ,  ) .\n\n   ai_ecommerce_order   JSON   , ,  .",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "(, UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  PK(ai_ecommerce_customer.id)."
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "   (PK, ai_ecommerce_cart.id)"
        },
        "shipping_address_id": {
          "type": "string",
          "format": "uuid",
          "description": "  PK(ai_ecommerce_user_address.id)"
        },
        "order_status": {
          "type": "string",
          "description": " . : pending, paid, shipped, delivered, cancelled."
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": " (,  ). null ."
            },
            {
              "type": "null",
              "description": " (,  ). null ."
            }
          ],
          "description": " (,  ). null ."
        },
        "placed_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (/ , ISO8601)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "/    ."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": " (null=)"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": " (null=)"
            }
          ],
          "description": " (null=)"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem"
          },
          "description": "   (, SKU )"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " ( ),  DB/   nullable"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": " ( ),  DB/   nullable"
            }
          ],
          "description": " ( ),  DB/   nullable"
        },
        "shipment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " ( ),  DB/   nullable"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": " ( ),  DB/   nullable"
            }
          ],
          "description": " ( ),  DB/   nullable"
        }
      },
      "required": [
        "id",
        "customer_id",
        "cart_id",
        "shipping_address_id",
        "order_status",
        "placed_at",
        "updated_at",
        "items"
      ]
    },
    "IAiEcommerceOrder.ICreate": {
      "type": "object",
      "description": "ai_ecommerce_order      .\n\n : ///,   .    PK   .   (ai_ecommerce_cart, ... ) FK         ,   .",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": " PK"
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "   PK"
        },
        "shipping_address_id": {
          "type": "string",
          "format": "uuid",
          "description": "  PK"
        },
        "order_status": {
          "type": "string",
          "description": "  . : pending(), paid() "
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": " (: app, web, ...)."
            },
            {
              "type": "null",
              "description": " (: app, web, ...)."
            }
          ],
          "description": " (: app, web, ...)."
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem.ICreate"
          },
          "description": "  SKU   ."
        }
      },
      "required": [
        "customer_id",
        "cart_id",
        "shipping_address_id",
        "order_status",
        "items"
      ]
    },
    "IAiEcommerceOrder.IUpdate": {
      "type": "object",
      "description": "ai_ecommerce_order       .    (order_status), ,  .  (id, customer, cart)  . /     .",
      "properties": {
        "order_status": {
          "type": "string",
          "description": "  (: pending, paid, shipped, delivered, cancelled)"
        },
        "shipping_address_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   "
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   "
            }
          ],
          "description": "   "
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "  "
            },
            {
              "type": "null",
              "description": "  "
            }
          ],
          "description": "  "
        }
      },
      "required": [
        "order_status"
      ]
    },
    "IAiEcommerceOrderItem.IRequest": {
      "type": "object",
      "description": " ()  /  .  order_id, sku_id   .\n\nlimit/offset      order_id, sku_id,      .",
      "properties": {
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   PK"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   PK"
            }
          ],
          "description": "   PK"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  SKU(PK)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  SKU(PK)"
            }
          ],
          "description": "  SKU(PK)"
        },
        "from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "   (, ISO8601 datetime)"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "   (, ISO8601 datetime)"
            }
          ],
          "description": "   (, ISO8601 datetime)"
        },
        "to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "   ()"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "   ()"
            }
          ],
          "description": "   ()"
        },
        "limit": {
          "type": "integer",
          "description": "   "
        },
        "offset": {
          "type": "integer",
          "description": "  "
        }
      },
      "required": [
        "limit",
        "offset"
      ]
    },
    "IPageIAiEcommerceOrderItem": {
      "type": "object",
      "description": " () /   .  , , ,    .",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem"
          },
          "description": "  "
        },
        "pagination": {
          "type": "object",
          "description": "  ( ,   )",
          "properties": {
            "current": {
              "type": "integer"
            },
            "limit": {
              "type": "integer"
            },
            "records": {
              "type": "integer"
            },
            "pages": {
              "type": "integer"
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        },
        "total_count": {
          "type": "integer",
          "description": "    "
        }
      },
      "required": [
        "records",
        "pagination",
        "total_count"
      ]
    },
    "IAiEcommerceOrderItem": {
      "type": "object",
      "description": "ai_ecommerce_order_item DB   (  SKU   ).\n\n PK, SKU PK, ,  , /   .  //    .",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": " PK/UUID( )"
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "    PK(uuid)"
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "  SKU() PK(uuid)"
        },
        "quantity": {
          "type": "integer",
          "description": " (1 )"
        },
        "ordered_at": {
          "type": "string",
          "format": "date-time",
          "description": "    (placing) ISO8601"
        }
      },
      "required": [
        "id",
        "order_id",
        "sku_id",
        "quantity",
        "ordered_at"
      ]
    },
    "IAiEcommerceOrderItem.ICreate": {
      "type": "object",
      "description": "  (SKU  )   .\n\nSKU PK    .   SKU        . order_id ai_ecommerce_order     ( order )",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": " SKU PK(uuid)"
        },
        "quantity": {
          "type": "integer",
          "description": "/ (1 )",
          "minimum": 1
        }
      },
      "required": [
        "sku_id",
        "quantity"
      ]
    },
    "IAiEcommerceOrderItem.IUpdate": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "SKU ID   .   SKU  SKU   , ai_ecommerce_order_item sku_id.   SKU  ,   /    .       ,   .\n\nai_ecommerce_order_item Prisma  'sku_id' .   SKU     ."
        },
        "quantity": {
          "type": "integer",
          "description": "      . ai_ecommerce_order_item quantity  ,      / /   . 0  ,         .\n\nPrisma DB quantity    ."
        }
      },
      "required": [
        "sku_id"
      ],
      "description": " (ai_ecommerce_order_item) ()  .   SKU       , ai_ecommerce_order_item   .\n\nSKU ,     ,   Prisma DB    .        ."
    },
    "IAiEcommerceOrderItem.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  (ai_ecommerce_order_item) PK(ID) .      ,       . Prisma  id  ."
        },
        "deleted": {
          "type": "boolean",
          "description": "   . true  ( )  ,   /     .   /   /   ."
        },
        "message": {
          "type": "string",
          "description": "()        . / ,   ,           .         . Prisma       ."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": " (ai_ecommerce_order_item)     .     (/)    .\n\nid, ,     .  DB  , API/      ."
    },
    "IAiEcommercePayment.IRequest": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": " (status)  . : 'pending', 'completed', 'cancelled' .      . Prisma status       .\n\n     ."
        },
        "provider": {
          "type": "string",
          "description": " (provider)  . 'stripe', 'paypal', ''        . Prisma provider   .\n\n, //    ."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "  (order) UUID.       . ai_ecommerce_payment  FK   ,  API order_id     ."
        },
        "page": {
          "type": "integer",
          "description": "     (Field: page).          . : 1."
        },
        "limit": {
          "type": "integer",
          "description": "       (Field: limit).    ,      . : 20~100(  )."
        }
      },
      "required": [],
      "description": "  //    . ai_ecommerce_payment  status, provider    , (), ,        .\n\n  ,          ."
    },
    "IPageIAiEcommercePayment": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "description": "   .     , IAiEcommercePayment   .",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePayment"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "   . IPage   ,  (pagination)   (data;    IAiEcommercePayment ) .\n\nPrisma DB page   ,  /API  ."
    },
    "IAiEcommercePayment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  (ai_ecommerce_payment) PK(ID).    ,   .   FK . Prisma id  ."
        },
        "amount": {
          "type": "number",
          "description": "( / )    .    .      ,        .\n\nPrisma amount(DoublePrecision)   ."
        },
        "provider": {
          "type": "string",
          "description": "   . 'stripe', 'paypal', '', ''   /   .\n\nPrisma provider      ,    ."
        },
        "method": {
          "type": "string",
          "description": " . 'card', 'bank_transfer', 'virtual_account', ''       .        .\n\nPrisma method  ."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": " PG()   (reference). PG   KEY ,   /  . Prisma payment_reference  nullable  ."
            },
            {
              "type": "null",
              "description": " PG()   (reference). PG   KEY ,   /  . Prisma payment_reference  nullable  ."
            }
          ],
          "description": " PG()   (reference). PG   KEY ,   /  . Prisma payment_reference  nullable  ."
        },
        "status": {
          "type": "string",
          "description": " . 'pending', 'completed', 'failed', 'cancelled'    / . Prisma status   , //  ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "     ISO8601(YYYY-MM-DDTHH:mm:SSZ) . ai_ecommerce_payment created_at DaTimestamptz  .  ,     , , UI  ."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "    .  //   . ai_ecommerce_payment updated_at DaTimestamptz  ."
        }
      },
      "required": [
        "id",
        "amount",
        "provider",
        "method",
        "status",
        "created_at",
        "updated_at"
      ],
      "description": "     (ai_ecommerce_payment  ). , , ,  , /     .\n\nPrisma  ai_ecommerce_payment   ,   ,  ,    ."
    },
    "IAiEcommercePayment.ICreate": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "number",
          "description": "  .       . DoublePrecision ,     (/ )  .\n\nPrisma amount(DoublePrecision)   ."
        },
        "provider": {
          "type": "string",
          "description": " /   . 'stripe', 'paypal', ''    ,        .\n\n , Prisma provider   ."
        },
        "method": {
          "type": "string",
          "description": " . 'card', 'bank_transfer', 'virtual_account', ''    .  /  .\n\nPrisma method    ."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": "()   PG /, 3      key .    null . ai_ecommerce_payment payment_reference(nullable)   ."
            },
            {
              "type": "null",
              "description": "()   PG /, 3      key .    null . ai_ecommerce_payment payment_reference(nullable)   ."
            }
          ],
          "description": "()   PG /, 3      key .    null . ai_ecommerce_payment payment_reference(nullable)   ."
        },
        "status": {
          "type": "string",
          "description": "    .  'pending', 'requested'    .       ,  Prisma DB status     .       ."
        }
      },
      "required": [
        "amount",
        "provider",
        "method",
        "status"
      ],
      "description": "     .  , , ,  ,     null,    .\n\nPrisma schema(ai_ecommerce_payment)       ."
    },
    "IAiEcommercePayment.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": " (status)      .   (->/, ) . Prisma status     , : 'completed', 'cancelled', 'refunded' ."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": "()  (: PG /)    .    PG   key   . Prisma payment_reference(nullable)   ."
            },
            {
              "type": "null",
              "description": "()  (: PG /)    .    PG   key   . Prisma payment_reference(nullable)   ."
            }
          ],
          "description": "()  (: PG /)    .    PG   key   . Prisma payment_reference(nullable)   ."
        }
      },
      "required": [
        "status"
      ],
      "description": " ( )    . status()  //     , payment_reference /      .\n\nPrisma ai_ecommerce_payment     ."
    },
    "IAiEcommercePayment.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "(  ) (ID) PK.      ,  ,   . Prisma id  ."
        },
        "deleted": {
          "type": "boolean",
          "description": "   . true   ( ) .\n\n    (,  )    ."
        },
        "message": {
          "type": "string",
          "description": "     .      ,        /    .    , API    ."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": "    API   .  ID, ,    . ai_ecommerce_payment  /   .\n\nid(), deleted( /), message(/)  ."
    },
    "IAiEcommerceOrderStatusLog.IRequest": {
      "type": "object",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "   (order)  ID. ai_ecommerce_order_status_log order_id FK  .   ."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "  (// ) UUID. ai_ecommerce_order_status_log actor_id  ."
        },
        "actor_type": {
          "type": "string",
          "description": "   . 'customer', 'seller', 'administrator'     . Prisma order_status_log actor_type . (enum )."
        },
        "old_status": {
          "type": "string",
          "description": " (order_status_log old_status)    ."
        },
        "new_status": {
          "type": "string",
          "description": " (order_status_log new_status)    ."
        },
        "from": {
          "type": "string",
          "format": "date-time",
          "description": "    (), ISO 8601 . ai_ecommerce_order_status_log changed_at  ."
        },
        "to": {
          "type": "string",
          "format": "date-time",
          "description": "    (), ISO 8601 . ai_ecommerce_order_status_log changed_at ."
        },
        "page": {
          "type": "integer",
          "description": "    . API  : 1."
        },
        "limit": {
          "type": "integer",
          "description": "       .         ."
        }
      },
      "required": [],
      "description": "   (ai_ecommerce_order_status_log) /  .  ID,   ,   /       .\n\nPrisma     ,   ."
    },
    "IPageIAiEcommerceOrderStatusLog": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderStatusLog"
          },
          "description": "       .   ai_ecommerce_order_status_log   IOrderStatusLog  ."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "   (ai_ecommerce_order_status_log) /  . pagination( ) data(  ) .  IPage  .\n\nPrisma DB         ."
    },
    "IAiEcommerceOrderStatusLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  (ai_ecommerce_order_status_log) PK(ID).    ,       row  ."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "   (order) FK. ai_ecommerce_order_status_log order_id (ID).     ."
        },
        "old_status": {
          "type": "string",
          "description": "  . : 'pending' . ai_ecommerce_order_status_log old_status  ."
        },
        "new_status": {
          "type": "string",
          "description": "   . : 'paid', 'shipped', 'cancelled' . ai_ecommerce_order_status_log new_status  ."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "  (//) UUID. ai_ecommerce_order_status_log actor_id  .       ."
        },
        "actor_type": {
          "type": "string",
          "description": " . 'customer', 'seller', 'administrator'  . Prisma order_status_log actor_type (enum)."
        },
        "changed_at": {
          "type": "string",
          "format": "date-time",
          "description": "     ISO8601  . ai_ecommerce_order_status_log changed_at(Timestamptz)  .     , /  ."
        }
      },
      "required": [
        "id",
        "order_id",
        "old_status",
        "new_status",
        "actor_id",
        "actor_type",
        "changed_at"
      ],
      "description": "   (ai_ecommerce_order_status_log)   . ,  (),  ,       .\n\nPrisma  /  , //    ."
    },
    "IAiEcommerceOrderStatusLog.ICreate": {
      "type": "object",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "   (order)  PK(FK). ai_ecommerce_order_status_log order_id .    . ."
        },
        "old_status": {
          "type": "string",
          "description": "   (order)  . ai_ecommerce_order_status_log old_status .  ,    . ."
        },
        "new_status": {
          "type": "string",
          "description": "     . ai_ecommerce_order_status_log new_status . ."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "  (//) UUID. ai_ecommerce_order_status_log actor_id . //  . ."
        },
        "actor_type": {
          "type": "string",
          "description": "  ('customer', 'seller', 'administrator  ). ai_ecommerce_order_status_log actor_type (enum). ."
        },
        "changed_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (ISO8601). ai_ecommerce_order_status_log changed_at.      . ."
        }
      },
      "required": [
        "order_id",
        "old_status",
        "new_status",
        "actor_id",
        "actor_type",
        "changed_at"
      ],
      "description": "  (ai_ecommerce_order_status_log)   . ,  (/),  ,     .\n\nPrisma          .   , /   ."
    },
    "IAiEcommerceOrderStatusLog.IUpdate": {
      "type": "object",
      "description": "This schema defines the structure for updating an order status log entry in the ai_ecommerce_order_status_log table. \n\nTypically used by administrators or privileged fulfillment logic when correcting or annotating order status transitions for compliance, audit, or business process reasons. All fields are atomic and strictly controlled, and only specific fields are allowed to change in typical 3NF design. Most fields, including actor, order linkage, and created_at, are immutable after log creation.\n\nBusiness rule: Only mutable fields permitted by policy (typically correction reason, possibly new status, or special admin-correction notes) should be present here. Attempted patching of immutable fields is forbidden at API/business level.",
      "properties": {
        "new_status": {
          "type": "string",
          "description": "The new order status applied for audit correction or compliance update. Example values might include 'paid', 'shipped', 'delivered', or custom business states. Must adhere to the allowed order status enum or list in the system logic."
        },
        "correction_reason": {
          "type": "string",
          "description": "Free-text or pre-canned explanation for updating/amending this status log, for audit trail clarity. Required for compliance or legal reasons. E.g., 'manual override', 'system correction', 'fraud reversal', etc."
        }
      },
      "required": [
        "new_status"
      ]
    },
    "IAiEcommerceOrderStatusLog.IDeleteResult": {
      "type": "object",
      "description": "Result/confirmation object returned after attempting to delete (or soft-delete) an order status log entry in ai_ecommerce_order_status_log.\n\nUsed by admin, compliance, or automated reconciliation processes to know the outcome of the API attempt. Typical fields include: confirmation boolean or message, the affected log id, and possibly additional status/report fields (such as whether the deletion was soft or hard, timestamp, audit id, etc).",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier (UUID) of the order status log entry that was deleted."
        },
        "success": {
          "type": "boolean",
          "description": "Whether the deletion (soft/hard) was successful."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp at which the deletion occurred. If soft-delete policy, it reflects the deleted_at column value. If hard delete, may be identical to actual DB operation time."
        },
        "message": {
          "type": "string",
          "description": "Additional message or confirmation text regarding the delete operation. Usually human-readable, may specify reason or report compliance rules applied."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "ai_ecommerce_shipment.IRequest": {
      "type": "object",
      "description": "Schema for querying/searching ai_ecommerce_shipment records (fulfillment/shipping units) in a paginated/filterable way.\n\nUsed by warehouse ops, admin dashboards, seller fulfillment, or support tools for querying shipments by status, carrier, shipment date, tracking number, etc. Fields are all atomic and may be combined for compound queries.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order id for which this shipment was created. Results can be filtered for a specific order."
        },
        "shipping_status": {
          "type": "string",
          "description": "Filters results by shipping status: allowed values are business-specific, e.g., 'pending', 'shipped', 'delivered', 'returned', etc."
        },
        "carrier": {
          "type": "string",
          "description": "Restricts search to a specific carrier (e.g., 'KoreaPost', 'CJ Logistics')."
        },
        "tracking_number": {
          "type": "string",
          "description": "Filter for a specific carrier-provided shipment tracking code."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start datetime for shipment record creation (inclusive). Useful for date window searches."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "End datetime for shipment record creation (inclusive)."
        },
        "limit": {
          "type": "integer",
          "description": "How many records to return per page. Default according to platform standard, e.g., 50."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into full result set for paging."
        }
      },
      "required": []
    },
    "ai_ecommerce_shipment.IPage": {
      "type": "object",
      "description": "Paged result container for shipment search/listing queries. Contains result array, pagination info, and optionally, count metadata.",
      "properties": {
        "data": {
          "type": "array",
          "description": "Array of shipment (ai_ecommerce_shipment) result items for this page.",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_shipment"
          }
        },
        "total": {
          "type": "integer",
          "description": "Total number of shipment records matching query (across all pages)."
        },
        "limit": {
          "type": "integer",
          "description": "Count per page used in this response."
        },
        "offset": {
          "type": "integer",
          "description": "Paging offset used to fetch these results."
        }
      },
      "required": [
        "data",
        "total"
      ]
    },
    "ai_ecommerce_shipment": {
      "type": "object",
      "description": "Atomic structure for ai_ecommerce_shipment (fulfillment unit of an order). Represents a single outbound shipment record (tracking, status, carrier) tied to an order. Strict 3NF: no aggregates, all fields required by shipment auditance and business process.\n\nPrimary use cases are order fulfillment, delivery tracking, platform analytics, or support tools.\n\nAlways associated 1:1 with an order. May be referenced by tracking dashboards or logistics partners.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key of the shipment record (immutable UUID for compliance referencing)."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "The order this shipment fulfills (FK to ai_ecommerce_order)."
        },
        "carrier": {
          "type": "string",
          "description": "Name of the delivery carrier/vendor. Nullable if unassigned at creation."
        },
        "tracking_number": {
          "type": "string",
          "description": "Carrier's tracking number for shipment. Nullable if not yet assigned/registered."
        },
        "shipping_status": {
          "type": "string",
          "description": "Current status of shipment: e.g., 'pending', 'shipped', 'delivered', 'returned', etc."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when package was shipped out (nullable until shipped)."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when shipment confirmed delivered (nullable until delivered)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Time the shipment record was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for shipping record/state."
        }
      },
      "required": [
        "id",
        "order_id",
        "shipping_status",
        "created_at",
        "updated_at"
      ]
    },
    "ai_ecommerce_shipment.ICreate": {
      "type": "object",
      "description": "Request body schema for creating a new ai_ecommerce_shipment record. Used by logistics systems, admin/order management back office to register an outbound shipment linked to an order. All required properties ensure 3NF normalization and compliance traceability.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to the order being shipped."
        },
        "carrier": {
          "type": "string",
          "description": "Name of carrier/delivery vendor (nullable on creation, but recommended)."
        },
        "tracking_number": {
          "type": "string",
          "description": "Parcel tracking number with carrier (nullable on creation)."
        },
        "shipping_status": {
          "type": "string",
          "description": "Initial shipment status: typically 'pending', 'shipped', etc."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime shipment was shipped (nullable, usually present if status >= 'shipped')."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime shipment was delivered (nullable, only upon delivery confirmation)."
        }
      },
      "required": [
        "order_id",
        "shipping_status"
      ]
    },
    "ai_ecommerce_shipment.IUpdate": {
      "type": "object",
      "description": "Request/patch schema for updating ai_ecommerce_shipment record fields by id. Supports updating mutable shipment fields (status, carrier, tracking info, timestamps). Subject to permissions, audit, and business validation.",
      "properties": {
        "carrier": {
          "type": "string",
          "description": "Delivery carrier/vendor to update (nullable, optional)."
        },
        "tracking_number": {
          "type": "string",
          "description": "Carrier-provided shipment tracking code (nullable, optional)."
        },
        "shipping_status": {
          "type": "string",
          "description": "Status to update: e.g., 'pending', 'shipped', 'delivered', etc. Required when updating status/timestamps."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the package was shipped (set if updating to >= 'shipped')."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the package was delivered (set if marking as delivered)."
        }
      },
      "required": [
        "shipping_status"
      ]
    },
    "ai_ecommerce_shipment.IDeleteResult": {
      "type": "object",
      "description": "Confirmation/result object after deleting a shipment. Indicates outcome and effective timestamp (if soft-deleted). Used by admin, fulfillment, or compliance APIs to track successful deletion.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Shipment id of the removed record."
        },
        "success": {
          "type": "boolean",
          "description": "True if deletion (soft/hard) was successful."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Deletion timestamp if soft-delete is in effect. May be null for hard deletes or immediate removals."
        },
        "message": {
          "type": "string",
          "description": "Human-readable confirmation or reason for outcome."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "ai_ecommerce_return_request.IRequest": {
      "type": "object",
      "description": "Flexible search/list/filter schema for querying ai_ecommerce_return_request (return/cancellation requests). Filters include status, type, customer/order linkage, reason, and date ranges.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order to which the return/cancel is attached."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Requesting customer id for querying only their requests."
        },
        "status": {
          "type": "string",
          "description": "Return/cancel request status: e.g., 'pending', 'processing', 'completed', 'denied', etc."
        },
        "request_type": {
          "type": "string",
          "description": "Kind of return: e.g., 'return', 'cancellation', etc."
        },
        "reason": {
          "type": "string",
          "description": "Reason code/detail for return/cancellation."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Earliest datetime (inclusive) for request creation."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "Latest datetime (inclusive) for request creation."
        },
        "limit": {
          "type": "integer",
          "description": "How many records per page (pagination)."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into result set (pagination)."
        }
      },
      "required": []
    },
    "ai_ecommerce_return_request.IPage": {
      "type": "object",
      "description": "Paged result container for return/cancellation requests. Includes array of result, count, and pagination window info.",
      "properties": {
        "data": {
          "type": "array",
          "description": "Array of return/cancel request objects (ai_ecommerce_return_request) for this page.",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_return_request"
          }
        },
        "total": {
          "type": "integer",
          "description": "Total number of matching return/cancel requests, across all pages."
        },
        "limit": {
          "type": "integer",
          "description": "Count per page for this result set."
        },
        "offset": {
          "type": "integer",
          "description": "Offset used for this page."
        }
      },
      "required": [
        "data",
        "total"
      ]
    },
    "ai_ecommerce_return_request": {
      "type": "object",
      "description": "Core entity schema for ai_ecommerce_return_request (return/cancellation workflow). Records all key properties and strict 3NF compliance for auditability, support, and analytics. Fields are atomic; no aggregates or computed totals per DB design.\n\nEach return/cancellation must have an order, customer, type, status, reason (nullable), and status date fields for audit trail. System uses these records for compliance reporting, return/cancel UX, and analytics.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique per-return/cancellation request. Primary key for referencing this event in downstream workflows."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order subject to return/cancellation."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer submitting this request."
        },
        "status": {
          "type": "string",
          "description": "Workflow status for return/cancel: e.g., 'pending', 'completed', 'processing', etc."
        },
        "request_type": {
          "type": "string",
          "description": "Request variant: 'return', 'cancellation', or business-defined label."
        },
        "reason": {
          "type": "string",
          "description": "Customer or business-provided explanation for return/cancel. May be null."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Request creation timestamp."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for this request."
        }
      },
      "required": [
        "id",
        "order_id",
        "customer_id",
        "status",
        "request_type",
        "created_at",
        "updated_at"
      ]
    },
    "ai_ecommerce_return_request.ICreate": {
      "type": "object",
      "description": "Creation schema for new return/cancel request in ai_ecommerce_return_request. Used by end user, admin, or platform logic to initiate a new return/cancel/correction/exception. Strict 3NF: atomic fields only, audit and compliance friendly.\n\nRequired fields: order, customer, type, status. Reason is optional for some business flows.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order for which return/cancellation is being requested."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The customer submitting this request."
        },
        "status": {
          "type": "string",
          "description": "Initial statustypically 'pending' at request creation."
        },
        "request_type": {
          "type": "string",
          "description": "Type of requeste.g., 'return', 'cancellation', etc."
        },
        "reason": {
          "type": "string",
          "description": "Reason for requestoptional/nullable."
        }
      },
      "required": [
        "order_id",
        "customer_id",
        "status",
        "request_type"
      ]
    },
    "ai_ecommerce_return_request.IUpdate": {
      "type": "object",
      "description": "Representation of data required to update an existing return or cancellation request within the next-generation, AI-ready shopping mall backend system.\n\nThis type corresponds to fields in the ai_ecommerce_return_request Prisma model. Updates modify request fields such as status, request_type, or reason. Only mutable, business-logic-compliant fields are included; immutable fields such as id, customer_id, and order_id must not be changed. The update operation enforces that only the fields permitted by business rules (e.g., status change, correction of reason) are allowed to update, supporting customer, admin, and support workflows.",
      "properties": {
        "status": {
          "type": "string",
          "description": "The new status for the return or cancellation request. Used to advance the request lifecycle (e.g., pending, approved, denied, completed). Must adhere to allowed business states and transition logic.\n\nDirectly maps to the status column in the ai_ecommerce_return_request Prisma schema."
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
            },
            {
              "type": "null",
              "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
            }
          ],
          "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
        }
      },
      "required": [
        "status"
      ]
    },
    "ai_ecommerce_return_request.IDeleteResult": {
      "type": "object",
      "description": "Result or confirmation object returned after deleting (soft-delete or full delete) a return/cancellation request entry in the ai_ecommerce_return_request table. Used to indicate whether the delete operation succeeded, and if so, provide the resulting (soft-deleted) object or status description.\n\nUseful for clients to check that a delete operation was applied and the new logical state of the record.",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Indicates if the delete/soft-delete operation was successful. True if the request is now deleted, false otherwise."
        },
        "deletedAt": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
            }
          ],
          "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
        },
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted return/cancellation request."
        }
      },
      "required": [
        "success",
        "id"
      ]
    },
    "ai_ecommerce_coupon.IRequest": {
      "type": "object",
      "description": "Request/query type for searching, filtering, or paginating ai_ecommerce_coupon records (platform or seller-issued coupons) in the shopping mall backend.\n\nThis supports Dashboards, Wallets, and Administrative coupon management, following business rules in the Prisma schema. Used with PATCH endpoints to allow strongly-typed, structured queries, such as filtering by status, code, date ranges, customer_id, seller_id, active state, expiration date, and discount_rule_id.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
            }
          ],
          "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
            }
          ],
          "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
        },
        "discount_rule_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
            }
          ],
          "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
        },
        "code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
            },
            {
              "type": "null",
              "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
            }
          ],
          "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
        },
        "is_active": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
            },
            {
              "type": "null",
              "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
            }
          ],
          "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
        },
        "expired": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
            },
            {
              "type": "null",
              "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
            }
          ],
          "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Maximum number of records to return for this request (pagination). If null, use default/system max.",
              "minimum": 1
            },
            {
              "type": "null",
              "description": "Maximum number of records to return for this request (pagination). If null, use default/system max.",
              "minimum": 1
            }
          ],
          "description": "Maximum number of records to return for this request (pagination). If null, use default/system max."
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Number of records to skip before selecting results (pagination). If null, treats as zero.",
              "minimum": 0
            },
            {
              "type": "null",
              "description": "Number of records to skip before selecting results (pagination). If null, treats as zero.",
              "minimum": 0
            }
          ],
          "description": "Number of records to skip before selecting results (pagination). If null, treats as zero."
        }
      },
      "required": []
    },
    "ai_ecommerce_coupon.IPage": {
      "type": "object",
      "description": "Paginated result set for queries/searches of ai_ecommerce_coupon entities. Contains both data and pagination metadata for client consumption.\n\nThis object is returned by endpoints that retrieve filtered, paged collections of coupons for admin dashboards, customer wallets, and seller promo tools.\n\nCombines a data array of coupon objects together with metadata about current page, page size, total count, and page count.",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_coupon"
          },
          "description": "Array of coupon records returned for the current page; each item conforms to the ai_ecommerce_coupon schema."
        },
        "pagination": {
          "type": "object",
          "description": "Metadata describing the current page and pagination state, following platform-standard IPage.IPagination (for offset/limit, total records, pages, etc.).",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number (1-based)."
            },
            "limit": {
              "type": "integer",
              "description": "Records per page on this result."
            },
            "records": {
              "type": "integer",
              "description": "Total number of records matching the current filter"
            },
            "pages": {
              "type": "integer",
              "description": "Total number of result pages."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        }
      },
      "required": [
        "data",
        "pagination"
      ]
    },
    "ai_ecommerce_coupon": {
      "type": "object",
      "description": "Normalized coupon entity for the next-generation e-commerce backend, representing a single platform- or seller-issued coupon available for redemption by customers. Fields correspond 1:1 with the ai_ecommerce_coupon Prisma model, used for discount systems, coupon redemption, wallet display, and admin promo tools.\n\nHolds unique, atomic coupon property values including owner, issuer, rule linkage, code, usage/expiration constraints, status, and compliance metadata.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID uniquely identifying the coupon."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
            }
          ],
          "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
            }
          ],
          "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
        },
        "discount_rule_id": {
          "type": "string",
          "format": "uuid",
          "description": "Discount rule this coupon references; required for application/eligibility logic."
        },
        "code": {
          "type": "string",
          "description": "Coupon code string; unique per owner/scope where required (e.g., SAVE10)."
        },
        "issued_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp coupon was issued."
        },
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
            }
          ],
          "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
        },
        "is_active": {
          "type": "boolean",
          "description": "Whether coupon is currently available for redemption/application."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Max total redemptions permitted for this coupon, across all users."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "Maximum number of redemptions permitted for single customer."
        }
      },
      "required": [
        "id",
        "discount_rule_id",
        "code",
        "issued_at",
        "is_active",
        "usage_limit",
        "usage_per_customer_limit"
      ]
    },
    "IAiEcommerceCoupon.ICreate": {
      "type": "object",
      "description": "Payload for creating a new coupon entity matching the ai_ecommerce_coupon schema in the backend system. Used by admin/seller promo tools and system integrations to insert a new redemption code into the platform coupon registry.\n\nFollows the validations and constraints described in the DB schema (e.g., uniqueness, required fields, correct associations with customer/seller/rule).",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
            }
          ],
          "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Issuing seller for seller-specific coupons; null for platform-issued."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Issuing seller for seller-specific coupons; null for platform-issued."
            }
          ],
          "description": "Issuing seller for seller-specific coupons; null for platform-issued."
        },
        "discount_rule_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to discount_rule applied by this coupon (required)."
        },
        "code": {
          "type": "string",
          "description": "Unique coupon code string for redemption (required, unique per business rule)."
        },
        "issued_at": {
          "type": "string",
          "format": "date-time",
          "description": "Coupon issuance timestamp (required)."
        },
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Expiration timestamp; null if no expiry."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Expiration timestamp; null if no expiry."
            }
          ],
          "description": "Expiration timestamp; null if no expiry."
        },
        "is_active": {
          "type": "boolean",
          "description": "Whether coupon is initially enabled when created."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Total redemption limit for the coupon."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "How many times a single customer may use the coupon."
        }
      },
      "required": [
        "discount_rule_id",
        "code",
        "issued_at",
        "is_active",
        "usage_limit",
        "usage_per_customer_limit"
      ]
    },
    "IAiEcommerceCoupon": {
      "$ref": "#/components/schemas/ai_ecommerce_coupon",
      "description": "Alias for the ai_ecommerce_coupon entity type; follows the same structure, used for response typing and unifying request/response objects in the OpenAPI component schema."
    },
    "IAiEcommerceCoupon.IUpdate": {
      "type": "object",
      "description": "Object for updating an existing coupon entry (ai_ecommerce_coupon table). Includes only fields allowed to update per business logic (cannot change immutable id, code, or owner after creation). Used to modify expiration, usage limits, status, or deactivate coupon.\n\nFields populated must be business-rule-allowed mutable fields.",
      "properties": {
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "New expiration timestamp for the coupon; null for no expiry."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "New expiration timestamp for the coupon; null for no expiry."
            }
          ],
          "description": "New expiration timestamp for the coupon; null for no expiry."
        },
        "is_active": {
          "type": "boolean",
          "description": "Override active state of the coupon."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Update max permitted total redemptions."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "Update max permitted per-customer redemptions."
        }
      },
      "required": []
    },
    "IDeleteConfirmation": {
      "type": "object",
      "description": "Generic confirmation type indicating logical/physical delete status for a resource within the system. Used to confirm successful completion of delete endpoints.\n\nPrimary use cases include resource APIs that must show completion of a delete action (coupon, order, loyalty point, return request, etc.) and return a status/optional effective field.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier of the deleted entity."
        },
        "success": {
          "type": "boolean",
          "description": "True if deletion was performed successfully."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
            }
          ],
          "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "IAiEcommerceLoyaltyPoint.IListRequest": {
      "type": "object",
      "description": "Request object for listing, filtering, or searching loyalty point events for customer accounts as per ai_ecommerce_loyalty_point. Supports admin dashboards, account history review, and loyalty program management.\n\nAllows paginated, filtered fetching of loyalty point records by customer, order, loyalty tier, date range, and reason.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
            }
          ],
          "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Order associated with loyalty point event. Filters by order if provided."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Order associated with loyalty point event. Filters by order if provided."
            }
          ],
          "description": "Order associated with loyalty point event. Filters by order if provided."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
            }
          ],
          "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
            },
            {
              "type": "null",
              "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
            }
          ],
          "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
        },
        "from_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for only events created after this timestamp (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for only events created after this timestamp (inclusive)."
            }
          ],
          "description": "Filter for only events created after this timestamp (inclusive)."
        },
        "to_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for only events created before this timestamp (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for only events created before this timestamp (inclusive)."
            }
          ],
          "description": "Filter for only events created before this timestamp (inclusive)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "minimum": 1,
              "description": "Maximum number of records to retrieve (pagination). Null for default value."
            },
            {
              "type": "null",
              "minimum": 1,
              "description": "Maximum number of records to retrieve (pagination). Null for default value."
            }
          ],
          "description": "Maximum number of records to retrieve (pagination). Null for default value."
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "minimum": 0,
              "description": "Number of records to skip (pagination). Null for zero/automatic."
            },
            {
              "type": "null",
              "minimum": 0,
              "description": "Number of records to skip (pagination). Null for zero/automatic."
            }
          ],
          "description": "Number of records to skip (pagination). Null for zero/automatic."
        }
      },
      "required": []
    },
    "IPageIAiEcommerceLoyaltyPoint": {
      "type": "object",
      "description": "Paginated result set for API queries of ai_ecommerce_loyalty_point records. This structure is used in endpoints returning a list of loyalty point transactions for a given filter/set of customers or orders. Includes the loyalty point event data and standard pagination metadata.",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceLoyaltyPoint"
          },
          "description": "Loyalty point event array corresponding to pagination window."
        },
        "pagination": {
          "type": "object",
          "description": "Pagination meta, using standard fields: current page, limit, total records, pages.",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number of results."
            },
            "limit": {
              "type": "integer",
              "description": "Number of rows per page."
            },
            "records": {
              "type": "integer",
              "description": "Total record count for the current filter query."
            },
            "pages": {
              "type": "integer",
              "description": "Page count for the query window."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        }
      },
      "required": [
        "data",
        "pagination"
      ]
    },
    "IAiEcommerceLoyaltyPoint": {
      "type": "object",
      "description": "Atomic loyalty point record as defined by the ai_ecommerce_loyalty_point Prisma model. Used to track reward, redemption, accrual, and audit for loyalty programs. Immutable except for business/compliance correction flows.\n\nIncludes references to customer, order, loyalty tier, change amount (int), reason (string), and created_at timestamp. This structure is used in all loyalty point API read and write contexts.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique ID for this loyalty point transaction."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to customer who earned/spent this loyalty point entry."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
            }
          ],
          "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: tier for this event; traceable for reporting/history."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: tier for this event; traceable for reporting/history."
            }
          ],
          "description": "Optional: tier for this event; traceable for reporting/history."
        },
        "change_amount": {
          "type": "integer",
          "description": "Signed integer showing points added (positive) or subtracted (negative) for this transaction."
        },
        "reason": {
          "type": "string",
          "description": "String reason code (e.g., 'purchase', 'cancel', 'manual_adjust')."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp the event occurred."
        }
      },
      "required": [
        "id",
        "customer_id",
        "change_amount",
        "reason",
        "created_at"
      ]
    },
    "IAiEcommerceLoyaltyPoint.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier (UUID) for the customer to whom this loyalty point event applies. References ai_ecommerce_customer in the database. Required for the transaction."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
            }
          ],
          "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
            }
          ],
          "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
        },
        "change_amount": {
          "type": "integer",
          "description": "The integer change in points this event represents. Positive for accrual, negative for redemption. Strictly atomicno aggregate or running balance. Required."
        },
        "reason": {
          "type": "string",
          "description": "Short string describing why the points are credited or debited (e.g., 'purchase', 'adjustment'). Must be provided for audit and trace."
        }
      },
      "required": [
        "customer_id",
        "change_amount",
        "reason"
      ],
      "description": "Input object for creating a new loyalty point event. Implements ai_ecommerce_loyalty_point event creation for accrual, redemption, or correction as per 08_ai_ecommerce_discount_loyalty_payment.md. The event is always atomic, with all references to customer, optional order, optional tier, and the integer point change."
    },
    "IAiEcommerceLoyaltyPoint.IUpdate": {
      "type": "object",
      "properties": {
        "change_amount": {
          "type": "integer",
          "description": "New value for the integer point change. Only permitted for corrections; must match business logic for allowed range."
        },
        "reason": {
          "type": "string",
          "description": "Updated or new reason for the point transaction. Used for correction or audit annotation."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
            }
          ],
          "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
        }
      },
      "required": [
        "change_amount"
      ],
      "description": "Object for updating a loyalty point event. Only permitted for corrections/adjustments. Fields updatable are: change_amount, reason, loyalty_tier_id. Business logic may limit which fields may be updated after finalization."
    },
    "IAiEcommerceLoyaltyTier.IListRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Filter by loyalty tier name. Optional."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Filter for minimum points required to achieve the tier. Optional."
        },
        "sort_order": {
          "type": "integer",
          "description": "Filter by display or business sort order. Optional."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination; defaults to 1. Optional."
        },
        "limit": {
          "type": "integer",
          "description": "Page size for pagination; defaults to a reasonable limit (e.g., 100). Optional."
        }
      },
      "required": [],
      "description": "Paginated and filterable request for listing loyalty tiers. Supports flexible search on name, min_points_required, and sort_order."
    },
    "IPageIAiEcommerceLoyaltyTier": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata (current page, limit, total records, total pages)."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceLoyaltyTier"
          },
          "description": "Array of loyalty tier records matching the request query."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response structure for loyalty tier listing. Contains meta and actual result set of loyalty tiers."
    },
    "IAiEcommerceLoyaltyTier": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier (UUID) for the loyalty tier. Primary key."
        },
        "name": {
          "type": "string",
          "description": "Display/business name for the loyalty tier (e.g., 'Silver', 'Gold', 'Diamond')."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Minimum point balance required to achieve or maintain this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Earning or redemption rate multiplier for this tier (e.g., 1.0 for basic, >1.0 for premium)."
        },
        "sort_order": {
          "type": "integer",
          "description": "Display or business sort order; enables ordered tier listings."
        }
      },
      "required": [
        "id",
        "name",
        "min_points_required",
        "multiplier",
        "sort_order"
      ],
      "description": "Schema representing a single loyalty tier definition, normalized as per 08_ai_ecommerce_discount_loyalty_payment.md. Used for point assignment/qualification and user reward context."
    },
    "IAiEcommerceLoyaltyTier.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name for the new loyalty tier; must be unique across all tiers (case-insensitive)."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Integer points required for users to reach this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Multiplier rate for point accrual or redemption. Must be positive and reflect business rules."
        },
        "sort_order": {
          "type": "integer",
          "description": "Sort order integer for tier display; lower value = higher priority on sorted lists."
        }
      },
      "required": [
        "name",
        "min_points_required",
        "multiplier",
        "sort_order"
      ],
      "description": "Schema for creating a new loyalty tier in the platform, as described in 08_ai_ecommerce_discount_loyalty_payment.md. All fields are atomic and required for tier onboarding."
    },
    "IAiEcommerceLoyaltyTier.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Updated name for the loyalty tier."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Updated minimum points required for this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Updated earning/redemption multiplier for the tier."
        },
        "sort_order": {
          "type": "integer",
          "description": "Updated sort order integer; affects business and UI positioning."
        }
      },
      "required": [],
      "description": "Object for updating the definition of a loyalty tier. Only mutable tier attributes are updatable; updates are fully audit-traced."
    },
    "ai_ecommerce_wallet.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter wallets by customer UUID. Optional."
        },
        "currency_code": {
          "type": "string",
          "description": "Filter for wallets by ISO currency code (e.g., 'KRW', 'USD'). Optional."
        },
        "is_active": {
          "type": "boolean",
          "description": "Filter by active status of the wallet."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination. Optional."
        },
        "limit": {
          "type": "integer",
          "description": "Page size for pagination. Optional."
        }
      },
      "required": [],
      "description": "Request object for searching/paginating ai_ecommerce_wallets. Supports filters on customer, currency, and status."
    },
    "IPageai_ecommerce_wallet": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_wallet"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result structure for wallet search/list in ai_ecommerce_wallet."
    },
    "ai_ecommerce_wallet": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique UUID for the wallet. Primary key."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer UUID; owner of the wallet."
        },
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 currency code ('KRW', 'USD', etc)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp the wallet was created. ISO 8601 format."
        },
        "is_active": {
          "type": "boolean",
          "description": "Wallet active status (true = usable, false = inactive/frozen)."
        }
      },
      "required": [
        "id",
        "customer_id",
        "currency_code",
        "created_at",
        "is_active"
      ],
      "description": "Entity for customer wallet as per ai_ecommerce_wallet table in DiscountLoyaltyPayment domain. Represents a wallet unit for platform credits, multi-currency handled by unique key."
    },
    "ai_ecommerce_wallet.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the customer to whom this wallet belongs."
        },
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 currency code for the wallet (e.g., 'KRW', 'USD')."
        },
        "is_active": {
          "type": "boolean",
          "description": "Wallet status (active/inactive). Optional; may be set to true by default."
        }
      },
      "required": [
        "customer_id",
        "currency_code"
      ],
      "description": "Object for creating a new ai_ecommerce_wallet record. Includes customer association and currency code. is_active is optional at creation."
    },
    "ai_ecommerce_wallet.IUpdate": {
      "type": "object",
      "properties": {
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 code for wallet currency; changing currency is rare, may be disabled by business logic."
        },
        "is_active": {
          "type": "boolean",
          "description": "Updated status of the wallet (active/inactive)."
        }
      },
      "required": [],
      "description": "Schema for updating wallet status/details. Field changes are audit-logged for compliance; status and currency_code may be updated per business logic."
    },
    "ai_ecommerce_wallet_transaction.IRequest": {
      "type": "object",
      "properties": {
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "    UUID.    ,     .\n\nPrisma schema column  : 'wallet_wallet_transaction ai_ecommerce_wallet @relation(fields: [wallet_id], references: [id], onDelete: Cascade)'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID.    ,     .\n\nPrisma schema column  : 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID.    ,     .\n\nPrisma schema column  : 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
            }
          ],
          "description": "  UUID.    ,     .\n\nPrisma schema column  : 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "    UUID.  ,    .\n\nPrisma schema column  : 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "    UUID.  ,    .\n\nPrisma schema column  : 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
            }
          ],
          "description": "    UUID.  ,    .\n\nPrisma schema column  : 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
        },
        "transaction_type": {
          "type": "string",
          "description": " (: 'deposit', 'payment', 'refund' ).     , , ,  .  enum   .\n\nPrisma schema column  : 'type - e.g., deposit, payment, refund, etc.'"
        },
        "date_range": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "format": "date-time",
              "description": " /(ISO 8601).     ."
            },
            "to": {
              "type": "string",
              "format": "date-time",
              "description": " /(ISO 8601).     ."
            }
          },
          "description": "     (/).     .",
          "required": []
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": " (1-based).   ."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 500,
          "description": "    .      ( )."
        }
      },
      "description": "     .\n\n  ai_ecommerce_wallet_transaction( ) , ,  . Prisma     ,    .\n\n  , ,     .",
      "required": [
        "wallet_id"
      ]
    },
    "IPageai_ecommerce_wallet_transaction": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_wallet_transaction"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "         .\n\nPrisma DB       ."
    },
    "ai_ecommerce_wallet_transaction": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "     (UUID). , ,      .\n\nPrisma schema column  : 'id String @id @db.Uuid'"
        },
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID.    .\n\nPrisma schema column  : 'wallet_id String @db.Uuid'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID. ,      .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID. ,      .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID. ,      .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID.     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID.     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID.     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": " (+, -) . (positive), /(negative  positive)  .\n\nPrisma schema column  : 'change_amount Float @db.DoublePrecision'"
        },
        "currency_code": {
          "type": "string",
          "description": "ISO 4217  (: 'KRW', 'USD').    .\n\nPrisma schema column  : 'currency_code String'"
        },
        "transaction_type": {
          "type": "string",
          "description": " (: 'deposit', 'payment', 'refund' ).  /  .\n\nPrisma schema column  : 'type String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " () (UTC, ISO 8601).      .\n\nPrisma schema column  : 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "id",
        "wallet_id",
        "change_amount",
        "currency_code",
        "transaction_type",
        "created_at"
      ],
      "description": "    .\n\n  Prisma   ,      .   DB         ."
    },
    "ai_ecommerce_wallet_transaction.ICreate": {
      "type": "object",
      "properties": {
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "    UUID().    .\n\nPrisma schema column  : 'wallet_id String @db.Uuid'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID().  ,     .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID().  ,     .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID().  ,     .\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID(). , ,     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID(). , ,     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID(). , ,     .\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": " (+, -).  //       ,   .\n\nPrisma schema column  : 'change_amount Float @db.DoublePrecision'"
        },
        "currency_code": {
          "type": "string",
          "description": "ISO 4217  (: 'KRW', 'USD').  /   .\n\nPrisma schema column  : 'currency_code String'"
        },
        "transaction_type": {
          "type": "string",
          "description": " (: 'deposit', 'payment', 'refund' ,   enum ).   .\n\nPrisma schema column  : 'type String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (UTC  ISO 8601).      .\n\nPrisma schema column  : 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "wallet_id",
        "change_amount",
        "currency_code",
        "transaction_type",
        "created_at"
      ],
      "description": "     .\n\n   Prisma DB      (   ) ."
    },
    "ai_ecommerce_wallet_transaction.IUpdate": {
      "type": "object",
      "properties": {
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID(  null  ).\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID(  null  ).\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID(  null  ).\n\nPrisma schema column  : 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  UUID(  null  ).\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  UUID(  null  ).\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "  UUID(  null  ).\n\nPrisma schema column  : 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": "  (+, -). , /      .\n\nPrisma schema column  : 'change_amount Float @db.DoublePrecision'"
        },
        "transaction_type": {
          "type": "string",
          "description": "  .  enum    (  ).\n\nPrisma schema column  : 'type String'"
        },
        "currency_code": {
          "type": "string",
          "description": " ISO  . : 'KRW', 'USD'.\n\nPrisma schema column  : 'currency_code String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "      ().  /IDTT .\n\nPrisma schema column  : 'created_at DateTime @db.Timestamptz'"
        }
      },
      "description": "    (  ).   Prisma DB       .",
      "required": []
    },
    "ai_ecommerce_payment_integration.IRequest": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "  (: 'Stripe', 'KCP', 'KakaoPay').   /."
        },
        "is_active": {
          "type": "boolean",
          "description": "  ( /  )."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": " (1-based)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "description": "    ."
        }
      },
      "description": " (provider) /  .   ai_ecommerce_payment_integration    /  .",
      "required": []
    },
    "IPageai_ecommerce_payment_integration": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePaymentIntegration"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "         .\n\n/ API    Prisma DB    ."
    },
    "IAiEcommercePaymentIntegration": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "  (UUID).       .\n\nPrisma schema column  : 'id String @id @db.Uuid'"
        },
        "provider_name": {
          "type": "string",
          "description": "  . (: 'Stripe', 'KCP', 'KakaoPay')       .\n\nPrisma schema column  : 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": " /   JSON (  ). API Key    .   /  .\n\nPrisma schema column  : 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "  . true /  \n\nPrisma schema column  : 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "/  (UTC, ISO 8601).  , ,  .\n\nPrisma schema column  : 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "id",
        "provider_name",
        "configuration_json",
        "is_active",
        "created_at"
      ],
      "description": "  (   )  .\n\n  Prisma     /   ."
    },
    "IAiEcommercePaymentIntegration.ICreate": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "  (, : 'Stripe', 'KCP', 'KakaoPay').\n\nPrisma schema column  : 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": "  (JSON,  API / ).      .\n\nPrisma schema column  : 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "     .  true(  ).\n\nPrisma schema column  : 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " (UTC ISO 8601).       .\n\nPrisma schema column  : 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "provider_name",
        "configuration_json",
        "is_active",
        "created_at"
      ],
      "description": "    ()  . AI- DB     API     ,      ."
    },
    "IAiEcommercePaymentIntegration.IUpdate": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "  ( ).\n\nPrisma schema column  : 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": "   (JSON)        .\n\nPrisma schema column  : 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "/  .\n\nPrisma schema column  : 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "(     ,     )."
        }
      },
      "description": " ()       .",
      "required": []
    },
    "IAiEcommerceDiscountRule.IRequest": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "  (: 'fixed_amount', 'percentage', 'stacking' .   ).\n\nPrisma schema column  : 'rule_type String'"
        },
        "description": {
          "type": "string",
          "description": "   / ."
        },
        "created_date_range": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "format": "date-time"
            },
            "to": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": " ()  -  .",
          "required": []
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "1   results ."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "description": "   /  ."
        }
      },
      "description": " (//  )  , ,   . AI- DB   /    .",
      "required": []
    },
    "IAiEcommercePageIAiEcommerceDiscountRule": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceDiscountRule"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "         .        ."
    },
    "IAiEcommerceDiscountRule": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "   .\n\n , ,       UUID .  primary key,  .   PostgreSQL UUID  , / ,    ."
        },
        "rule_type": {
          "type": "string",
          "description": "//    .\n\n: 'fixed_amount', 'percentage', 'stacking'.    . , , ,       type   ,  /DB    ."
        },
        "description": {
          "type": "string",
          "description": "     .\n\n, , UI   ,      . , ,      ."
        },
        "predicate_json": {
          "type": "string",
          "description": "     JSON   .\n\nex)  , , ,       , //    JSON .\n\n: {\"min_purchase\": 10000, \"applicable_category\": [\"Electronics\"]}"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "    .\n\nISO8601 format datetime  , /DB insert   . /, /   ."
        }
      },
      "required": [
        "id",
        "rule_type",
        "description",
        "predicate_json",
        "created_at"
      ],
      "description": "  //   .\n\n or        (JSON  ) . , ,       /       .\n\n: Prisma  ai_ecommerce_discount_rule -  ,  ,        .\n\n rule_type, description,    ,        .   (,  )   ."
    },
    "IAiEcommerceDiscountRule.ICreate": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "    .\n\n: 'percentage'/'fixed_amount'/'stacking'      , //DB /    ."
        },
        "description": {
          "type": "string",
          "description": "   //  . , , ,   , //    ."
        },
        "predicate_json": {
          "type": "string",
          "description": "     ,      (JSON)\n\n: '{\"min_amount\":10000, \"category\":[\"Food\",\"Electronics\"]}'\n\n//      JSON , Optional  ( {}  null  )"
        }
      },
      "required": [
        "rule_type",
        "description",
        "predicate_json"
      ],
      "description": "  /   DTO.   type, description,  JSON .\n\n   // /     , DB/      .\n\n: Prisma schema ai_ecommerce_discount_rule,     ."
    },
    "IAiEcommerceDiscountRule.IUpdate": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "    type.        , type    ."
        },
        "description": {
          "type": "string",
          "description": "  .  (Memo)  ."
        },
        "predicate_json": {
          "type": "string",
          "description": "  (JSON  ,       )."
        }
      },
      "required": [
        "rule_type",
        "description",
        "predicate_json"
      ],
      "description": "      DTO.  //   ,        .\n\n   //       ,   /    .\n\n: ai_ecommerce_discount_rule,  /    ."
    },
    "IAiEcommerceFavorite.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   UUID.\n\n ()     . null       ."
            },
            {
              "type": "null"
            }
          ],
          "description": "   UUID.\n\n ()     . null       ."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   UUID.\n\n  ()     . null   ."
            },
            {
              "type": "null"
            }
          ],
          "description": "   UUID.\n\n  ()     . null   ."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " ()    UUID.   null."
            },
            {
              "type": "null"
            }
          ],
          "description": " ()    UUID.   null."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "    (1 )."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "default": 20,
          "description": "    ( 100)."
        },
        "sort_key": {
          "oneOf": [
            {
              "type": "string",
              "description": "   (: created_at, name ). null    ."
            },
            {
              "type": "null"
            }
          ],
          "description": "   (: created_at, name ). null    ."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": " . : asc, : desc.  desc()."
            },
            {
              "const": "desc",
              "description": " . : asc, : desc.  desc()."
            }
          ],
          "description": " . : asc, : desc.  desc()."
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "()    DTO.\n\n, ,       ,  / .    null ( )."
    },
    "IAiEcommercePageIAiEcommerceFavorite": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceFavorite"
          },
          "description": "()   ( ).\n\n row IAiEcommerceFavorite ,  --  ."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "+  (/favorite)   .\n\n    pagination/   . (: IPage   )\n\n:  API   Wrapper."
    },
    "IAiEcommerceFavorite": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": " row   (PK/UUID).\n\n DB PK,     / ."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": " () UUID.\n\n()    ,       profile   ."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "   UUID.\n\n()        ID."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "/  grouping  connection key (nullable)\n\n favorites   (  null)"
            },
            {
              "type": "null"
            }
          ],
          "description": "/  grouping  connection key (nullable)\n\n favorites   (  null)"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "     (iso8601)."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "created_at"
      ],
      "description": "()  row DTO.\n\n, , ()  ,  timestamp . (: ai_ecommerce_favorite)\n\n CRUD ,    ."
    },
    "IAiEcommerceFavorite.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "()    UUID.\n\n    /  ,    ."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "  UUID.\n\n  ,  fav  ."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "()  /   UUID. null    ."
            },
            {
              "type": "null"
            }
          ],
          "description": "()  /   UUID. null    ."
        }
      },
      "required": [
        "customer_id",
        "product_id"
      ],
      "description": "  row   DTO.\n\n--/   row ."
    },
    "IAiEcommerceFavorite.IUpdate": {
      "type": "object",
      "properties": {
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": " (folder/grouping) UUID.\n\n   ()   , null   ."
            },
            {
              "type": "null"
            }
          ],
          "description": " (folder/grouping) UUID.\n\n   ()   , null   ."
        }
      },
      "required": [
        "favorite_tag_id"
      ],
      "description": "   ,        DTO.\n\n     . ( favorites row product/customer  )"
    },
    "IAiEcommerceFavoriteTag.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   UUID. null  (Tag Owner ) ."
            },
            {
              "type": "null"
            }
          ],
          "description": "   UUID. null  (Tag Owner ) ."
        },
        "name": {
          "oneOf": [
            {
              "type": "string",
              "description": "()  .  ,  .  null."
            },
            {
              "type": "null"
            }
          ],
          "description": "()  .  ,  .  null."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": " (1 )."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "default": 20,
          "description": " row ( 20,  100)."
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": " (favorite group/tag/folder)   DTO.\n\n, , ,    ."
    },
    "IPageIAiEcommerceFavoriteTag": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceFavoriteTag"
          },
          "description": "  () "
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": " favorite tag /   DTO.\n\n     ( IPage  )."
    },
    "IAiEcommerceFavoriteTag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": " row UUID(PK).\n\n , DB ."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "  () UUID."
        },
        "name": {
          "type": "string",
          "description": "  ( )\n\n/   UI ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "  (ISO8601).        ."
        }
      },
      "required": [
        "id",
        "customer_id",
        "name",
        "created_at"
      ],
      "description": " (favorite group/folder)  row DTO.\n\n/, , UUID,  .       ."
    },
    "IAiEcommerceFavoriteTag.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "   UID.\n\n    /  ,  ( name )."
        },
        "name": {
          "type": "string",
          "description": " ( ).\n\n        . //     ."
        }
      },
      "required": [
        "customer_id",
        "name"
      ],
      "description": "  ()   DTO.   .    ."
    },
    "IAiEcommerceFavoriteTag.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The new name for the favorite tag.\n\nRepresents the updated label for this favorite grouping (e.g., 'Gift Ideas', 'To Buy'). Must be unique per customer. Refer to the 'name' column in the ai_ecommerce_favorite_tag table."
        }
      },
      "required": [
        "name"
      ],
      "description": "Request object for updating a favorite tag in ai_ecommerce_favorite_tag. Used to change a tag's name. Only allowed for the owner of the tag. Fully normalized; only properties allowed by business logic are present."
    },
    "IAiEcommerceRecommendation.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for the customer to retrieve recommendations for.\n\nCorresponds to the 'customer_id' column in ai_ecommerce_recommendation. Only recommendations for this customer will be retrieved."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for a specific product to filter recommendations by.\n\nAllows querying recommendations for a particular product within the set of recommendations. Corresponds to the 'product_id' column."
        },
        "snapshot_id": {
          "type": "string",
          "format": "uuid",
          "description": "If supplied, filters recommendations tied to this personalization snapshot. Used for context restoration or targeted analytics. Null or omitted for global search."
        },
        "reason_code": {
          "type": "string",
          "description": "The reason code filter, for retrieving recommendations connected to specific AI-driven reasons (e.g., 'similar_items', 'trending').\n\nMatches 'reason_code' column in ai_ecommerce_recommendation."
        },
        "recommended_after": {
          "type": "string",
          "format": "date-time",
          "description": "Show recommendations created after this timestamp. ISO8601 format; corresponds to filtering on 'recommended_at' (greater than).\n\nOptional for paged/batched export."
        },
        "recommended_before": {
          "type": "string",
          "format": "date-time",
          "description": "Show recommendations created before this timestamp. ISO8601 format; used for paged export or rolling analytics windows."
        },
        "limit": {
          "type": "integer",
          "description": "Maximum number of records to fetch in this page/batch. For pagination control. Default and range governed by system/service."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into the result set for pagination purposes. Used for skipping previous pages of results."
        },
        "sort_by": {
          "type": "string",
          "description": "Sort key for results (e.g., 'recommended_at', 'reason_code').\n\nSpecifies which column to sort the results by."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
            },
            {
              "const": "desc",
              "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
            }
          ],
          "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
        }
      },
      "description": "Request type for retrieving/paginating/searching ai_ecommerce_recommendation records. Allows search, filter, and pagination by customer, product, snapshot, reason, and recommended_at. Used in PATCH list endpoints for recommendations.",
      "required": []
    },
    "IPageIAiEcommerceRecommendation": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Number of items per page."
        },
        "total": {
          "type": "integer",
          "description": "Total number of available matching recommendations."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceRecommendation"
          },
          "description": "Array of recommendation records for this page."
        }
      },
      "required": [
        "page",
        "limit",
        "total",
        "data"
      ],
      "description": "Paginated result structure for arrays of IAiEcommerceRecommendation entities. Used on PATCH list endpoints and similar query interfaces. Includes pagination metadata and the result array."
    },
    "IAiEcommerceRecommendation": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the recommendation record (UUID).\n\nMatches 'id' in ai_ecommerce_recommendation."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer receiving this recommendation.\n\nMatches 'customer_id' in ai_ecommerce_recommendation."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being recommended, refers to ai_ecommerce_product.id."
        },
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional ID of the personalization snapshot that contextually informed this recommendation; nullable."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional ID of the personalization snapshot that contextually informed this recommendation; nullable."
        },
        "recommended_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime (ISO 8601) when this recommendation was logged/generated. Column: 'recommended_at'."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional reason code for why this recommendation was made (e.g., 'trending', 'similar_items'). Null for baseline system recommendations."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional reason code for why this recommendation was made (e.g., 'trending', 'similar_items'). Null for baseline system recommendations."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "recommended_at"
      ],
      "description": "Detailed schema for an ai_ecommerce_recommendation record. Each entry provides a product recommendation for a specific customer, possibly linked to system snapshots and annotated with a reason_code. Used to drive personalized catalogs, analytics, and auditing. Columns mapped directly from ai_ecommerce_recommendation table."
    },
    "IAiEcommerceRecommendation.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the customer receiving this recommendation. Must reference an existing ai_ecommerce_customer row."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the product to recommend. References ai_ecommerce_product."
        },
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional personalization snapshot that led to this recommendation (nullable, references ai_ecommerce_snapshot)."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional personalization snapshot that led to this recommendation (nullable, references ai_ecommerce_snapshot)."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional code describing the AI/business reason for recommendation, such as 'trending','similar_items', etc."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional code describing the AI/business reason for recommendation, such as 'trending','similar_items', etc."
        }
      },
      "required": [
        "customer_id",
        "product_id"
      ],
      "description": "Input schema for creating a new recommendation entry in ai_ecommerce_recommendation. Used by admin tools, system automation, or personalization engines to record a new recommendation. All IDs must reference existing entities and reason_code is optional."
    },
    "IAiEcommerceRecommendation.IUpdate": {
      "type": "object",
      "properties": {
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Set or change the personalization snapshot related to this recommendation; nullable for removal."
            },
            {
              "type": "null"
            }
          ],
          "description": "Set or change the personalization snapshot related to this recommendation; nullable for removal."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Update the AI/business reason for this recommendation. Null to clear reason."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update the AI/business reason for this recommendation. Null to clear reason."
        }
      },
      "description": "Schema for partial update of an ai_ecommerce_recommendation row. Only snapshot_id and reason_code are mutable fields. Used for corrections or admin-side annotation. Other fields (IDs, main references) are never updatable.",
      "required": []
    },
    "IAiEcommerceSnapshot.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer whose snapshots to search."
        },
        "snapshot_type": {
          "type": "string",
          "description": "Filter snapshots by this type (e.g., 'favorites', 'settings'). Corresponds to ai_ecommerce_snapshot.snapshot_type."
        },
        "taken_after": {
          "type": "string",
          "format": "date-time",
          "description": "Search for snapshots taken after this timestamp."
        },
        "taken_before": {
          "type": "string",
          "format": "date-time",
          "description": "Limit results to snapshots taken before this timestamp."
        },
        "limit": {
          "type": "integer",
          "description": "Maximum results per page."
        },
        "offset": {
          "type": "integer",
          "description": "Offset of results (for pagination)."
        }
      },
      "description": "Request type for PATCH/list operation on ai_ecommerce_snapshots. Allows filtering and paginating user snapshots for personalization, sync, analytics.",
      "required": []
    },
    "IPageIAiEcommerceSnapshot": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Items per page."
        },
        "total": {
          "type": "integer",
          "description": "Total available matching snapshots."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSnapshot"
          },
          "description": "Array of snapshot records for current page."
        }
      },
      "required": [
        "page",
        "limit",
        "total",
        "data"
      ],
      "description": "Paginated result type for arrays of IAiEcommerceSnapshot, as used in PATCH/lists. Includes result set, metadata, and count info."
    },
    "IAiEcommerceSnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the personalization snapshot (UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the owning customer (cross-reference ai_ecommerce_customer)."
        },
        "snapshot_type": {
          "type": "string",
          "description": "Type string describing what this snapshot captures: e.g., 'favorites', 'settings', etc."
        },
        "taken_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the snapshot was taken (ISO 8601)."
        },
        "blob_uri": {
          "type": "string",
          "description": "URI (typically to S3/blob storage) where the snapshot's binary data is held."
        }
      },
      "required": [
        "id",
        "customer_id",
        "snapshot_type",
        "taken_at",
        "blob_uri"
      ],
      "description": "Detailed schema for a personalization snapshot (ai_ecommerce_snapshot). Snapshots capture user state for sync, backup, or analytics. Key columns directly map to ai_ecommerce_snapshot fields."
    },
    "IAiEcommerceSnapshot.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the target customer for this snapshot (must exist)."
        },
        "snapshot_type": {
          "type": "string",
          "description": "String describing the business/type for the snapshot (e.g., 'favorites','settings')."
        },
        "taken_at": {
          "type": "string",
          "format": "date-time",
          "description": "Exact ISO datetime when snapshot was created."
        },
        "blob_uri": {
          "type": "string",
          "description": "Blob/CSP URI for the binary snapshot data."
        }
      },
      "required": [
        "customer_id",
        "snapshot_type",
        "taken_at",
        "blob_uri"
      ],
      "description": "Request type for new snapshot creation. Used when a new snapshot must be stored, e.g., during sync, analytics, or config backup. All required fields must be provided."
    },
    "IAiEcommerceSnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "blob_uri": {
          "type": "string",
          "description": "Update the URI where the snapshot's data is stored.\n\nUsed for rehosting/migration or stripping down corrupted URIs during admin repair flows. Only mutable field per schema."
        }
      },
      "description": "Schema for updating a snapshot record, typically just the blob_uri (cannot alter id/customer/snapshot_type/taken_at). Used for admin-side repair or migration.",
      "required": []
    },
    "IAiEcommercePersonalizationConfig.IRequest": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for configs created/set by this admin actor."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Show configs scoped to this customer."
        },
        "config_key": {
          "type": "string",
          "description": "Search for only configs with this key name (targeted/toggle search)."
        },
        "applied_after": {
          "type": "string",
          "format": "date-time",
          "description": "Only configs applied after this timestamp."
        },
        "applied_before": {
          "type": "string",
          "format": "date-time",
          "description": "Filter to configs with applied_at date on or before this value."
        },
        "limit": {
          "type": "integer",
          "description": "Max records per page (paging)."
        },
        "offset": {
          "type": "integer",
          "description": "Skip this number of records (for pagination)."
        }
      },
      "description": "Search/filter request structure for listing/paging ai_ecommerce_personalization_config records. Used by admin or advanced UX for config listing feature. All paging/filtering fields map to columns on ai_ecommerce_personalization_config.",
      "required": []
    },
    "IPageIAiEcommercePersonalizationConfig": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePersonalizationConfig"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Pageable container for ai_ecommerce_personalization_config records.\n\nThis schema represents a paginated result set of personalization config entities as defined in ai_ecommerce_personalization_config. The `pagination` object provides metadata about the current page, total records, limits, and pages (using the standard IPage.IPagination), while `data` contains an array of personalization config entities. Referenced from paginated search and list endpoints for personalization configs."
    },
    "IAiEcommercePersonalizationConfig": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique system-generated id for this config row. Serves as the primary key for ai_ecommerce_personalization_config."
        },
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the administrator who set/applied this config. References ai_ecommerce_administrator."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
            }
          ],
          "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
        },
        "config_key": {
          "type": "string",
          "description": "Name specifying which setting is being applied, such as AI model version, feature flag, or UI parameter. Must be unique for given customer/timestamp."
        },
        "config_value": {
          "type": "string",
          "description": "Value associated with config key, usually a string or URI. The actual content is interpreted by system logic (model version, personalization rule, etc)."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when config went into effect. Used for audit, versioning, and compliance tracking."
        }
      },
      "required": [
        "id",
        "admin_id",
        "config_key",
        "config_value",
        "applied_at"
      ],
      "description": "ai_ecommerce_personalization_config entity definition.\n\nImplements per-user or global personalization configuration options for the AI-ready shopping mall backend. Used to store key/value parameter settingssuch as personalization model version, feature flags, tuning parameterstogether with administrative and customer context. Referenced from analytics, UI, and audit modules. See Prisma table for full compliance and data normalization guidance."
    },
    "IAiEcommercePersonalizationConfig.ICreate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "Administrator who creates/applies this config."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional customer id for per-user config, null if system/global config."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional customer id for per-user config, null if system/global config."
            }
          ],
          "description": "Optional customer id for per-user config, null if system/global config."
        },
        "config_key": {
          "type": "string",
          "description": "Configuration key, must be unique per customer/time."
        },
        "config_value": {
          "type": "string",
          "description": "Value for the configuration key."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the config is applied/created."
        }
      },
      "required": [
        "admin_id",
        "config_key",
        "config_value",
        "applied_at"
      ],
      "description": "Payload for creating a new ai_ecommerce_personalization_config entryrecords configuration key, value, and assignment context. Fields must enforce uniqueness and business rules as required by the schema comments."
    },
    "IAiEcommercePersonalizationConfig.IUpdate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "(Optional) Administrator making the update. If supplied, must reference a valid admin."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Target customer for specific config. Null for global config."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "(Optional) Target customer for specific config. Null for global config."
            }
          ],
          "description": "(Optional) Target customer for specific config. Null for global config."
        },
        "config_key": {
          "type": "string",
          "description": "(Optional) The key to update or set."
        },
        "config_value": {
          "type": "string",
          "description": "(Optional) The new value for the key."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "(Optional) Timestamp when this new config is effective."
        }
      },
      "required": [],
      "description": "Payload to update existing ai_ecommerce_personalization_config rows. Allows partial update of one or more fields (except immutable id). Used for adjusting settings, toggling feature flags, and rolling out new personalization features. At least one of the properties should be present in a valid update payload."
    },
    "IAiEcommercePersonalizationAnalytics.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
            }
          ],
          "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by admin actor. Null for no admin filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by admin actor. Null for no admin filter."
            }
          ],
          "description": "Optionally filter by admin actor. Null for no admin filter."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by product involved in analytics event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by product involved in analytics event."
            }
          ],
          "description": "Optionally filter by product involved in analytics event."
        },
        "event_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
            },
            {
              "type": "null",
              "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
            }
          ],
          "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
        },
        "event_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
            }
          ],
          "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
        },
        "event_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest event timestamp to return (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest event timestamp to return (inclusive)."
            }
          ],
          "description": "Latest event timestamp to return (inclusive)."
        },
        "details_search": {
          "oneOf": [
            {
              "type": "string",
              "description": "Text search within arbitrary details JSON for matching analytics event context."
            },
            {
              "type": "null",
              "description": "Text search within arbitrary details JSON for matching analytics event context."
            }
          ],
          "description": "Text search within arbitrary details JSON for matching analytics event context."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Target page of results, for paging. Defaults to 1 if not specified."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Target page of results, for paging. Defaults to 1 if not specified."
            }
          ],
          "description": "Target page of results, for paging. Defaults to 1 if not specified."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Limit of results per page. Default and maximum governed by system policy."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Limit of results per page. Default and maximum governed by system policy."
            }
          ],
          "description": "Limit of results per page. Default and maximum governed by system policy."
        }
      },
      "required": [],
      "description": "Request schema for listing or searching personalization analytics records (ai_ecommerce_personalization_analytics). All fields optionaltogether support advanced filtering, search, and paging on analytics events."
    },
    "IPageIAiEcommercePersonalizationAnalytics": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePersonalizationAnalytics"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_personalization_analytics records, as returned by search/list APIs.\n\nIncludes metadata for paging and the analytics event data array."
    },
    "IAiEcommercePersonalizationAnalytics": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key: unique analytics event id (UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer/user who triggered the event."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin involved, if any, in analytics event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin involved, if any, in analytics event."
            }
          ],
          "description": "Admin involved, if any, in analytics event."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Product associated with the analytics event, if relevant."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Product associated with the analytics event, if relevant."
            }
          ],
          "description": "Product associated with the analytics event, if relevant."
        },
        "event_type": {
          "type": "string",
          "description": "Event classification string: e.g., 'favorite_add', 'rec_click'. Defines business logic for event."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "When analytics event occurred (creation timestamp)."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
            },
            {
              "type": "null",
              "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
            }
          ],
          "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
        }
      },
      "required": [
        "id",
        "customer_id",
        "event_type",
        "event_at"
      ],
      "description": "Analytics event row for ai_ecommerce_personalization_analytics. Represents one atomic user or admin engagement eventappend-only, strictly 3NF. The entity records core context, event, actor, and time without aggregation. Used in reporting, dashboards, and compliance modules."
    },
    "IAiEcommercePersonalizationAnalytics.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer/user who triggers this event."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin related to this event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin related to this event, if applicable."
            }
          ],
          "description": "Admin related to this event, if applicable."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Product associated with the analytics event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Product associated with the analytics event, if applicable."
            }
          ],
          "description": "Product associated with the analytics event, if applicable."
        },
        "event_type": {
          "type": "string",
          "description": "Type/classification of event: 'favorite_add', 'rec_click', etc."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation timestamp of the event."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "Arbitrary JSON, serialized, for additional event metadata/context."
            },
            {
              "type": "null",
              "description": "Arbitrary JSON, serialized, for additional event metadata/context."
            }
          ],
          "description": "Arbitrary JSON, serialized, for additional event metadata/context."
        }
      },
      "required": [
        "customer_id",
        "event_type",
        "event_at"
      ],
      "description": "Payload to create a new personalization analytics event, as logged in ai_ecommerce_personalization_analytics. All non-required properties are optional; see domain for further business validation."
    },
    "IAiEcommercePersonalizationAnalytics.IUpdate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: update admin context on event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: update admin context on event."
            }
          ],
          "description": "Optional: update admin context on event."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: update product context on event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: update product context on event."
            }
          ],
          "description": "Optional: update product context on event."
        },
        "event_type": {
          "type": "string",
          "description": "(Optional) New event type/classification."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "(Optional) Change timestamp of event."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) New or updated event metadata."
            },
            {
              "type": "null",
              "description": "(Optional) New or updated event metadata."
            }
          ],
          "description": "(Optional) New or updated event metadata."
        }
      },
      "required": [],
      "description": "Partial update (patch) schema for ai_ecommerce_personalization_analytics events. Allows selectively updating mutable fields for an analytics record. All fields optional."
    },
    "IAiEcommerceAuditLogs.IRequest": {
      "type": "object",
      "properties": {
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting customer. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting customer. Null for no filter."
            }
          ],
          "description": "Filter logs by acting customer. Null for no filter."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting seller. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting seller. Null for no filter."
            }
          ],
          "description": "Filter logs by acting seller. Null for no filter."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting admin. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting admin. Null for no filter."
            }
          ],
          "description": "Filter logs by acting admin. Null for no filter."
        },
        "action_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter logs by event/action type."
            },
            {
              "type": "null",
              "description": "Filter logs by event/action type."
            }
          ],
          "description": "Filter logs by event/action type."
        },
        "target_table": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter logs by affected target business table/entity."
            },
            {
              "type": "null",
              "description": "Filter logs by affected target business table/entity."
            }
          ],
          "description": "Filter logs by affected target business table/entity."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by affected business object/entity id."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by affected business object/entity id."
            }
          ],
          "description": "Filter logs by affected business object/entity id."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest timestamp for log creation (inclusive) filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest timestamp for log creation (inclusive) filter."
            }
          ],
          "description": "Earliest timestamp for log creation (inclusive) filter."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest timestamp for log creation (inclusive) filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest timestamp for log creation (inclusive) filter."
            }
          ],
          "description": "Latest timestamp for log creation (inclusive) filter."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Results page number for pagination."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Results page number for pagination."
            }
          ],
          "description": "Results page number for pagination."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Page size/limit for pagination."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Page size/limit for pagination."
            }
          ],
          "description": "Page size/limit for pagination."
        }
      },
      "required": [],
      "description": "Request schema for searching/filtering ai_ecommerce_audit_logs events. All fields optional, serve as filters for various audit analyses. Used for paged/complex audit log queries for compliance, investigation, or business analytics."
    },
    "IPageAiEcommerceAuditLogs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceAuditLogs"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result structure for ai_ecommerce_audit_logs events.\n\nEncapsulates both paging metadata and the audit log records in the result set for compliance, analytics, and platform investigation endpoints."
    },
    "IAiEcommerceAuditLogs": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the audit record (UUID, PK)."
        },
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer who acted (if this event was triggered by customer logic, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer who acted (if this event was triggered by customer logic, else null)."
            }
          ],
          "description": "Customer who acted (if this event was triggered by customer logic, else null)."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller who acted (if this log is about a seller activity, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller who acted (if this log is about a seller activity, else null)."
            }
          ],
          "description": "Seller who acted (if this log is about a seller activity, else null)."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin who acted (if this log is for administrative action, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin who acted (if this log is for administrative action, else null)."
            }
          ],
          "description": "Admin who acted (if this log is for administrative action, else null)."
        },
        "action_type": {
          "type": "string",
          "description": "String code describing the event (e.g., login, update_order, change_role)."
        },
        "target_table": {
          "type": "string",
          "description": "String representing the business entity/table affected by this event."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the primary object involved in the audit (the entity being affected)."
        },
        "description": {
          "type": "string",
          "description": "Brief text description explaining event context/reason for audit entry."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this audit log entry was created."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
            }
          ],
          "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
        }
      },
      "required": [
        "id",
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "ai_ecommerce_audit_logs event entity.\n\nImplements the platform-wide audit logging system for the AI e-commerce backend. Each entry records a specific user/system/admin action, the affected business table/row, and the context and timestamp for forensics, compliance, and investigation."
    },
    "IAiEcommerceAuditLogs.ICreate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_audit_logs   / (log)    .\n\n  (: actor_customer_id, actor_seller_id, actor_admin_id, action_type, target_table, target_id, description, created_at )   .      Prisma         .\n\n         (/  )     ,     /    .",
      "required": []
    },
    "IAiEcommerceAuditLogs.IUpdate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_audit_logs      .\n\n  (: description, action_type )   ,   (:  /, actor  )  .    Prisma    ,   /  ,       .\n\n    /    ,       .",
      "required": []
    },
    "IAiEcommerceSystemEvents.IRequest": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_system_events    //   .\n\nevent_type, target_table,           . \n\n         ,      Prisma  (  )   .\n\n         , ,        RESTful  DTO.",
      "required": []
    },
    "IPageAiEcommerceSystemEvents": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_system_events    ,           ( ,  ,   ) .\n\n (),  ,  /     ,  IPage    ai_ecommerce_system_events    .\n\nUI  ,  /           .",
      "required": []
    },
    "IAiEcommerceSystemEvents": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_system_events        .\n\n    /  (event_type, target_table, target_id, payload_json, created_at )    .   Prisma   ERD    ,  /   .\n\n    ,  ,        .",
      "required": []
    },
    "IAiEcommerceSystemEvents.ICreate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_system_events   //       .\n\n event_type, target_table, target_id, payload_json, created_at   ,   Prisma    /  .\n\n  /     ,   ,          .",
      "required": []
    },
    "IAiEcommerceSystemEvents.IUpdate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_system_events    (immutable)  //    DTO.\n\n  (: payload_json, description ),  (: event_type, created_at, target_table )      .\n\n  / ,      ,         .",
      "required": []
    },
    "IComplianceAudit.IRequest": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_compliance_audits    //     DTO.\n\n  (: audit_type, subject_table, admin_id, status, created_at  ) /       .\n\n  / ,  , ,    .",
      "required": []
    },
    "IPageIComplianceAudit": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_compliance_audits    ,        (/ ,   )   .\n\n  IPage<T>  ,  (),  ,     .",
      "required": []
    },
    "IComplianceAudit": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_compliance_audits     / .\n\n    (audit_type, subject_table, subject_id, status, admin_id, created_at )   ( )  ,  DB          .\n\n:  (//)    / .",
      "required": []
    },
    "IComplianceAudit.ICreate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_compliance_audits      /    DTO.\n\naudit_type, subject_table, subject_id, status, notes, admin_id    , Prisma          .\n\n    /  ,         .",
      "required": []
    },
    "IComplianceAudit.IUpdate": {
      "type": "object",
      "properties": {},
      "description": " . ai_ecommerce_compliance_audits    (, / )  DTO,    .\n\n(audit_type, subject_id, created_at ) , (status), notes, admin_id     .\n\n    ,   ,    ,   Prisma    .",
      "required": []
    },
    "IAuditLog.IRequest": {
      "type": "object",
      "properties": {},
      "description": "        .\n\n       ,     .\n\n   page, limit, sort,       .   Prisma DB   ERD      .\n",
      "required": []
    },
    "IPageIAuditLog": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAuditLog"
          },
          "description": "      ."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "()    .  ,    ,  ,    ."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "      ,        .\n\nDB     ,      ."
    },
    "IAuditLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "   . ai_ecommerce_audit_log  PK(UUID),     .\n\n  ,  ,   /  ."
        },
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   (CUSTOMER)    UUID. null  ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   (CUSTOMER)    UUID. null  ."
            }
          ],
          "description": "   (CUSTOMER)    UUID. null  ."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "      ai_ecommerce_seller  UUID . null / ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "      ai_ecommerce_seller  UUID . null / ."
            }
          ],
          "description": "      ai_ecommerce_seller  UUID . null / ."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "    (ADMIN)    UUID. null  ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "    (ADMIN)    UUID. null  ."
            }
          ],
          "description": "    (ADMIN)    UUID. null  ."
        },
        "action_type": {
          "type": "string",
          "description": "  ()  , ,  .\n: ,  ,  ,  / .   ."
        },
        "target_table": {
          "type": "string",
          "description": "    .\n: ai_ecommerce_order, ai_ecommerce_customer    /  ."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "   ()  UUID.  //     UUID PK."
        },
        "description": {
          "type": "string",
          "description": "       .    ,    ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "     .     ."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  logical  .   null, ()     (soft delete)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  logical  .   null, ()     (soft delete)."
            }
          ],
          "description": "  logical  .   null, ()     (soft delete)."
        }
      },
      "required": [
        "id",
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "    /  (append only)     .\n\nPrisma  ai_ecommerce_audit_log( ai_ecommerce_audit_logs)  ,     //   .\n\n property , ,   Prisma   ERD    .\n"
    },
    "IAuditLog.ICreate": {
      "type": "object",
      "properties": {
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "   () UUID. null ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "   () UUID. null ."
            }
          ],
          "description": "   () UUID. null ."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "  () UUID. null ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "  () UUID. null ."
            }
          ],
          "description": "  () UUID. null ."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "     admin UUID, null ."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "     admin UUID, null ."
            }
          ],
          "description": "     admin UUID, null ."
        },
        "action_type": {
          "type": "string",
          "description": "        (/aktion  )."
        },
        "target_table": {
          "type": "string",
          "description": "  (  )."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "   DB   UUID(PK) ."
        },
        "description": {
          "type": "string",
          "description": "/     ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": " ().  , DB ,      ."
        }
      },
      "required": [
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "  (audit row)  (Post)    DTO.\nPrisma DB ai_ecommerce_audit_log   1:1 ,          .\n"
    },
    "IAuditLog.IUpdate": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "description": "  ()   ."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "  soft delete .      ."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "  soft delete .      ."
            }
          ],
          "description": "  soft delete .      ."
        }
      },
      "required": [
        "description"
      ],
      "description": " (row)  (/ )   PATCH/PUT DTO.\nPrisma        .\n"
    },
    "ISystemEvent.IRequest": {
      "type": "object",
      "properties": {},
      "description": "/   advanced /   DTO.\n\nREST API PATCH body   , event_type, target_table, ,       .\n",
      "required": []
    },
    "IPageISystemEvent": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSystemEvent"
          },
          "description": "     ."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": " (, ,   )."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "       .\n\nPrisma ai_ecommerce_system_events     ,      .\n"
    },
    "IAiEcommerceSystemEvent": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "   (PK). ai_ecommerce_system_events  PK(UUID)."
        },
        "event_type": {
          "type": "string",
          "description": " (: order_created, payment_callback, integration )."
        },
        "target_table": {
          "type": "string",
          "description": "   / (ID )."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "      UUID."
        },
        "payload_json": {
          "type": "string",
          "description": "JSON-  .     /   JSON  ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "     .    /DB   (ISO8601)."
        }
      },
      "required": [
        "id",
        "event_type",
        "target_table",
        "target_id",
        "payload_json",
        "created_at"
      ],
      "description": "     ,  ,      .\n\nPrisma  ai_ecommerce_system_events( ai_ecommerce_system_event)  1:1 , /    , ,  , AI   ."
    },
    "IAiEcommerceSystemEvent.ICreate": {
      "type": "object",
      "properties": {
        "event_type": {
          "type": "string",
          "description": " (Event/Kind) . : order_created, payment_callback, webhook, integration ."
        },
        "target_table": {
          "type": "string",
          "description": "  ( )  ."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "    UUID."
        },
        "payload_json": {
          "type": "string",
          "description": "    JSON  .   context,  ,       ."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "  . ISO 8601  ."
        }
      },
      "required": [
        "event_type",
        "target_table",
        "target_id",
        "payload_json",
        "created_at"
      ],
      "description": " ( )   DTO. Prisma ai_ecommerce_system_events    1:1 .\n"
    },
    "IAiEcommerceSystemEvent.IUpdate": {
      "type": "object",
      "properties": {
        "payload_json": {
          "type": "string",
          "description": "/   () JSON ."
        }
      },
      "required": [
        "payload_json"
      ],
      "description": "   ( )       PATCH/PUT DTO.   ,     /    ."
    },
    "IListAiEcommerceComplianceAudit.Request": {
      "type": "object",
      "properties": {},
      "description": "ai_ecommerce_compliance_audit (/  )   advanced /  DTO.\n\n audit_type, status, subject_table, admin_id, ,        .",
      "required": []
    },
    "IPageIAiEcommerceComplianceAudit": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceComplianceAudit"
          },
          "description": "      ."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": " ( ,     )."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "  (ai_ecommerce_compliance_audit)    .\n\n       ,    //   ."
    },
    "IAiEcommerceComplianceAudit": {
      "type": "object",
      "description": "Represents a detailed compliance audit log record for the AI-ready shopping mall backend. This entity is used to record legal, regulatory, or privacy-related platform events, as described in the compliance sections of the requirements. Reflects the structure of the ai_ecommerce_compliance_audit table.\n\nA compliance audit row captures critical regulatory events (e.g., GDPR erasure requests, PCI reviews, policy changes), records actor (administrator), event type, audit subject, status and notes, and ensures full 3NF normalizationno denormalized aggregates, and every event is atomic.\n\nAll updates, creations, and deletions are tracked for traceability and legal defensibility. Key for regulator review, legal reporting, and integrated audit/export pipelines.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Globally unique identifier for compliance audit record.\n\nReferenced in all future lookups, update, delete, and legal/export logic."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
            }
          ],
          "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
        },
        "audit_type": {
          "type": "string",
          "description": "Type/category of the audit event. Examples: 'GDPR_DELETE', 'PCI_REVIEW', 'POLICY_CHANGE'.\n\nBusiness logic and reporting filter on this property."
        },
        "subject_table": {
          "type": "string",
          "description": "Name of the business table/entity being audited (typically a table name, e.g., 'ai_ecommerce_customer').\n\nAtomic string: not a denormalized object."
        },
        "subject_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the entity (row) under audit; cross-entity for flexible reporting/traceability."
        },
        "status": {
          "type": "string",
          "description": "Outcome/status of the audit event. Examples: 'pending', 'approved', 'rejected', 'processed', etc."
        },
        "notes": {
          "type": "string",
          "description": "Arbitrary context or explanatory notes for the compliance event; atomic, may include rationale, POI, or evidence details."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp; when the audit event was created in the DB for immutable timeline analysis."
        }
      },
      "required": [
        "id",
        "audit_type",
        "subject_table",
        "subject_id",
        "status",
        "notes",
        "created_at"
      ]
    },
    "IAiEcommerceComplianceAudit.ICreate": {
      "type": "object",
      "description": "Request payload for creating a new compliance audit record. Used by operator, admin, or automation to insert a new compliance event per audit rules.\n\nRequired on POST /ai_ecommerce/complianceAudit. All fields except admin_id are required; admin_id may be null for system-level events (automation or workflow triggers).",
      "properties": {
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin (actor) responsible for the compliance event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin (actor) responsible for the compliance event, if applicable."
            }
          ],
          "description": "Admin (actor) responsible for the compliance event, if applicable."
        },
        "audit_type": {
          "type": "string",
          "description": "Audit type; required business logic taxonomy (e.g., 'GDPR_DELETE')."
        },
        "subject_table": {
          "type": "string",
          "description": "Target table/entity under compliance review."
        },
        "subject_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID for subject under audit (row/entity)."
        },
        "status": {
          "type": "string",
          "description": "Initial event status: typically 'pending', 'initiated', or business-defined."
        },
        "notes": {
          "type": "string",
          "description": "Context, rationale, or documentation for compliance event."
        }
      },
      "required": [
        "audit_type",
        "subject_table",
        "subject_id",
        "status",
        "notes"
      ]
    },
    "IAiEcommerceComplianceAudit.IUpdate": {
      "type": "object",
      "description": "Payload for updating mutable fields of a compliance audit log entry. Used on PUT for update (e.g., status change, appending legal notes).\n\nImmutable fields on main record (ID, audit_type, subject_table, subject_id, created_at) cannot be altered. Updatable fields include status and notes (e.g., after review, compliance update, external audit, or legal outcome).\n\nBusiness logic prohibits update to non-permitted fieldsschema-compliant request yields only legal changes per audit model.",
      "properties": {
        "status": {
          "type": "string",
          "description": "Updated status for audit event (e.g., 'approved', 'rejected', 'processed')."
        },
        "notes": {
          "type": "string",
          "description": "Additional or corrected notes/context for the audit event."
        }
      },
      "required": [
        "status",
        "notes"
      ]
    },
    "IMvCommunityLastActivity.IRequest": {
      "type": "object",
      "description": "Payload for searching or filtering community last-activity records from the materialized view mv_community_last_activity. Used as the request body in PATCH list or search endpoints.\n\nFields enable flexible dashboard, reporting, or analytics queries on activity type, customer id, entity id, activity intervals, with pagination and sort. Supports integration with advanced analytics or AI workflows to fetch cohort-specific or date-range community activity slices.\n\nMay include any filterable, indexed columns from the ERD/Prisma definition of mv_community_last_activity, and pagination controls for result management.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
            }
          ],
          "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context for activity filtering, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context for activity filtering, if any."
            }
          ],
          "description": "Thread context for activity filtering, if any."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry context for filtering."
            }
          ],
          "description": "Inquiry context for filtering."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review context for filtering."
            }
          ],
          "description": "Review context for filtering."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment context for filtering."
            }
          ],
          "description": "Comment context for filtering."
        },
        "last_activity_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Activity type string enum'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
            },
            {
              "type": "null",
              "description": "Activity type string enum'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
            }
          ],
          "description": "Activity type string enum'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
        },
        "last_activity_at_gte": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
            }
          ],
          "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
        },
        "last_activity_at_lte": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
            }
          ],
          "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
        },
        "sort_by": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
            },
            {
              "type": "null",
              "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
            }
          ],
          "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            },
            {
              "const": "desc",
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            }
          ],
          "description": "Sort order: enum 'asc', 'desc', or null (default)."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page number for paginated query."
            },
            {
              "type": "null",
              "description": "Page number for paginated query."
            }
          ],
          "description": "Page number for paginated query."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Results per page for pagination (default and/or max limits apply)."
            },
            {
              "type": "null",
              "description": "Results per page for pagination (default and/or max limits apply)."
            }
          ],
          "description": "Results per page for pagination (default and/or max limits apply)."
        }
      },
      "required": []
    },
    "IPageIMvCommunityLastActivity": {
      "type": "object",
      "description": "Paginated result wrapper for mv_community_last_activity records, supporting efficient dashboard, analytics, or bulk reporting access. Used as the standard response container for PATCH list/search endpoints. \n\nContains a 'data' array of mv_community_last_activity objects (atomically-typed per entity model), and a 'pagination' metadata object outlining paging info such as limit, current page, total records, and total pages. Strictly normalized: all aggregates must be computed externally/elsewhere except for count metadata.\n\nUsed to return a scrollable/browseable result set to UIs or reporting tools.",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Paging metadata (current, limit, total records, total pages) for analytics result context."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IMvCommunityLastActivity"
          },
          "description": "Array of mv_community_last_activity result objects for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ]
    },
    "IMvCommunityLastActivity": {
      "type": "object",
      "description": "Atomic read-only record of last community activity snapshot, per the mv_community_last_activity materialized view. Used to display cross-entity, cross-domain activity in dashboards, AI cohort analytics, or customer engagement reports.\n\nEach row represents one user's/entity's most recent activity for a given context (thread, inquiry, review, comment, etc), supporting fast lookup without denormalized data. All entity lookups are by foreign key, atomic per 3NF, with strict typing on activity_type and datetime values.\n\nCannot be mutated except via refresh process (MV update), not via business logic. Direct POST/PUT/DELETE only in exceptional admin/analytics loops.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Stable unique identifier for this last activity entry. Keys all dashboard/report joins and analytics drilldowns."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer/user context for this activity. Null for record not tied to a specific user."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer/user context for this activity. Null for record not tied to a specific user."
            }
          ],
          "description": "Customer/user context for this activity. Null for record not tied to a specific user."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context entity, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context entity, if any."
            }
          ],
          "description": "Thread context entity, if any."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment entity id, if any."
            }
          ],
          "description": "Comment entity id, if any."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry entity id, if any."
            }
          ],
          "description": "Inquiry entity id, if any."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review entity id, if any."
            }
          ],
          "description": "Review entity id, if any."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Type/enum string describing the activity: 'comment', 'review', 'thread', etc."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when last activity was recorded for this context scope (UTC/ISO8601)."
        }
      },
      "required": [
        "id",
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "IMvCommunityLastActivity.ICreate": {
      "type": "object",
      "description": "Payload for inserting a new row into mv_community_last_activity (when supported by writable view or during admin repair). Used to seed the view with known state or for advanced analytics. All fields mirror the core entity definition.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for user/customer contextnull for entity-level activity."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for user/customer contextnull for entity-level activity."
            }
          ],
          "description": "FK for user/customer contextnull for entity-level activity."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for thread context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for thread context."
            }
          ],
          "description": "FK for thread context."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for comment context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for comment context."
            }
          ],
          "description": "FK for comment context."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for inquiry context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for inquiry context."
            }
          ],
          "description": "FK for inquiry context."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for review context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for review context."
            }
          ],
          "description": "FK for review context."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Activity type, as enumerated per dashboard context ('comment', 'review', 'thread', etc)."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 UTC time for last activity (activity timestamp)."
        }
      },
      "required": [
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvCommunityLastActivity.IUpdate": {
      "type": "object",
      "description": "Payload for updating (full replace/PUT) of a mvCommunityLastActivity entity in the materialized view (when admin/analytics endpoint allows direct mutation). Used only in advanced, privileged analytics repair flows, not normal business logic. Fields must match the main entity structure by schema.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for user/customer scope."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for user/customer scope."
            }
          ],
          "description": "FK for user/customer scope."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread FK."
            }
          ],
          "description": "Thread FK."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment FK."
            }
          ],
          "description": "Comment FK."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry FK."
            }
          ],
          "description": "Inquiry FK."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review FK."
            }
          ],
          "description": "Review FK."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Type of activity."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp when last activity occurred (update/PUT replaces this value)."
        }
      },
      "required": [
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvCommunityLastActivity": {
      "type": "object",
      "description": "Entity definition for mvCommunityLastActivitya materialized view row recording the last community activity for a user or entity. Used by dashboards, analytics, and AI pipelines for rapid access to engagement signals.\n\nFields mirror the base table/view: all FKs are atomic, activity type is a string enum, and activity time is an ISO date. Any modification (PUT/POST) only in advanced admin/analytics flows.\n\nThis schema is used for full entity representation in GET, listing, and mutation endpoints.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique primary key of the last activity record; immutable, UUIDv4."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
            }
          ],
          "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context identifier (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context identifier (nullable)."
            }
          ],
          "description": "Thread context identifier (nullable)."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment entity context/fk (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment entity context/fk (nullable)."
            }
          ],
          "description": "Comment entity context/fk (nullable)."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry reference if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry reference if present."
            }
          ],
          "description": "Inquiry reference if present."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review reference if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review reference if present."
            }
          ],
          "description": "Review reference if present."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Atomic string describing the activity type; used by analytics and dashboards for faceting/reporting."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp marking the last activity event; ISO-8601 UTC."
        }
      },
      "required": [
        "id",
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvDailyStats.IRequest": {
      "type": "object",
      "description": "Request object for searching or filtering records in the mv_daily_stats materialized analytics view. Used in PATCH endpoints to filter daily statistics for platform analytics, dashboards, or reporting.\n\nSupports flexible filtering for date, order_count, revenue_amount, or login/signups/review count intervals, with pagination and sort options for custom analytics consumption.",
      "properties": {
        "stat_date_gte": {
          "oneOf": [
            {
              "type": "string",
              "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
            },
            {
              "type": "null",
              "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
            }
          ],
          "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
        },
        "stat_date_lte": {
          "oneOf": [
            {
              "type": "string",
              "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
            },
            {
              "type": "null",
              "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
            }
          ],
          "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
        },
        "min_order_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Minimum order count for analytic filtering (null for none)."
            },
            {
              "type": "null",
              "description": "Minimum order count for analytic filtering (null for none)."
            }
          ],
          "description": "Minimum order count for analytic filtering (null for none)."
        },
        "max_order_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Maximum order count for analytic filtering (null for none)."
            },
            {
              "type": "null",
              "description": "Maximum order count for analytic filtering (null for none)."
            }
          ],
          "description": "Maximum order count for analytic filtering (null for none)."
        },
        "min_revenue_amount": {
          "oneOf": [
            {
              "type": "number",
              "description": "Minimum revenue amount filter."
            },
            {
              "type": "null",
              "description": "Minimum revenue amount filter."
            }
          ],
          "description": "Minimum revenue amount filter."
        },
        "max_revenue_amount": {
          "oneOf": [
            {
              "type": "number",
              "description": "Maximum revenue amount filter."
            },
            {
              "type": "null",
              "description": "Maximum revenue amount filter."
            }
          ],
          "description": "Maximum revenue amount filter."
        },
        "min_login_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum login count."
            },
            {
              "type": "null",
              "description": "Filter by minimum login count."
            }
          ],
          "description": "Filter by minimum login count."
        },
        "max_login_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum login count."
            },
            {
              "type": "null",
              "description": "Filter by maximum login count."
            }
          ],
          "description": "Filter by maximum login count."
        },
        "min_signups_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum signups count."
            },
            {
              "type": "null",
              "description": "Filter by minimum signups count."
            }
          ],
          "description": "Filter by minimum signups count."
        },
        "max_signups_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum signups count."
            },
            {
              "type": "null",
              "description": "Filter by maximum signups count."
            }
          ],
          "description": "Filter by maximum signups count."
        },
        "min_review_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum review count."
            },
            {
              "type": "null",
              "description": "Filter by minimum review count."
            }
          ],
          "description": "Filter by minimum review count."
        },
        "max_review_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum review count."
            },
            {
              "type": "null",
              "description": "Filter by maximum review count."
            }
          ],
          "description": "Filter by maximum review count."
        },
        "sort_by": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
            },
            {
              "type": "null",
              "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
            }
          ],
          "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order (asc/desc/null)."
            },
            {
              "const": "desc",
              "description": "Sort order (asc/desc/null)."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": "Sort order (asc/desc/null)."
            }
          ],
          "description": "Sort order (asc/desc/null)."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page number for pagination (null for default)."
            },
            {
              "type": "null",
              "description": "Page number for pagination (null for default)."
            }
          ],
          "description": "Page number for pagination (null for default)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page limit."
            },
            {
              "type": "null",
              "description": "Page limit."
            }
          ],
          "description": "Page limit."
        }
      },
      "required": []
    },
    "IPageMvDailyStats": {
      "type": "object",
      "description": "Paginated result set for mvDailyStats analytics view records. Used in API responses as the standard structure for listing query results in PATCH/list endpoints for the analytics dashboard or reporting interfaces.\n\nAggregation or business intelligence tools consume this page structure, which includes both data (array of mvDailyStats) and pagination/count metadatatotal new records, current page, page size, total count, etc.",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Metadata for requested pagination (current, limit, total records/pages)."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/mvDailyStats"
          },
          "description": "Array of mvDailyStats records returned for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ]
    },
    "mvDailyStats": {
      "type": "object",
      "description": "Single row from ai_ecommerce.mv_daily_stats materialized analytics view. Represents platform-wide aggregation of daily sales, orders, logins, signups, and reviews for a single calendar day. Used as the atomic entity in analytics dashboards, statistical charting, reporting/reconciliation, and AI/ML input sets.\n\nDenormalization is permitted here for performance (each field is an aggregate snapshot for the day).",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique ID for stats row; UUID of the analytics view entry."
        },
        "stat_date": {
          "type": "string",
          "description": "Date for this record, format 'YYYY-MM-DD' (ISO) as stringkey for daily analytics."
        },
        "order_count": {
          "type": "integer",
          "description": "Total number of orders on this date."
        },
        "revenue_amount": {
          "type": "number",
          "description": "Summed order/revenue amount (platform currency/exchange base)."
        },
        "login_count": {
          "type": "integer",
          "description": "Number of distinct logins (unique users) on this day."
        },
        "signups_count": {
          "type": "integer",
          "description": "Aggregate users registered on this date."
        },
        "review_count": {
          "type": "integer",
          "description": "Number of reviews written on this date."
        }
      },
      "required": [
        "id",
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ]
    },
    "mvDailyStats.ICreate": {
      "type": "object",
      "properties": {
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) representing the day for which the statistics are recorded. Used as the primary reference date for daily aggregation in analytics dashboards and reporting tools.\n\nShould follow the ISO 8601 standard and match business regional settings. Examples: '2025-07-01', '2024-12-31'."
        },
        "order_count": {
          "type": "integer",
          "description": "The number of orders placed on the given stat_date. Aggregated from order data for reporting, KPI dashboards, and trend analytics.\n\nMust be a non-negative integer. For example: 100."
        },
        "revenue_amount": {
          "type": "number",
          "format": "double",
          "description": "The total revenue (sum of order amounts) for the day. Used in financial reporting, analytics, and trend monitoring.\n\nRepresents the sum in the platform's base currency (usually KRW, USD, etc.). Should match double-precision floating-point format. Examples: 1250000.75."
        },
        "login_count": {
          "type": "integer",
          "description": "Total unique user logins registered on the specific stat_date. Supports platform engagement and analytics use cases.\n\nMust be non-negative. Example: 250."
        },
        "signups_count": {
          "type": "integer",
          "description": "The number of new account registrations that occurred on the stat_date. Supports growth, onboarding, and user acquisition metrics for analytics and admin dashboards.\n\nShould be a non-negative integer (e.g., 20)."
        },
        "review_count": {
          "type": "integer",
          "description": "Number of new product reviews posted on the stat_date. Used for engagement analytics and platform health reporting.\n\nShould be non-negative. For example: 10."
        }
      },
      "required": [
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ],
      "description": "Creation structure for mvDailyStats, representing a day's aggregated analytics. Must include all fields for atomic, non-aggregated reporting. Derived from Prisma schema mv_daily_stats table and described for compliance/audit in analytics reporting. All fields are atomic and required."
    },
    "mvDailyStats.IUpdate": {
      "type": "object",
      "properties": {
        "stat_date": {
          "type": "string",
          "description": "ISO date (YYYY-MM-DD) for the stats row. See mvDailyStats.ICreate for description."
        },
        "order_count": {
          "type": "integer",
          "description": "Updated order count for this day. See mvDailyStats.ICreate for description."
        },
        "revenue_amount": {
          "type": "number",
          "format": "double",
          "description": "Updated revenue for this day. See mvDailyStats.ICreate for description."
        },
        "login_count": {
          "type": "integer",
          "description": "Updated login count for this day. See mvDailyStats.ICreate for description."
        },
        "signups_count": {
          "type": "integer",
          "description": "Updated signups count for this day. See mvDailyStats.ICreate for description."
        },
        "review_count": {
          "type": "integer",
          "description": "Updated review count for this day. See mvDailyStats.ICreate for description."
        }
      },
      "required": [
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ],
      "description": "Update structure for mvDailyStats. Used for entire row replacement as described in PUT endpoint documentation. All fields are required to ensure the materialized view row is completely replaced. Descriptions are as in mvDailyStats.ICreate."
    },
    "mvTrendingProducts.IRequest": {
      "type": "object",
      "properties": {
        "stat_period": {
          "type": "string",
          "description": "The time period granularity for the trending analysis. Typically values: 'daily', 'weekly', 'monthly'. Enables filtering/searching by aggregation level in dashboards or analytics UIs.\n\nBusiness logic expects strict enumeration in implementations."
        },
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) for the trending statistic group. Enables filtering and analytics queries by date window. Follows ISO 8601.\n\nExamples: '2025-07-16', '2025-07-01'."
        },
        "trend_rank": {
          "type": "integer",
          "description": "The minimum or exact rank value for trend filtering (e.g., top 5, 10, etc). Used in analytics to order/filter trending product results.\n\nShould be positive integer if used."
        },
        "product_id": {
          "type": "string",
          "description": "Unique product identifier (UUID format) to filter trending stats for a specific product. Enables focused analytics on a single product's trending performance."
        }
      },
      "description": "Request/filtering parameters for listing/searching mvTrendingProducts analytics records. Used by PATCH endpoint for dashboard analytics, top-product feeds, or AI-powered recommendation systems. Properties correspond to analytics filtering use cases as described in the ERD and endpoint specs.",
      "required": []
    },
    "IPageMvTrendingProducts": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/mvTrendingProducts"
          },
          "description": "Array of mvTrendingProducts analytic records matching the query/filter criteria.\n\nEach item contains all atomic analytics information for a product/stat period/stat date combination."
        },
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number for paginated result. Used in conjunction with limit and total counts for UI and API navigation.\n\nZero or one-based depending on API design."
            },
            "limit": {
              "type": "integer",
              "description": "Number of records per page (page size). Default can be 100; should match request or system policy.\n\nUsed by UI and scripts for batch processing."
            },
            "records": {
              "type": "integer",
              "description": "Total records found for query. Used for pagination controls in APIs and UIs.\n\nAlways non-negative integer."
            },
            "pages": {
              "type": "integer",
              "description": "Total pages of results available for current query and pagination size. Calculated by records and limit."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination metadata following IPage.IPagination structure: current, limit, records, pages."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "Paginated result set for mvTrendingProducts listing/search operations. Includes both array of analytics records and pagination metadata following IPage<I> interface as described in the AI E-Commerce documentation."
    },
    "mvTrendingProducts": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the trending product analytics record. Used as PK for the materialized view row as per ERD."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to the ai_ecommerce_product row for which the trending analytics data is recorded. Required for joining and analytics reporting.\n\nMust match product PK in product catalog."
        },
        "stat_period": {
          "type": "string",
          "description": "Denotes time aggregation period for trending analytics (e.g., 'daily', 'weekly', 'monthly'). Value is typically used as an enum for period grouping.\n\nUsed for dashboard, recommendation, and analytics granularity."
        },
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) for the trending product analytics interval. Used for grouping and time-based reporting.\n\nFollows ISO 8601 business conventions."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Trending rank for this product in the specified period/date. Lower values indicate higher rank (e.g., 1 = top trend, 2, ...)."
        },
        "sales_count": {
          "type": "integer",
          "description": "Total count of sales for this product in the analytical window (stat_period/stat_date). Used for trending calculation and analytics dashboards."
        },
        "views_count": {
          "type": "integer",
          "description": "Total views of the product in the given stat_period/stat_date. Used for popularity scoring and AI recommendation algorithms."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Business-configured composite score for trending products, calculated using sales, views, reviews, and additional analytics fields. Used to order/rank trending products/analytics.\n\nShould reflect normalized or weighted algorithm scoring."
        }
      },
      "required": [
        "id",
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Materialized view record for trending products analytics. Contains all atomic, normalized analytics properties including rank, sales, views, and business composite score. Derived directly from Prisma schema ai_ecommerce_mv_trending_products and ERD specifications."
    },
    "mvTrendingProducts.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to the product being ranked in this trending analytics window. Must correspond to PK in ai_ecommerce_product."
        },
        "stat_period": {
          "type": "string",
          "description": "Period aggregation for trending analytics (enum: 'daily', 'weekly', 'monthly'). Required for analytics aggregation/grouping.\n\nBusiness rules expect system-enforced content."
        },
        "stat_date": {
          "type": "string",
          "description": "Date string (ISO 8601, YYYY-MM-DD) representing the window for trending analytics. Used for filtering, UI display, and analytics grouping."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Rank of this product for this period/date combination. Lower means higher trending position (1 = top trending).\n\nMust be a positive integer."
        },
        "sales_count": {
          "type": "integer",
          "description": "Total number of times the product was sold in this stat period/date. Used in analytics for trend scoring.\n\nNon-negative integer; required for full analytics row."
        },
        "views_count": {
          "type": "integer",
          "description": "Total number of times this product was viewed in the stat window. Used in composite scoring, analytics dashboards, and AI ranking.\n\nMust be non-negative integer."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Composite (algorithmic) score used in trend ranking and AI/ML models. Calculated from sales, views, and engagement stats as per business rule.\n\nShould match normalized or weighted scoring as described in algorithm documentation."
        }
      },
      "required": [
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Create structure for new analytics record in mvTrendingProducts (materialized view). All properties are required for atomic reporting, derived from ERD Prisma schema commented explanations."
    },
    "mvTrendingProducts.IUpdate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference for the product to update trending stats for."
        },
        "stat_period": {
          "type": "string",
          "description": "Period aggregation value ('daily', 'weekly', 'monthly')."
        },
        "stat_date": {
          "type": "string",
          "description": "ISO 8601 date string for stats window."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Updated trending rank for product/stat period/stat date."
        },
        "sales_count": {
          "type": "integer",
          "description": "Updated total sales for trending row."
        },
        "views_count": {
          "type": "integer",
          "description": "Updated total view count for the product window."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Updated composite score for AI/analytics ranking/scoring."
        }
      },
      "required": [
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Update structure for mvTrendingProducts: full replacement of analytics row for a trending product, stat period, and window. All atomic fields required. Used with PUT endpoint, descriptions as in ICreate."
    }
  },
  "authorization": [
    {
      "name": "customer",
      "description": "Individual users who can browse products, place orders, manage favorites, write reviews/inquiries, and access personalized features after authenticating via API. Customers may be members, guests, or external platform users."
    },
    {
      "name": "seller",
      "description": "Authenticated business users who can list, manage, and fulfill products, view analytics, issue coupons, and respond to inquiries or reviews. Sellers manage their product catalogs and order workflow via API."
    },
    {
      "name": "administrator",
      "description": "Platform-wide managers with permissions for system configuration, seller onboarding, channel management, marketing tools, and regulatory/audit modules. Administrators can access all system APIs for operational and analytic purposes."
    }
  ]
}